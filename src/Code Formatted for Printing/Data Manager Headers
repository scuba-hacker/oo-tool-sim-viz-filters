/************************************************************************************** * HEADER FILE: Data Manager.h * PURPOSE		: declare Data Manager class **************************************************************************************/#ifndef _data_manager_h#define _data_manager_h#include "set_input_object.h"																// List node definition files#include "record_object.h"#include "IO_map_object.h"#include "data_set_obj.h"#include "record_object.h"#include "name_object.h"#include "stringobject.h"#include "newstring.h"																			// foundation definition files#include "complex.h"#include "ulist.h"#include <iostream.h>#include <strstream.h>class data_manager{	public:		ulist<record_object> record_list;										// Ascending lexical order on name		ulist<data_set_obj> data_list;											// Ascending lexical order on name		ulist<IO_map_object> map_list;											// Ascending lexical order on name		ulist<set_input_object> set_input_list;							// Ascending lexical order on name						void interface();																										// User Interface		void display_help();																// Display CLI commands on-screen			// Functions for manipulating record_list		status new_record(string_class name, string_class record);					// Add record		status delete_record(string_class name);														// Delete record		void output_record_list();																// Dump record list to cout				// Functions for manipulating data_list		status new_data(string_class name, string_class record, int length);// Add data_set		status delete_data(string_class name);															// Delete data_set		void output_data_list();																// Dump data_set list to cout		// Function to cross-check data manager lists		status check_data_list(string_class data_name, ulist<string_object> inputnames,																		ulist<string_object> mapnames, data_set_obj* &target);				// Functions for manipulating map_list		status new_map(string_class map_name, string_class input_fields,				// Add IO_map									 string_class output_fields);		status delete_map(string_class map_name);																// Del IO_map		void output_map_list();																		// Dump IO_map list to cout				// Functions for manipulating set_input_list		status new_set_input(string_class set_input_name, int lower_i,				// Add set_input												 int upper_i, double start_val, double increment);		status delete_set_input(string_class set_input_name);									// Del set_input		void output_set_input_list();														// Dump set_input list to cout		// Function to check all names in string ulist reference valid set_input objects		status check_set_input_list(ulist<string_object> sourcelist);		void reset_manager();																								// Clear all lists};#endif/************************************************************************************** * HEADER FILE: record_object.h * PURPOSE		: declare record_object class **************************************************************************************/#ifndef _record_object_h#define _record_object_h#include "newstring.h"#include "stringobject.h"#include "ulist.h"#include "define_vars.h"#include <iostream.h>class record_object{	private:		string_class name;																								// Indexing object		ulist<string_object> data;																				// Data object		record_object *next_record_object;																// Used to form list			public:		static string_class undefined_index;				// Holds definition of an undefined index		// functions required by list		record_object() ; 																				// Default constructor		record_object(string_class name_string);									// string_class constructor		// string_class/ulist<string_object> constructor		record_object(string_class name_string, ulist<string_object> data_list);				record_object(record_object &original);										// Copy Constructor		record_object& operator=( record_object &original);				// Overloaded =		string_class get_index();															// Return value of index field		status set_index(const string_class setting);					// Set value of index field 				void set_to_first_index();														// Return first index value		void set_to_next_index(const string_class ref);				// Return next index value		compare compare_index(const string_class index1,			// Return comparison between													const string_class index2);			// two index objects															ulist<string_object> get_data();											// Return value of data field		status set_data(ulist<string_object> setting);				// Set value of data field		compare compare_data(ulist<string_object> name1,			// Return comparison between												 ulist<string_object> name2);			// two data objects		void set_pointer_to(record_object *p);								// Set pointer field		record_object* get_pointer();													// Return value of pointer field		void print_node();																		// Print Node info		// Overloaded output operator for record_object		friend ostream& operator<<(ostream& output_stream, record_object a);};#endif/************************************************************************************** * HEADER FILE: data_set.h * PURPOSE		: declare data_set class **************************************************************************************/#ifndef _data_set_h#define _data_set_h#include "newstring.h"#include "stringobject.h"#include "ulist.h"#include "complex.h"#include "record_object.h"#include "set_input_object.h"class data_set{	private:		string_class record_name;																	// Template record name		int length;																								// Length of data set array		int width;																								// Width of data set array		complex *data_array;																			// Data set array pointer		string_class *fields;																			// Associative Fields pointer			public:		data_set();																										// Default constructor		// record_object/int constructor				data_set(record_object record_ob, const int array_length);		data_set(const data_set &original);														// Copy constructor		data_set& operator=(const data_set &original);								// Overloaded = operator		~data_set();																									// Destructor				string_class get_record_name();																// Return record name		// data_array element access - associative field, non-associative integer index		status get_element_assoc(complex &result, const int index, const string_class field);		status set_element_assoc(const complex new_value, const int index,														 const string_class field);		// data_array element access - non-associative field (int) and index (int)		status get_element(complex &result, const int index, const int field);		status set_element(const complex new_value, const int index, const int field);				status clear_data_array();															// Set all elements to 0+0j				int get_length();																				// Return length of data_array		int get_width();																				// Return width of data_array		void get_fields(string_class *storage);									// Return record names				// Overloaded output operator for data_set object		friend ostream& operator<<(ostream& output_stream, const data_set output_set);};#endif/************************************************************************************** * HEADER FILE: data_set_obj.h * PURPOSE		: declare data_set_obj class **************************************************************************************/#ifndef _data_set_obj_h#define _data_set_obj_h#include "newstring.h"#include "data_set.h"#include "define_vars.h"#include <iostream.h>class data_set_obj{	private:		string_class name;																								// Indexing object		data_set data;																										// Data object		data_set_obj *next_data_set_obj;																	// Used to form list			public:		static string_class undefined_index;				// Holds definition of an undefined index		// functions required by list		data_set_obj(); 																								// Default constructor		data_set_obj(string_class name_string);													// string_class const.		// string_class/data_set constructor		data_set_obj(string_class name_string, data_set data_list);		data_set_obj(data_set_obj &original);														// Copy Constructor		data_set_obj& operator=(data_set_obj &original);								// Overloaded =				string_class get_index();															// Return value of index field		status set_index(const string_class setting);					// Set value of index field 				void set_to_first_index();														// Return first index value		void set_to_next_index(const string_class ref);				// Return next index value		compare compare_index(const string_class index1,			// Return comparison between													const string_class index2);			// two index objects															data_set get_data();																	// Return value of data field		status set_data(const data_set setting);							// Set value of data field		compare compare_data(const data_set name1,						// Return comparison between												 const data_set name2);						// two data objects		void set_pointer_to(data_set_obj *p);									// Set pointer field		data_set_obj* get_pointer();													// Return value of pointer field		void print_node();																		// Print Node info		// Overloaded output operator for data_set_obj		friend ostream& operator<<(ostream& output_stream, const data_set_obj a);		// Get/Set individual elements of data object; not used by ulist...		status get_element_assoc(complex &result, const int index, const string_class field);		status set_element_assoc(const complex new_value, const int index,														 const string_class field);				status get_element(complex &result, const int index, const int field_index);		status set_element(const complex new_value, const int index, const int field_index);				status clear_data_array();															// Set all elements to 0+0j		// Functions for accessing data_set data member		int get_length();		int get_width();		void get_fields(string_class *storage);		// Function for applying set_input to field 'field' of data_set object (data)		status load_real_input(set_input &input, string_class field);		// Function for returning pointer to data_set private data member		data_set *get_data_set_pointer();};#endif/************************************************************************************** * HEADER FILE: set_input.h * PURPOSE		: declare set_input class **************************************************************************************/#ifndef _set_input_h#define _set_input_h#include "newstring.h"#include "ulist.h"#include "stringobject.h"#include "define_vars.h"class set_input{	private:		int lower_index;																				// Lower bound for input data		int upper_index;																				// Upper bound for input data		double start_value;																			// Start value for input data		double incrementer;																			// Incrementer for input data	public:		set_input();																									// Default constructor		set_input(int lower_i,int upper_i,double start_val,double inc);	// Parameterized Constr.		set_input(set_input &original);																// Copy Constructor		set_input& operator=( set_input &original);										// Overloaded = operator		~set_input();																									// Destructor				// Overloaded output operator for set_input object		friend ostream& operator<<(ostream& output_stream, const set_input output_set);		// Access to private data members		void set_parameters( int lower_i, int upper_i, double start_val, double inc);		void get_parameters(int &lower_i, int &upper_i, double &start_val, double &inc);};#endif/************************************************************************************** * HEADER FILE: set_input_object.h * PURPOSE		: declare set_input_object class **************************************************************************************/#ifndef _set_input_object_h#define _set_input_object_h#include "newstring.h"#include "define_vars.h"#include "set_input.h"#include <iostream.h>class set_input_object{	private:		string_class name;																							// Indexing object		set_input load_data;																						// Data object		set_input_object *next_set_input_object;												// Used to form list			public:		static string_class undefined_index;				// Holds definition of an undefined index		// Functions required by list		set_input_object();																				// Default constructor		set_input_object(string_class name_string);								// String_class constructor		// string_class/set_input constructor		set_input_object(string_class name_string, set_input data);		set_input_object(set_input_object &original);									// Copy constructor		set_input_object& operator=(set_input_object &original);			// Overloaded =				string_class get_index();															// Return value of index field		status set_index(const string_class setting);					// Set value of index field 				void set_to_first_index();														// Return first index value		void set_to_next_index(const string_class ref);				// Return next index value		compare compare_index(const string_class index1,			// Return comparison between													const string_class index2);			// two index objects															set_input get_data();																	// Return value of data field		status set_data(const set_input setting);							// Set value of data field		compare compare_data(const set_input name1,						// Return comparison between												 const set_input name2);					// two data objects		void set_pointer_to(set_input_object *p);							// Set pointer field		set_input_object* get_pointer();											// Return value of pointer field		void print_node();																		// Print Node info		// Overloaded output operator for name_object		friend ostream& operator<<(ostream& output_stream, const set_input_object a);};#endif/************************************************************************************** * HEADER FILE: IO_map.h * PURPOSE		: declare IO_map class **************************************************************************************/#ifndef _IO_map_h#define _IO_map_h#include "ulist.h"#include "stringobject.h"#include "newstring.h"#include "define_vars.h"#include <iostream.h>class IO_map{	private:		int input_length;																				// No of input fields		int output_length;																			// No of output fields		string_class *input_fields;															// input fields array pointer		string_class *output_fields;														// output fields array pointer			public:		IO_map();																								// Default Constructor		IO_map(ulist<string_object> in_fields, 					 ulist<string_object> out_fields);								// Parameterized Constructor		IO_map(IO_map &original);																// Copy Constructor		IO_map& operator=(const IO_map &original);							// Overloaded = operator		~IO_map();																							// Destructor		// Overloaded output operator for IO_map object		friend ostream& operator<<(ostream& output_stream, const IO_map output_map);		// Access to private data members		void get_input_fields(string_class *storage);		int get_number_of_input_fields();		void get_output_fields(string_class *storage);		int get_number_of_output_fields();};#endif/************************************************************************************** * HEADER FILE: IO_map_object.h * PURPOSE		: declare IO_map_object class **************************************************************************************/#ifndef _IO_map_object_h#define _IO_map_object_h#include "newstring.h"#include "IO_map.h"#include "define_vars.h"class IO_map_object{	private:		string_class name;																								// Indexing object 		IO_map map;																												// Data object		IO_map_object *next_IO_map_object;																// Used to form list	public:		static string_class undefined_index;				// Holds definition of an undefined index		// functions required by list		IO_map_object();																				// Default constructor		IO_map_object(string_class name);												// string_class constructor		IO_map_object(string_class name, IO_map new_map);				// string_class/IO_map constr.		IO_map_object(IO_map_object &original);									// Copy constructor		IO_map_object& operator=( IO_map_object &original);			// Overloaded =		string_class get_index();															// Return value of index field		status set_index(const string_class setting);					// Set value of index field 				void set_to_first_index();														// Return first index value		void set_to_next_index(const string_class ref);				// Return next index value		compare compare_index(const string_class index1,			// Return comparison between													const string_class index2);			// two index objects															IO_map get_data();																		// Return value of data field	 	status set_data(const IO_map setting);								// Set value of data field		compare compare_data(const IO_map name1,							// Return comparison between												 const IO_map name2);							// two data objects		void set_pointer_to(IO_map_object *p);								// Set pointer field		IO_map_object* get_pointer();													// Return value of pointer field		void print_node();																		// Print Node info		// Get/set individual elements of IO_map, not used by list...		void get_input_fields(string_class *stored_input_fields);		int get_number_of_input_fields();		void get_output_fields(string_class *stored_output_fields);		int get_number_of_output_fields();				// Overloaded output operator for IO_map_object		friend ostream& operator<<(ostream& output_stream, const IO_map_object a);};#endif