/************************************************************************************** * CODE FILE: validator.c++ * PURPOSE	: define members of validator class **************************************************************************************/#include "validator.h"// Constructor - instantiates validator and connects preprocessor service providervalidator::validator(calc_preprocessor *preprocessor){	connected_preprocessor=preprocessor; }// Define method for validating all equations inside a particular calculator objectstatus validator::validate(calculator *connect_calculator){	connected_calculator=connect_calculator;						// setup reference to the calculator	// Get list of all equations from connected_calculator	ulist<name_object> *equation_list=connected_calculator->get_equation_list();	name_object equation_node;									// Define object to hold current equation	error_trace="";															// Initialise error_trace		// Reset to head of equation_list	if (equation_list->reset_transverse()==ERROR)		// Equation list empty - no checks to do		return SUCCESS;											do	{		equation_list->get_transverse(equation_node);					// Get current equation		if (verify(equation_node.get_index())==ERROR)					// Verify the equation			return ERROR;																				// Circular definition found	}	while (equation_list->progress_transverse()==SUCCESS);	// Process all equations in list	error_trace="";														// no errors so make sure error_trace is blank	return SUCCESS;							// verified every equation in list - no circular definitions}// Define recursive method for verifying equation with identifier, name_stringstatus validator::verify(const string_class name_string, string_class dependents){	string_class output_string;										// result of preprocessing - not used	ulist<string_object> non_reserved_names;			// List of const/var/eqn names in equation	string_object string_node;										// Holds string containing RHS of equation	name_object equation(name_string);						// Search reference object	// Get list of equations in connected_calculator	ulist<name_object> *equation_list=connected_calculator->get_equation_list();	// Find out if name_string references an equation or not	if (equation_list->search_node(equation, COUNTER)==ERROR)	// check for non-equation name		return SUCCESS;						// Success if name_string references a constant or variable	// Call to search_node has loaded DATA field of 'equation' with string holding RHS of	// equation being verified.	// Get list of non-reserved names present in string stored in DATA field of 'equation'	connected_preprocessor->preprocess(equation.get_equation(), output_string,																		 &non_reserved_names);	if (non_reserved_names.reset_transverse()==ERROR)	// If non-reserved name list is empty		return SUCCESS;																	// then contains no circular defns		// Recursively verify all equations referenced by the non-reserved names.	do	{					non_reserved_names.get_transverse(string_node);												// Get next name		if (search_string(dependents, string_node.get_data())==SUCCESS)				// Circular defn		{			append_name(dependents, string_node.get_data());	// add name to list of dependents			error_trace=dependents;														// Update error_trace 			return ERROR;																			// Circular reference been found		}		else												// No circular definition so far - must continue verifying		{														// to bottom of recusive definition for this equation			string_class dependents_backup=dependents;							// Make backup of dependents 			// Add current name to list of dependents for parent equation 			append_name(dependents, string_node.get_data());			if (verify (string_node.get_data(), dependents)==ERROR)				// Circular defn found				return ERROR;												// Propagate ERROR up recursion stack			else																	// Bottom of tree reached - all okay				dependents=dependents_backup;				// Resume using backup dependents,																						// as last name has proved to be non-dependent		}	}	while (non_reserved_names.progress_transverse()==SUCCESS);					// Verify every name	return SUCCESS;													// All dependents of equation name_string found																					// to contain no circular definitions}/*---------------------------------------------------------------------------------------  ---------------------------- End of validator.c++ -------------------------------------  ---------------------------------------------------------------------------------------*/  /************************************************************************************** * CODE FILE: preprocessorTypes.c++ * PURPOSE	: define members of user_label class **************************************************************************************/#include "preprocessorTypes.h"// Define default constructoruser_label::user_label(){	input_string="";	calc_string="";}// Define parameterized constructoruser_label::user_label(string_class i_string, string_class c_string){	input_string=i_string;	calc_string=c_string;}// Define overloaded output operator for user_labelostream& operator<<(ostream& output_stream, const user_label label){ return output_stream << label.input_string << " -> " << label.calc_string; }/*---------------------------------------------------------------------------------------  ---------------------------- End of preprocessorTypes.c++ -----------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: calc_preprocessor.c++ * PURPOSE	: define members of calc_preprocessor class **************************************************************************************/#include "calc_preprocessor.h"// Define Constructor which builds a correlator array which maps input strings to// calculator special characters and an inverse correlator array which performs the// reverse actioncalc_preprocessor::calc_preprocessor(const user_label *input_mappings,																		 const token_name *token_mappings, int length){	input_stream=NULL;																						// Initialise input stream	input_char_array=NULL;																					// Initialise char array		array_length=length;																						// Length of correlator	correlator=new token_name[array_length];												// Allocate correlator		for (int i=0; i<array_length; i++)															// Traverse input_array	{		for (int j=0; j<array_length; j++)														// Traverse token_array		{			if (input_mappings[i].calc_string==token_mappings[j].name)	// When match is found			{				// Associate input_string with corresponding character token, store in correlator				correlator[i].name=input_mappings[i].input_string;				correlator[i].token=token_mappings[j].token;			}		}	}	// now build reverse map for postprocessing - store in inverse_correlator	for(int k=0; k<array_length; k++)		inverse_correlator[(unsigned char)correlator[k].token]=correlator[k].name;}// Define destructor functioncalc_preprocessor::~calc_preprocessor(){ delete[] correlator;}											// delete dynamically allocated data structure// Define method to convert user string to calc stringvoid calc_preprocessor::preprocess (string_class input_string,																		string_class &output_string){	output_string="";																					// Initialise output_string	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	string_class single_name;																	// For single name read in	char input_char;																					// For piecewise char input			while (*input_stream)											// Scan entire input string using input_stream	{			// Read input, storing chars read into output_string, until alpha char found		while (input_stream->get(input_char) && (!isalpha(input_char) ))			output_string=output_string+input_char;				// Break out of while loop if end of stream encountered		if (!*input_stream)			break;				input_stream->putback(input_char);		// Put back last character into stream		*input_stream >> single_name;					// Read in a name (delimited by non alnum char)				// Look-up the single name in the correlator array		// Find out if a char token substitution is required		for (int i=0; i<array_length; i++)												// Search entire correlator			if (correlator[i].name==single_name)										// If a match is found...			{				single_name=correlator[i].token;											// Substitute name for token				break;																								// Break out of loop			}		output_string=output_string+single_name;									// Append to output_string	}	reset_input();																							// Reset istrstream}// Define method to convert user string to calc string, whilst also returning list of// unidentified user names found in user stringvoid calc_preprocessor::preprocess (string_class input_string,																		string_class &output_string,																		ulist<string_object> *unidentified){	unidentified->clearlist();																// Clear referenced list	output_string="";																					// Initialise output_string	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	string_class single_name;																	// For single name read in	char input_char;																					// For piecewise char input			while (*input_stream)											// Scan entire input string using input_stream	{			// Read input, storing chars read into output_string, until alpha char found		while (input_stream->get(input_char) && (!isalpha(input_char) ))			output_string=output_string+input_char;				// Break out of while loop if end of stream encountered		if (!*input_stream)			break;				input_stream->putback(input_char);		// Put back last character into stream		*input_stream >> single_name;					// Read in a name (delimited by non alnum char)				// Look-up the single name in the correlator array		// Find out if a char token substitution is required		int found=0;																							// Found flag		for (int i=0; i<array_length; i++)												// Search entire correlator			if (correlator[i].name==single_name)										// If a match is found...			{				found=1;																							// Flag the match found				single_name=correlator[i].token;											// Substitute name for token				break;																								// Break out of loop			}				if (!found)		{	// corresponding token not found for name, add name to unidentified list			string_object not_found(single_name);										// Build string_object			unidentified->add(not_found, DATA, ASCENDING);					// Add to list		}		output_string=output_string+single_name;									// Append to output_string	}	reset_input();																							// Reset istrstream}void calc_preprocessor::postprocess (const string_class &input_string,																		 string_class &postprocessed_string){	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	unsigned char input_char;																	// For piecewise char input	char output_string[1000]="";															// For holding output	char append_string[1000]="";															// For expanded string	char current_letter[2]=" ";																// Array holding one char+NULL		while (*input_stream)											// Scan entire input string using input_stream		{		*input_stream >> input_char;											// Read in single char from stream				if (!*input_stream)																// If end of input_stream reached...			break;																					// break out of the loop					// Use input_char as index for inverse_correlator array		if (inverse_correlator[(int)input_char]!="")			// If an expand string is present...		{	// Substitute string for single character			inverse_correlator[(int)input_char].string_copy(append_string);		// Extract string			strcat(output_string,append_string);						// Append expansion-string to output		}		else		{			current_letter[0]=input_char;										// Else no translation required...			strcat(output_string,current_letter);						// Append single char to output			}	}	reset_input();																			// Reset istrstream	postprocessed_string=output_string;									// Return output_string}// Define method for initialising input_streamstatus calc_preprocessor::set_input(string_class input_string){	if (input_stream!=NULL)																					// Stream already set-up		reset_input();																								// so reset the stream.	// istrstream objects can only operate on char arrays	// Extract char array from input_string, allocating mem to hold the copy	input_char_array=new char[input_string.length()+1];	input_string.string_copy(input_char_array);		input_stream = new istrstream(input_char_array);							// Initialise input_stream	return SUCCESS;}// Define method for terminating input_streamstatus calc_preprocessor::reset_input(){	if (input_stream!=NULL)															// Stream okay to reset	{		delete input_stream;															// Deallocate stream		input_stream=NULL;		delete[] input_char_array;												// Deallocate associated char array		input_char_array=NULL;		return SUCCESS;	}	else	{		cout << "WARNING - trying to reset a non-set input stream\n";			// Steam not inited		return ERROR;	}}/*---------------------------------------------------------------------------------------  ---------------------------- End of calc_preprocessor.c++ -----------------------------  ---------------------------------------------------------------------------------------*/