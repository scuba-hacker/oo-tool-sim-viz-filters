/************************************************************************************** * HEADER FILE: define_vars.h * PURPOSE		: declare enum status, enum compare, enum ordering and enum orderproperty **************************************************************************************/ #include <iostream.h>#include <stdio.h>#include <string.h>#include <fstream.h>#ifndef _define_vars_h#define _define_vars_h	enum status { SUCCESS, ERROR };	enum compare { SMALLER, EQUAL, LARGER };	enum ordering { DATA, COUNTER };	enum orderproperty { ASCENDING, DESCENDING };#endif/************************************************************************************** * HEADER FILE: ulist.h * PURPOSE		: declare templated ulist class **************************************************************************************/#ifndef _ulist_h#define _ulist_h#include "define_vars.h"template <class node>class ulist	{	private:		node *head;															// Points to first node 		node *tail;															// Points to last node		node *current;													// Utility pointer		node *transverse;												// Traverse pointer - controlled																						// by user using transverse functions				// Search for searchitem using ordering method (COUNTER/DATA)		node* search(node searchitem, ordering method);			// Search for insertion position for target based upon ordering		// comparisontype (COUNTER/DATA) and orderproperty direction (ASCENDING/DESCENDING)		void find_neighbours(node* target, node* &preceding,	node* &proceding,												ordering comparisontype, orderproperty direction);	public:		ulist(void);																			// Default constructor		ulist(ulist &original);														// Copy constructor		void clearlist(void);															// Removes all nodes from ulist		~ulist(void);																			// List destructor function		// +++++++++++++ AUTOMATIC ORDERING ADD/REMOVE FUNCTIONS +++++++++++++++++++		// Add copy of newitem to the ulist. Insertion position determined by value		// of order (COUNTER/DATA) and direction (ASCENDING/DESCENDING) specified		status add(node newitem, ordering order,	orderproperty direction);				// Remove node containing index or data, contained in item. The search		// criteria (index/data) is determined by 'method' value, (COUNTER/DATA)		status remove(node item, ordering method);			// Update reference node (which may be found within the ulist) with new_info.		// Maintain list ordering on order_method/direction.		status update(node reference, node new_info, ordering update_field,									ordering order_method, orderproperty direction);											// maintain ulist by adding or updating new_info node		status maintain(node new_info, ordering order_method, orderproperty direction);				// Append copy of newitem to end of ulist		status add_to_end(node newitem);				// Search for search_item node using ordering method (COUNTER/DATA)		status search_node(node &search_item, ordering method);		// ++++++++++++++++++++++ TRANSVERSE FUNCTIONS +++++++++++++++++++++++++++++			status reset_transverse();												// Reset transverse to ulist head		status get_transverse(node &gotitem);							// Load gotitem with transverse data		status progress_transverse();											// Move transverse to next node.		status remove_transverse();												// Remove transverse node		node* get_transverse_node_pointer();							// Get transverse node pointer				// ++++++++++++++++++++++ OVERLOADED OPERATORS ++++++++++++++++++++++++++		friend ostream& operator<<(ostream& output_stream, const ulist a);																			ulist<node>& operator=(ulist<node> &source);};#endif/************************************************************************************** * HEADER FILE: stringobject.h * PURPOSE		: declare stringobject class **************************************************************************************/#ifndef _stringobject_h#define _stringobject_h#include "define_vars.h"#include "newstring.h"class string_object{													private:		int index;																												// Indexing object		string_class string;																							// Data object		string_object *next_string_object;																// Used to form list	public:		static int undefined_index;									// Holds definition of an undefined index		string_object();																					// Default Constructor		string_object(const string_class original);								// String_class constructor		string_object(const string_object &original);							// Copy Constructor		string_object& operator=(string_object &source);					// Overloaded = operator				int get_index();																			// Return value of index field		status set_index(const int setting);									// Set value of index field 		void set_to_first_index();														// Return first index value		status set_to_next_index(const int ref);							// Return next index value		compare compare_index(const int index1, const int index2);	// Compare two index objs		string_class get_data();															// Return value of data field		status set_data(const string_class set_string);				// Set value of data field		compare compare_data(const string_class data1,				// Return comparison between												 const string_class data2);				// two data objects			void set_pointer_to(string_object *p);								// Set pointer field		string_object* get_pointer();													// Return value of pointer field		void print_node();																		// Print Node info		// Overloaded output operator for name_object		friend ostream& operator<<(ostream& output_stream, const string_object a);};#endif