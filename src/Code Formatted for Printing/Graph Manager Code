/************************************************************************************** * CODE FILE: Graph Manager.c++ * PURPOSE	: define members of graph_manager class **************************************************************************************/#include "Graph Manager.h"// Define CLI using cin/cout streams for accessing graph_manager functionsvoid graph_manager::interface(){	const int MAX_IO=1000;														// Define Buffer size for input/output	char input_string[MAX_IO]="";											// Initialise primary input char array	char input[MAX_IO]="";														// Initialise second input char array	string_class name;																// Define name holder		cout << "\nGraph Manager> ";													// Output manager prompt	while (cin >> input_string)														// Main interface loop	{		if (strcmp(input_string,"help")==0)									// Command displaying commands		{			display_help();			goto prompt3;		}				if (strcmp(input_string,"newspec")==0)							// Command for adding graph spec		{			cin >> name;																			// Get identifier for spec			graph_spec spec_input;																	cin >> spec_input;																// Get spec info			new_spec(name, spec_input);												// Add new spec to list			goto prompt3;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delspec")==0)							// Command for deleting graph spec		{			cin >> name;																			// Get identifier for spec			delete_spec(name);																// Delete specified spec from list			goto prompt3;																			// Jump to end of interface loop		}				if (strcmp(input_string,"specs")==0)								// Command to output spec list		{			output_spec_list();																// Output spec list			goto prompt3;																			// Jump to end of interface loop		}		if (strcmp(input_string,"resetmanager")==0)					// Command to output spec list		{			reset_manager();																	// Output spec list			goto prompt3;																			// Jump to end of interface loop		}				if (strcmp(input_string,"return")==0)								// Break out of the CLI			break;				prompt3:																						// End of loop label		cout << "\nGraph Manager> ";												// Output manager prompt	}}void graph_manager::display_help(){	cout << "Commands Available:\n";										// Dump commands to standand output	cout << "\t newspec <spec_name>\n";	cout << "\t delrecord <spec_name>\n";	cout << "\t specs\n";	cout << "\t help\n\n";}		// Define method for adding graph spec with identifying name to spec_liststatus graph_manager::new_spec(string_class name, graph_spec new_spec){	// Add to list using ascending lexical order	if (spec_list.add(graph_spec_obj (name, new_spec), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: graph spec name must be unique to this list\n";		return ERROR;	}	else		return SUCCESS;}// Define method for deleting graph spec with identifying name from spec_liststatus graph_manager::delete_spec(string_class name){	if (spec_list.remove(name, COUNTER)==ERROR)	{		cout << "ERROR: no such spec exists\n";		return ERROR;	}	else		return SUCCESS;}// Define method for outputting spec_listvoid graph_manager::output_spec_list(){	cout << spec_list; }// Define function to clear internal listsvoid graph_manager::reset_manager(){	spec_list.clearlist(); }/*---------------------------------------------------------------------------------------  ---------------------------- End of graph_manager.c++ ---------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: extragraphclasses.c++ * PURPOSE	: define members of: port_info class *															 border_info class *															 border_info class *															 bound_info class *															 scale_info class *															 range_info class *															 tick_info class **************************************************************************************/#include "extragraphclasses.h"// Define port_info default constructorport_info::port_info (double WIDTH, double HEIGHT){	top=50;	left=50;	width=WIDTH;	height=HEIGHT;}// Define port_info parameterized constructorport_info::port_info (double TOP, double LEFT, double WIDTH, double HEIGHT){	top=TOP;	left=LEFT;	width=WIDTH;	height=HEIGHT;}// Define border_info default constructorborder_info::border_info (double TOP, double BOTTOM, double LEFT, double RIGHT){	top=TOP;	bottom=BOTTOM;	left=LEFT;	right=RIGHT;}// Define bound_info default constructorbound_info::bound_info(){	top=0;	bottom=0;	left=0;	right=0;	width=0;	height=0;}// Define scale_info default constructorscale_info::scale_info (double MAJ, double MIN){	MajScale=MAJ;	MinTicks=MIN;}		// Define range_info default constructorrange_info::range_info (double MIN, double MAX){ 	Max=MAX;	Min=MIN;}// Define range_info method to return absolute range sizedouble range_info::range(){ return Max-Min; }// Define tick_info default constructortick_info::tick_info(double MAJ, double MIN){	MajTickSize=MAJ;	MinTickSize=MIN;}// Define overloaded output operator for port_infoostream& operator<<(ostream& output_stream, port_info port){	output_stream << "top=" << port.top << ", left=" << port.left << ", width=";	output_stream << port.width << ", height=" << port.height;	return output_stream;}// Define overloaded output operator for border_infoostream& operator<<(ostream& output_stream, border_info border){	output_stream << "top=" << border.top << ", bottom=" << border.bottom << ", left=";	output_stream << border.left << ", right=" << border.right;	return output_stream;}// Define overloaded output operator for bound_infoostream& operator<<(ostream& output_stream, bound_info bound){	output_stream << "top=" << bound.top << ", bottom=" << bound.bottom;	output_stream << ", left=" << bound.left << ", right=" << bound.right << ", width=";	output_stream << bound.width << ", height=" << bound.height;	return output_stream;}// Define overloaded output operator for scale_infoostream& operator<<(ostream& output_stream, scale_info scale){	output_stream << "scale=" << scale.MajScale << ", divs=" << scale.MinTicks;	return output_stream;}// Define overloaded output operator for range_infoostream& operator<<(ostream& output_stream, range_info range){	output_stream << "min=" << range.Min << ", max=" << range.Max;	return output_stream;}// Define overloaded output operator for tick_infoostream& operator<<(ostream& output_stream, tick_info tick){			output_stream << "MajTickSize=" << tick.MajTickSize << ", MinTickSize=";	output_stream << tick.MinTickSize;	return output_stream;}// Define overloaded input operator for scale_infoistream& operator>>(istream& input_stream, scale_info& scale){	cout << "Scale Division? ";	input_stream >> scale.MajScale;	cout << "Inter-Divisions? ";	input_stream >> scale.MinTicks;	return input_stream;}// Define overloaded input operator for range_infoistream& operator>>(istream& input_stream, range_info& range){	cout << "Range Min? ";	input_stream >> range.Min;	cout << "Range Max? ";	input_stream >> range.Max;	return input_stream;}/*---------------------------------------------------------------------------------------  ---------------------------- End of extragraphclasses.c++ -----------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: graph_spec.c++ * PURPOSE	: define members of graph_spec class **************************************************************************************/#include "graph_spec.h"// Define default constructorgraph_spec::graph_spec(){ scaleSize=10; }			// Note all other variables automatically take default values// Define parameterized constructorgraph_spec::graph_spec(port_info port1, border_info border1, scale_info horiz_scale1,			scale_info vert_scale1, range_info horiz_range1, range_info vert_range1,			tick_info ticks1){	port=port1;														// Copy in all data	border=border1;	horiz_scale=horiz_scale1;	vert_scale=vert_scale1;	horiz_range=horiz_range1;	vert_range=vert_range1;	ticks=ticks1;		scaleSize=10;}// Define overloaded output operator for graph_specostream& operator<<(ostream &output_stream, graph_spec spec){	output_stream << "Graph Spec:\n";	output_stream << "\t Horiz: range (" << spec.horiz_range << "), scale(";	output_stream << spec.horiz_scale << ")\n";	output_stream << "\t Vert: range (" << spec.vert_range << "), scale(";	output_stream << spec.vert_scale << ")\n";	return output_stream;}// Define overloaded input operator for graph_specistream& operator>>(istream& input_stream, graph_spec& spec){	cout << "Horizontal:\n";	input_stream >> spec.horiz_scale;	input_stream >> spec.horiz_range;	cout << "Vertical:\n";	input_stream >> spec.vert_scale;	input_stream >> spec.vert_range;	return input_stream;}/*---------------------------------------------------------------------------------------  ---------------------------- End of graph_spec.c++ ------------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: graph_spec_obj.c++ * PURPOSE	: define members of graph_spec_obj class **************************************************************************************/#include "graph_spec_obj.h"// Define default constructorgraph_spec_obj::graph_spec_obj() {	next_graph_spec_obj = NULL;	name=graph_spec_obj::undefined_index;}// Define constructor using string_class to initialisegraph_spec_obj::graph_spec_obj(string_class graph_name){	next_graph_spec_obj = NULL;	name=graph_name;} // Define constructor using string_class and new_graph_spec to initialisegraph_spec_obj::graph_spec_obj(string_class graph_name, graph_spec new_graph_spec){		next_graph_spec_obj = NULL;	name=graph_name;	spec=new_graph_spec;}// Define copy constructorgraph_spec_obj::graph_spec_obj(graph_spec_obj &original){	next_graph_spec_obj=original.next_graph_spec_obj;	name=original.name;	spec=original.spec;}// Define assignment of graph_spec_obj objects by graph_spec_obj objectsgraph_spec_obj& graph_spec_obj::operator=(graph_spec_obj &original){	next_graph_spec_obj=original.next_graph_spec_obj;	name=original.name;	spec=original.spec;	return *this;}// Define method for extracting index fieldstring_class graph_spec_obj::get_index(){ return name; }// Define method for setting index fieldstatus graph_spec_obj::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid graph_spec_obj::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid graph_spec_obj::set_to_next_index(const string_class ref){	name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare graph_spec_obj::compare_index(const string_class index1,																			const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldgraph_spec graph_spec_obj::get_data(){ return spec; }	// Define method for setting data fieldstatus graph_spec_obj::set_data(graph_spec setting){			spec=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison grapg_speccompare graph_spec_obj::compare_data(const graph_spec name1, const graph_spec name2){	#pragma unused (name1)	#pragma unused (name2)	return SMALLER;																			 // Arbitrary ordering on graph_spec}// Define method for setting pointer fieldvoid graph_spec_obj::set_pointer_to(graph_spec_obj *p){ next_graph_spec_obj=p; }// Define method for extracting pointer fieldgraph_spec_obj* graph_spec_obj::get_pointer(){ return next_graph_spec_obj; }	// Define method for outputting name_object contents on standard outputvoid graph_spec_obj::print_node(){cout << name << "-> " << spec;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, graph_spec_obj a){	output_stream << a.name << "->" << a.spec;	return output_stream;}// Define undefined index as empty stringstring_class graph_spec_obj::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of graph_spec_obj.c++ --------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: graph_device.c++ * PURPOSE	: define members of graph_device class **************************************************************************************/#include "graph_device.h"// Define Default Constructorgraph_device::graph_device(){	mainPtr=NULL;																// All other data members take default values	scaleSize=10;}// Define Parameterized Constructorgraph_device::graph_device(port_info newport, border_info newborder,													 scale_info newhoriz_scale, scale_info newvert_scale,													 range_info newhoriz_range,  range_info newvert_range,													 tick_info newticks){	mainPtr=NULL;																								// Window pointer NULL	set_port(newport);																					// Set port values	set_border(newborder);																			// Set border values	horiz_scale=newhoriz_scale;																	// Set data members	vert_scale=newvert_scale;	horiz_range=newhoriz_range;	vert_range=newvert_range;	ticks=newticks;		scaleSize=10;																								// Preset text size}// Define method for setting scale and range parametersvoid graph_device::set_params(scale_info newhoriz_scale, scale_info newvert_scale,	range_info newhoriz_range,  range_info newvert_range){	horiz_scale=newhoriz_scale;	vert_scale=newvert_scale;	horiz_range=newhoriz_range;	vert_range=newvert_range;}// Define method for hi-liting graphing windowvoid graph_device::showGraph(){	SetPort(mainPtr);																		// Set hi-lited port to graph window	ShowWindow(mainPtr);																// Show window information	SelectWindow(mainPtr);															// Select graphing window}// Define method for clearing graphing windowvoid graph_device::clear_window(){	showGraph();																					// Show graph window	Rect clearRect;	SetRect (&clearRect,0,0,port.width, port.height);			// Define rectangle fitting window	SetPort(mainPtr);																			// Set port to graphing window	EraseRect(&clearRect);																// Erase graphing window}// Define method for clearing graph window, and then drawing fresh axes and scalesvoid graph_device::blank_graph(){	clear_window();	vertical_ticks();	horizontal_ticks();	draw_axes();}// Define method for translating x-axis value to graph window pixel co-ordinatedouble graph_device::translate_x(double x){ return bound.left+(x-horiz_range.Min)*bound.width/horiz_range.range(); }// Define method for translating y-axis value to graph window pixel co-ordinatedouble graph_device::translate_y(double y){	return bound.bottom-(y-vert_range.Min)*bound.height/vert_range.range(); }// Define method for drawing line at (x_axis value)=x on graph in grey (vertical)void graph_device::draw_x_line(double x, long int brightness){		RGBColor grey, current;	grey.red=grey.green=grey.blue=brightness;					// Set to grey - shade of 'brightness'	GetForeColor(&current);														// Preserve current foreground colour	RGBForeColor(&grey);															// Set foreground colour to grey	PenPat(&qd.gray);																	// Use QuickDraw 'gray' as pen pattern	MoveTo(translate_x(x),bound.bottom);							// Move pen to top side of graph	LineTo(translate_x(x),bound.top);									// Draw vertical line down graph	RGBForeColor(&current);														// Restore old foreground colour	PenPat(&qd.black);																// Restore pen pattern to black}// Define method for drawing line at (y_axis value)=y on graph in grey	(horizontal)void graph_device::draw_y_line(double y, long int brightness){	RGBColor grey, current;	grey.red=grey.green=grey.blue=brightness;					// Set to grey - shade of 'brightness'	GetForeColor(&current);														// Preserve current foreground colour	RGBForeColor(&grey);															// Set foreground colour to grey	PenPat(&qd.gray);																	// Use QuickDraw 'gray' as pen pattern	MoveTo(bound.left,translate_y(y));								// Move pen to left side of graph	LineTo(bound.right,translate_y(y));								// Draw horizontal line across graph	RGBForeColor(&current);														// Restore old foreground colour	PenPat(&qd.black);																// Restore pen pattern to black}// Define method for drawing scales and x=0, y=0 lines if within graphing window, and axesvoid graph_device::draw_axes(){	RGBColor zero;	zero.red=60000;															// Set axes colour to dark yellow	zero.green=40000;	zero.blue=70000;		ForeColor(redColor);												// Draw axes in red	MoveTo(bound.left, bound.bottom);						// x-axis always along bottom edge of graph	LineTo(bound.right, bound.bottom);		MoveTo(bound.left, bound.bottom);						// 	y-axis always along left edge of graph	LineTo(bound.left, bound.top);		RGBForeColor(&zero);												// Set foreground colour to yellow	PenPat(&qd.gray);														// Set pen pattern to 'gray'	if (vert_range.Max>0 && vert_range.Min<0)		// If line y=0 is in the graphing window...	{		MoveTo(bound.left,translate_y(0));				// Move to left edge of graph		LineTo(bound.right, translate_y(0));			// Draw y=0 line in yellow	}	if (horiz_range.Max>0 && horiz_range.Min<0)	{		MoveTo(translate_x(0), bound.bottom);			// Move to bottom edge of graph		LineTo(translate_x(0), bound.top);				// Draw x=0 line in yellow	}	ForeColor(blackColor);											// Set foreground colour to black	PenPat(&qd.black);													// Set pen pattern to black}// Define method for drawing tick marks (divisions) and numbering along vertical y-axis// and draw horizontal grid lines over graph area.void graph_device::vertical_ticks(){	ForeColor(redColor);																								// Draw ticks in red	TextSize(scaleSize);	double y=bound.bottom;	// y_incrementer holds number of pixels distance between each tick mark	double y_incrementer=				((vert_scale.MajScale/vert_range.range())/(vert_scale.MinTicks+1))*bound.height;	int count=vert_scale.MinTicks;	double y_val=vert_range.Min;	char y_val_string[20];		do								// Each loop draws a major tick, and an appropriate no. of minor ticks	{		MoveTo(bound.left,y);		LineTo(bound.left-ticks.MajTickSize, y);		// Draw horizontal major tick		Move(-25,scaleSize/2);											// Move to position to place number		sprintf(y_val_string,"%.1f",y_val);					// Store scale number (1 digit after dp)		ForeColor(blackColor);											// Scale numbers in black		DrawString(c2pstr(y_val_string));						// Place scale number on graph		ForeColor(redColor);												// Tick marks in red				if (y<=bound.top+y_incrementer*vert_scale.MinTicks)	// If major tick required 		{			draw_y_line(y_val, 40000);								// Draw major tick horizontal grid line			break;																		// Break out of while loop - all done		}				do																					// Draw minor ticks between major tick		{			y-=y_incrementer;													// Increment y axis value			MoveTo(bound.left,y);											// Move pen to new minor tick position			LineTo(bound.left-ticks.MinTickSize, y);	// Draw minor tick			// Draw minor tick horizontal grid line			draw_y_line(y_val+(count)*vert_scale.MajScale/(vert_scale.MinTicks+1), 55000);		}		while(count--);															// Repeat until count hits 0				count=vert_scale.MinTicks;									// Restore minor tick count to Minticks		draw_y_line(y_val, 40000);									// Draw horizontal major tick grid line		y_val+=vert_scale.MajScale;									// Update scale number for next iteration	}	while(1);																			// Loop forever - breaks out manually	ForeColor(blackColor);												// Set foreground colour to black}// Define method for drawing tick marks (divisions) and numbering along horizontal x-axis// and draw vertical grid lines over graph area.void graph_device::horizontal_ticks(){	ForeColor(redColor);																								// Draw ticks in red	TextSize(scaleSize);		double x=bound.left;	// x_incrementer holds number of pixels distance between each tick mark	double x_incrementer=			((horiz_scale.MajScale/horiz_range.range())/(horiz_scale.MinTicks+1))*bound.width;	int count=horiz_scale.MinTicks;	double x_val=horiz_range.Min;	char x_val_string[20];		do								// Each loop draws a major tick, and an appropriate no. of minor ticks	{		MoveTo(x, bound.bottom);		LineTo(x, bound.bottom+ticks.MajTickSize);			// Draw horizontal major tick				Move(-scaleSize,ticks.MajTickSize+scaleSize/2);	// Move to position to place number		sprintf(x_val_string,"%.1f",x_val);						// Store scale number (1 digit after dp)		ForeColor(blackColor);												// Scale numbers in black		DrawString(c2pstr(x_val_string));							// Place scale number on graph		ForeColor(redColor);													// Tick marks in red				if (x>=bound.right-x_incrementer*horiz_scale.MinTicks)	// If major tick line required		{			draw_x_line(x_val,40000);									// Draw major tick vertical grid line			break;																		// Break out of while loop - all done		}				do																					// Draw minor ticks between major tick		{			x+=x_incrementer;													// Incrementer x axis value			MoveTo(x, bound.bottom);									// Move pen to new minor tick position			LineTo(x, bound.bottom+ticks.MinTickSize);		// Draw minor tick			// Draw minor tick vertical grid line 			draw_x_line(x_val+count*horiz_scale.MajScale/(horiz_scale.MinTicks+1), 55000);		}		while(count--);															// Repeat until count hits 0				count=horiz_scale.MinTicks;									// Restore minor tick count to Minticks		draw_x_line(x_val,40000);										// Draw vertical major tick grid line		x_val+=horiz_scale.MajScale;								// Update scale number for next iteration	}	while(1);																			// Loop forever - breaks out manually	ForeColor(blackColor);												// Set foreground colour to black}// Define method for drawing a cross centred at current pen position, of size 'Width'void graph_device::PlaceCross(int Width){	RGBColor current;	GetForeColor(&current);														// Preserve current foreground colour		ForeColor(greenColor);														// Crosses are green		Move(-Width/2,-Width/2);													// Draw cross	Line(Width, Width);	Move(-Width, 0);	Line(Width, -Width);		Move(-Width/2, Width/2);													// Restore pen back to original pos.		RGBForeColor(&current);														// Restore original foreground colour}// Define size of 'graph port' or graphing window - returns a pointer to the windowvoid graph_device::set_port(port_info newport){	port=newport;	if (mainPtr!=NULL)															// If window already set, deallocate it		CloseWindow(mainPtr);													// MacOS QuickDraw function	// Set windRect to have dimensions equal to port co-ordinates	Rect windRect;	SetRect(&windRect, port.top,port.left, port.top+port.width, port.left+port.height);	// Instantiate window	mainPtr = NewCWindow(nil, &windRect, "\pGraph Title", true, documentProc, 				(WindowPtr) -1, false, 0);		SetPort(mainPtr);																// Set current window to graph window	bound.right=port.width-border.right;													// Recalculate bounds	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}// Define method for setting border info, updating bound info appropriatelyvoid graph_device::set_border(border_info newborder){	border=newborder;	bound.top=border.top;																					// Recalculate all bounds	bound.left=border.left;	bound.right=port.width-border.right;	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}// Define methods for setting private data members individuallyvoid graph_device::set_horiz_scales(scale_info newhoriz_scale){ horiz_scale=newhoriz_scale; }void graph_device::set_vert_scales(scale_info newvert_scale){ vert_scale=newvert_scale; }void graph_device::set_horiz_range(range_info newhoriz_range){ horiz_range=newhoriz_range; }void graph_device::set_vert_range(range_info newvert_range){ vert_range=newvert_range; }void graph_device::set_ticks(tick_info newticks){ ticks=newticks; }// Define method for translating x origin offset to graph window pixel co-ordinatedouble graph_device::x_origin(double x){ return bound.left+x; }// Define method for translating y origin offset to graph window pixel co-ordinatedouble graph_device::y_origin(double y){	return bound.bottom-y; }/*---------------------------------------------------------------------------------------  ---------------------------- End of graph_device.c++ ----------------------------------  ---------------------------------------------------------------------------------------*/