/************************************************************************************** * HEADER FILE: CalculatorManager.h * PURPOSE		: declare calculator_manager class **************************************************************************************/#include "rCalculatorClass.h"#include "calc_preprocessor.h"#include "validator.h"#include "calcobject.h"#include "newstring.h"#include <iostream.h>class calculator_manager{	private:		ulist<calc_object> calc_list;						// List of calc_object objects ordered on name		calc_object *current_calc;							// Pointer to calc_object currently accessed		calc_preprocessor *preprocessor;				// Preprocesses user input, converts to tokens		validator *equation_checker;						// Validates equation_list of calc_object			public:		calculator_manager(calc_preprocessor *preprocess);				// Parameterized Constructor		~calculator_manager();																		// Destructor		calculator_manager(calculator_manager &original);							// Copy Constructor		calculator_manager& operator=(calculator_manager &source);		// Overloaded = operator				// Functions for manipulating calc_object list		status add_calculator(const string_class name);		status remove_calculator(const string_class name);		// Function for directing orders to a particular calc_object in the calculator list		status set_current_calc(const string_class name_string="");		// Send order (expression/assignment/definition) to current calculator for evaluation		complex process_order(const string_class &calc_order);		// Output all variables and equations stored in current calculator				ostream& current_storage(ostream &output_stream);		// Output error report stored in current calculator		ostream& current_errors(ostream &output_stream);		// Clear error report stored in current calculator		string_class current_clear_errors();		// Validate all equations in current calculator for circular definitions		status validate_current();															// Use when auto-verify is off		// Clear all variables & equations in current calculator		string_class clear_memory();		// Clear variable or equation with particular 'name' in current calculator		string_class clear_single_memory(string_class name);		// Output names and variables/equations stored in all calc_objects in calculator list		friend ostream& operator<<(ostream& output_stream, calculator_manager &output);		void interface();																// CLI for accessing member functions		void display_help();														// Display CLI commands on-screen		string_class get_current_calc();								// Return name of current calculator				void auto_verify_on();													// Turn on auto-checking of equations		void auto_verify_off();													// Turn off auto-checking of equations		void reset_manager();														// Clear calculator list};/************************************************************************************** * HEADER FILE: rCalculatorUserTypes.h * PURPOSE		: declare enums token_value, macro_type, calculator_type; *							declare classes token_name, calculator_symbol **************************************************************************************/#ifndef _rCalculatorUserTypes_h#define _rCalculatorUserTypes_h#include <string.h>#include <iostream.h>#include <strstream.h>#include <ctype.h>#include <math.h>#include "complex.h"#include "newstring.h"// 'token_value' contains an enumeration of all tokens understood by calculator class.// Each token name is associated with a single integer which is interpreted as an unsigned// ASCII character, ranged over 0-255. Special key combinations to obtain characters with// ASCII code > 128 are given on appropriate lines of the enumeration.enum token_value{	NAME,		NUMBER,		END,																							// \0 \1 \2	PLUS='+', 	MINUS='-',	MUL='*',	DIV='/',													// + - * /	POW='^', FACTORIAL='!', SQRT='@', CBRT='£',  ROOTX='$',							// ^ ! @ £ $	SIN='¡', COS='™', TAN='#', ASIN='¢', ACOS='∞', ATAN='§',						// Alt 1 2 3 4 5 6	SINH='~',COSH='Ω',TANH='≈', ASINH='ç', ACOSH='√', ATANH='∫',				// ~ Alt z x c v b	LN='¶', LOG10='•', LOG2='ª', LOGX='º',															// Alt 7 8 9 0	PRINT=';',	ASSIGN_CONSTANT='=', LP='(', RP=')',										// ; = ( )	LM='[', RM=']', ARGUMENT='≠',																				// [ ] Alt =	MILLI='œ', MICRO='∑', NANO='®', PICO='†', FEMTO='¥',								// Alt q w r t y	KILO='å', MEGA='ß', GIGA='∂', TERA='ƒ', PETA='©', EXA='∆',					// Alt a s d f g j	DEFINE_EQUATION=':', SUMMATION='¬', PRODATION='∏',									// : Alt l P	COMMA=',', REAL='≤', IMAGINARY='≥', WINDOW='÷'											// , Alt < > ÷};// 'macro_type' is used to distinguish between the two types of data stored in complex_// container class. 'CONSTANT' signifies a fixed complex_number is stored, whereas// 'EQUATION' signifies a string_class object is stored.enum macro_type{ CONSTANT, EQUATION };// 'calculator_type' is used to determine between a calculator created by the user (SUPER_// CALCULATOR - capable of assignment of variables/equations) and those created on-the-fly// by a SUPER_CALCULATOR, called SUB_CALCULATORs, which are used to perform recursive// calculations on behalf of a SUPER_CALCULATOR.enum calculator_type{ SUPER_CALCULATOR, SUB_CALCULATOR };// 'token_name' is used to map an OPERATION string_class to a character token.// OPERATIONs are common to both preprocessor and calculator. Character tokens are// local to the calculator. class token_name{	public:		string_class name;																					// Holds OPERATION		char token;																									// Holds calculator token			// Default Constructor			token_name();		// Parameterized Constructor		token_name(const char *tokenname, const char token_character);		// Overloaded output operator		friend ostream& operator<<(ostream& output_stream, const token_name output);};// 'calculator_symbol' is used to hold the current symbol read in by calculator class// from the input stream. It holds a single token_value corresponding to the// interpretation of the character token read in. It also holds either a complex number,// or a string_class depending upon the particular token_value stored. Information is// stored mutually exclusively between  (complex/string_class).class calculator_symbol{	public:		token_value token;						// Holds character token equivalent enum		complex number_value;					// Holds complex number operand associated with token		string_class name_string;			// Holds string_class operand associated with token		void clear();									// Initalises all data members};#define _rCalculatorUserTypes_h#endif/************************************************************************************** * HEADER FILE: extraclasses.h * PURPOSE		: declare complex_container class **************************************************************************************/#ifndef _extraclasses_h#define _extraclasses_h#include "rCalculatorUserTypes.h"#include "complex.h"#include "define_vars.h"#include "newstring.h"class calc_preprocessor;																					// Forward Declarationclass complex_container{	public:		macro_type indicator;																					// Type of data stored		complex complex_number;																				// Complex number data		string_class equation;																				// Equation string data		// Preprocessor Link used for expanding equation string (contains calc tokens) to		// equation containing user function names (eg sin, cos, log, etc.)		static calc_preprocessor *postprocessing;				// Default Constructor		complex_container();		// Parameterized Constructor - for storing complex number 		complex_container(macro_type store_indicator, complex store_complex_number);		// Parameterized Constructor - for storing string		complex_container(string_class equation_string);		// Function for comparing two complex container objects		friend compare compare_containers(complex_container left, complex_container right);			// Overloaded output operator		friend ostream& operator<<(ostream& output_stream, const complex_container container);		// Overloaded input operator		friend istream& operator>>(istream& input_stream, complex_container& container);};#endif/************************************************************************************** * HEADER FILE: name_object.h * PURPOSE		: declare name_object class **************************************************************************************/ #ifndef _name_object_h#define _name_object_h#include "newstring.h"#include "extraclasses.h"#include "define_vars.h"class name_object{	private:		string_class name;																								// Indexing object		complex_container data;																						// Data object		name_object *next_name_object;																		// Used to form list			public:		static string_class undefined_index;				// Holds definition of an undefined index		// Functions required by ulist...		name_object() ; 																								// Default constructor		// string_class/complex container constructor		name_object(const string_class string, const complex_container complex_field=								complex_container(CONSTANT, complex(0, 0)) );				// char array/complex container constructor		name_object(const char *string, const complex_container complex_field=								complex_container(CONSTANT, complex(0, 0)) );										name_object(const name_object &original);												// Copy constructor		name_object& operator=(name_object &source);										// Overloaded =		string_class get_index();															// Return value of index field		status set_index(const string_class setting);					// Set value of index field 				void set_to_first_index();														// Return first index value		void set_to_next_index(const string_class ref);				// Return next index value		compare compare_index(const string_class index1,			// Return comparison between													const string_class index2);			// two index objects															complex_container get_data();													// Return value of data field	  status set_data(const complex_container setting);			// Set value of data field		compare compare_data(const complex_container name1,		// Return comparison between												 const complex_container name2);	// two data objects												 		void set_pointer_to(name_object *p);									// Set pointer field		name_object* get_pointer();														// Return value of pointer field		void print_node();																		// Print Node info		// Get/Set individual elements of data object; not used by ulist...		// Manipulate the complex number inside complex container data object		complex get_complex();		void set_complex(const complex new_complex);				// Manipulate the macro_type (VARIABLE/EQUATION) inside complex container data object		macro_type get_indicator();		void set_indicator(const macro_type new_indicator);		// Manipulate the string_class inside complex container data object		string_class get_equation();		void set_equation(const string_class new_equation);				// Overloaded output operator for name_object		friend ostream& operator<<(ostream& output_stream, const name_object a);};#endif/************************************************************************************** * HEADER FILE: calcobject.h * PURPOSE		: declare calc_object class **************************************************************************************/#ifndef _calcobject_h#define _calcobject_h#include "newstring.h"#include "rCalculatorClass.h"#include "define_vars.h"class calc_object{	private:		string_class identifier;																					// Indexing object		calculator data;																									// Data object		calc_object *next_calc_object;																		// Used to form list			public:		static string_class undefined_index;				// Holds definition of an undefined index					// Functions required by ulist...		calc_object();  																				// Default constructor		calc_object(const string_class name);										// String_class constructor		calc_object(const calc_object &original);								// Copy constructor		calc_object& operator=(calc_object &source);						// Overloaded =		string_class get_index();																// Return value of index field		status set_index(const string_class setting);						// Set value of index field 				void set_to_first_index();															// Return first index value		void set_to_next_index(const string_class ref);					// Return next index value		compare compare_index(const string_class index1,				// Return comparison between													const string_class index2);				// two index objects				calculator get_data();																	// Return value of data field	  status set_data(const calculator setting);							// Set value of data field		compare compare_data(const calculator name1,						// Return comparison between												 const calculator name2);						// two data objects				void set_pointer_to(calc_object *p);										// Set pointer field		calc_object* get_pointer();															// Return pointer field		void print_node();																			// Print Node info		// Overloaded output operator for name_object		friend ostream& operator<<(ostream& output_stream, const calc_object a);		// Access to public member functions of calculator (data object)		complex evaluate(string_class input_string);		string_class flush_errors();		ostream& peek_errors(ostream& output_stream);		int get_number_of_errors();		void all_clear();		status clear_single_memory(string_class name);		void auto_verify_off();		status auto_verify_on();		void set_validator(validator *checker);};#endif/************************************************************************************** * HEADER FILE: rCalculatorClass.h * PURPOSE		: declare calculator class **************************************************************************************/ #ifndef _rCalculatorClass_h#define _rCalculatorClass_h#include "rCalculatorUserTypes.h"			 #include "complex.h"#include "complex functions.h"#include "iadditionalmath.h"#include "extraclasses.h"#include "ulist.h"#include "name_object.h"#include "validator.h"class validator;																						// Forward declarationclass calculator{	private:		static int math_function_array_initialised;							// Flag indicating init status		static double (*math_func[256])(double);								// Function pointer look-up		static char terminator_table[256];							// Expression terminator token look-up		static const token_value terminator_tokens[15];					// Terminator tokens		validator *equation_checker;														// Used for validating eqns		int *number_of_errors;																	// Number of errors occurred		calculator_type rank;																		// SUPER/SUB calculator flag		calculator_symbol current_symbol;												// Currently read token		int binding_segment;																		// Current parentheses level		ulist<name_object> *var_list;														// Variable list for calc		ulist<name_object> *equation_list;											// Equation list for calc		istrstream *input_stream;																// Dynamic Input stream		ostrstream *error_stream;																// Dynamic Error stream		char *input_char_array;																	// Feeds dynamic input stream		char *error_string;																			// Output of error stream		void new_error_stream();																// Re-initialise error stream		int auto_verify;																				// Flag for checking eqns				complex level1();																				// Add/Substract Level		complex level2();																				// Multiply/Divide Level		complex level3();																				// Power Level		complex level4();																				// Factorial Level		complex level5();																				// ENG symbols Level		complex primary();																			// Primary Level				complex compound(token_value method);									// Calculate Summation/Prodation		// Retrieve SUM/PROD parameters from input_stream		status get_compound_parameters(token_value method, string_class &variable,																	 int &lower_bound, int &upper_bound);		// Retrieve window parameters from error_stream		status get_window_parameters(string_class &variable, double &lower_bound,																 double &upper_bound);		string_class get_definition();						// Get equation definition from input_stream		static void initialise_math_function_array();						// Called within Constructor		void init_math_array();														// Sets up function pointer look-up		// Apply multiplying factor according to engineering conversion token		complex engineering_conversion(const token_value token, const complex x);		// Check operands for token operation are valid		int invalid_operands(const token_value token, const complex value1,												 const complex value2=complex(0,0));		token_value get_token();													// Retrieve token from input_stream		complex error(const char* s);											// Internal error reporting method		complex error(const string_class s);							// Internal error reporting method		// Constructor used in recursive calculations requiring derivative calculators		calculator(ulist<name_object> *var_list, ulist<name_object> *equation_list,							 ostrstream *errors, int *number_of_errors);		status set_input(string_class input_string);							// Acquire new input stream		status reset_input();																			// Dump input stream			public:			static const token_name token_names[50];						// Tokens processed by calculator		static ulist<name_object> constant_list;						// Generic Constant list		// Initialise generic constant list		static void build_internal_constants(const name_object *constants,const int length);		static int ERROR_STREAM_SIZE;												// Maximum error stream size		calculator();																									// Default Constructor		~calculator();																								// Destructor		calculator(const calculator &original);												// Copy Constructor		calculator& operator=(const calculator &source);							// Overloaded = operator		ulist<name_object>* get_equation_list();						// Return pointer to equation list		ulist<name_object>* get_var_list();									// Return pointer to variable list		complex evaluate(string_class input_string);		// Evaluate input string		string_class flush_errors();										// Return and clear error stream		ostream& peek_errors(ostream& output_stream);	 	// Return error stream through stream		int get_number_of_errors();											// Return no. of errors since clear		void all_clear();																// Clear all variables and equations		status clear_single_memory(string_class name);	// Clear single variable/equation		void auto_verify_off();													// Turn off auto verification		status auto_verify_on();												// Turn on auto verification		void set_validator(validator *checker);					// Setup validating object link		// Output contents of calculator to output_stream		friend ostream& operator<<(ostream& output_stream, const calculator a);		friend complex sqrt_comp(const complex value);						// Set up friend association		friend complex cbrt(const complex value);									// Set up friend association};#endif