/************************************************************************************** * CODE FILE: newstring.c++ * PURPOSE	: define members of string_class class **************************************************************************************/#include "newstring.h"extern const int MAX_INPUT_STRING_LENGTH;// define default constructorstring_class::string_class()				// initialise string with NULL terminator, string_length=1{	letters=new char[1];				letters[0]='\0';				string_length=1;			}// define constructor using char array as sourcestring_class::string_class(const char *source){	if (source==NULL)	{		cout << "Trying to copy NULL address into string class - illegal\n";		letters=new char[(string_length=1)];										// initialise as in string_class()		letters[0]='\0';	}	else	{		letters = new char[(string_length=(strlen(source)+1))];		letters[0]='\0';		strcpy (letters, source);	}}// define copy constructorstring_class::string_class(const string_class &original){	letters = new char[(string_length=original.string_length)];	letters[0]='\0';	strcpy(letters, original.letters);}// define destructorstring_class::~string_class(){	if (letters!=NULL)		delete[] letters;	else	{		// bad construction, no memory has been allocated, so don't delete anything	}}// define method for extracting letters char array from string_class objectstatus string_class::string_copy(char *target)								// copy letters array into target{	if (target!=NULL)	{		target[0]='\0';		strcpy(target,letters);		return SUCCESS;	}	else	{		cout << "ERROR : attempted to string_copy into a NULL char pointer\n";		return ERROR;	}}// define assignment of string_class objects by string_class objectsstring_class& string_class::operator=(const string_class &source){	// first disallow x=x where left side is same as right side	// don't change a thing in this case	if (&source==this)		return *this;	delete[] letters;	letters = new char[(string_length=source.string_length)];	letters[0]='\0';	strcpy (letters, source.letters);	return *this;}// define assignment of string_class objects by char arraysstring_class& string_class::operator=(const char *source){	if (source==NULL)	{		cout << "Trying to assign NULL address into string class - illegal\n";	}	else	{		delete[] letters;		letters = new char[(string_length=(strlen(source)+1))];		letters[0]='\0';		strcpy (letters, source);	}	return *this;}// define assignment of string_class objects by single charstring_class& string_class::operator=(const char &source){	delete[] letters;	letters = new char[2];	letters[0]=source;	letters[1]='\0';	string_length=2;	return *this;}// define string_class+string_class appending operationstring_class operator+(const string_class source1, const string_class source2){	string_class return_string;	char *temp=			new char [(return_string.string_length=source1.string_length+source2.string_length-1)];	temp[0]='\0';		strcat (temp, source1.letters);	strcat (temp, source2.letters);			return_string=temp;	delete[] temp;	return return_string;}// define string_class+char_array appending operationstring_class operator+(const string_class source1, const char *source2){	string_class return_string;	char *temp = new char [(return_string.string_length=source1.string_length+strlen(source2))];	temp[0]='\0';		strcat (temp, source1.letters);	strcat (temp, source2);		return_string=temp;	delete[] temp;	return return_string;}// define char_array+string_class operationstring_class operator+(const char *source1, const string_class source2 ){	string_class return_string;	char *temp = new char [(return_string.string_length=source2.string_length+strlen(source1))];	temp[0]='\0';		strcat (temp, source1);	strcat (temp, source2.letters);		return_string=temp;	delete[] temp;	return return_string;}// define string_class+char operationstring_class operator+(const string_class source1, const char input_char){	int string_len=source1.string_length+1;	char *temp = new char [string_len];	temp[0]='\0';			strcpy (temp, source1.letters);	temp[string_len-2]=input_char;	temp[string_len-1]='\0';	string_class return_string(temp);	return_string=temp;	delete[] temp;	return return_string;}// define string_class[] subscriptingchar& string_class::operator[](const int index){	if (index<0 || index>string_length-2)	{		cout << "Error : string index " << index << " out of range\n";		return letters[string_length];																				// return NULL char	}	else		return letters[index];}// define const string_class[] subscriptingchar& string_class::operator[](const int index) const{	if (index<0 || index>string_length-2)	{		cout << "Error : string index " << index << " out of range\n";		return letters[string_length];																				// return NULL char	}	else		return letters[index];}// define method for finding out length of char array stored in string_classint string_class::length(){	return string_length-1;}// define overloaded output operatorostream& operator<<(ostream& output_stream, const string_class output_string){	return output_stream << output_string.letters;}// define overloaded input operatoristream& operator>>(istream& input_stream, string_class& input_string){	char buffer[MAX_INPUT_STRING_LENGTH]="";	char next_char=0;	int x=0;		// skip initial white space	while(input_stream.get(next_char) && isspace(next_char)) ;		// put back last character into stream if input held > 0 characters originally	if (next_char!=0)		input_stream.putback(next_char);		// read in string delimited by end of input stream and non-alphanumeric characters, reading	// maximum of MAX_INPUT_STRING_LENGTH-1 characters	while(input_stream.get(buffer[x]) && x<MAX_INPUT_STRING_LENGTH-1)	{		if (x==MAX_INPUT_STRING_LENGTH-1)			break;		if (!isalnum(buffer[x]))		{				input_stream.putback(buffer[x]);			// put non alnum back into stream and			buffer[x]='\0';												// chop off non-alnum at end of buffer and terminate			break;		}		x++;	}		// deal with the case where input has been truncated due to finite buffer	if(x==MAX_INPUT_STRING_LENGTH-1 && isalnum(buffer[x]))		cout << "String stream input too long > " << MAX_INPUT_STRING_LENGTH-1 <<						" chars... read in: " << buffer << '\n';	input_string=buffer;	return input_stream;}// Define 10 operators for lexically comparing string_class objects and char arraysint operator==(const string_class &string1, const string_class &string2){	return (strcmp(string1.letters, string2.letters) == 0); }int operator==(const string_class &string1, const char *string2){ return (strcmp(string1.letters, string2) == 0); }int operator==(const char *string1, const string_class &string2){	return (strcmp(string1, string2.letters) == 0); }int operator!=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters) != 0); }int operator!=(const string_class &string1, const char *string2){	return (strcmp(string1.letters, string2) != 0); }int operator!=(const char *string1, const string_class &string2){ return (strcmp(string1, string2.letters) != 0); }int operator>=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)>=0); }int operator<=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)<=0); }int operator>(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)>0); }int operator<(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)<0); }// Define function which appends two strings, adding an additional space at the endvoid append_name(string_class &target, const string_class &source){		char *temp= new char [target.string_length+=source.string_length];	temp[0]='\0';		if (target.string_length==1)	{		strcpy (temp, source.letters);		strcat (temp, " ");	}	else	{		strcpy (temp, target.letters);		strcat (temp, source.letters);		strcat (temp, " ");	}			delete[] target.letters;	target.letters=temp;}// Define function which searches for target+' ' within sourcestatus search_string(const string_class &source, const string_class &target){	string_class temp=target.letters;	temp=temp+' ';	if (strstr(source.letters, temp.letters)==NULL)		return ERROR;	else		return SUCCESS;}/*---------------------------------------------------------------------------------------  ---------------------------- End of newstring.c++ -------------------------------------  ---------------------------------------------------------------------------------------*/  /************************************************************************************** * HEADER FILE: complex functions.c++ * PURPOSE		: define members of complex class **************************************************************************************/ #include "complex.h"#include "complex functions.h"double magnitude(const complex a){ return sqrt(a.re*a.re + a.im*a.im); }									// return magnitude of complex adouble arg(const complex a){	double theta=atan2(a.im,a.re);	if (theta<0)		return (2*PI+theta);																// returns answer in range ¹->2¹	else		return theta;																				// returns answer in range 0->¹}complex sqrt_comp(const complex a){ return a^complex(0.5,0); }														// return square root of complex acomplex cbrt(const complex a){ return a^complex((double)1/3,0); }										// return cube root of complex acomplex polar_rect(const double mag, const double arg){ return complex(mag*cos(arg), mag*sin(arg)); }					// return rectangular conversion/*---------------------------------------------------------------------------------------  ---------------------------- End of complex functions.c++ -----------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * HEADER FILE: iadditionalmath.c++ * PURPOSE		: define functions specified in iadditionalmath.h **************************************************************************************/#include "iadditionalmath.h"double log2(const double value)											// return log to base 2 of value{	return log(value)/log(2); }double logx(const double value, const double x)			// return log to base x of value{	return log(value)/log(x); }double asinh(const double x)												// return arc-hyperbolic sine of x{	return log(x+sqrt(1+pow(x,2)));	}									// Got from SMP Formula Bookdouble acosh(const double x)												// return arc-hyperbolic cosine of x{ return log(x+sqrt(pow(x,2)-1));	}									// Got from SMP Formula Bookdouble atanh(const double x)												// return arc-hyperbolic tangent of x{ return 0.5*log((1+x)/(1-x)); }										// Got from SMP Formula Bookint factorial(const int x)													// return factorial of x{	int factorial=1;	for (int counter=x; counter>1; counter--)		factorial *= counter;	return factorial;}/*---------------------------------------------------------------------------------------  ---------------------------- End of idditionalmath.c++ --------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * HEADER FILE: complex.c++ * PURPOSE		: define members of complex class **************************************************************************************/#include "complex.h"#include "complex functions.h"// define default constructorcomplex::complex(){	re=0;	im=0;}// define real/imag parameterized constructorcomplex::complex(const double real, const double imag){	re=real;	im=imag;}// define function for setting both real/imag componentsvoid complex::set(const double real, const double imag){	re=real;	im=imag;}// define complex addition 																									(this=this+a)complex& complex::operator+=(const complex a){	re += a.re;	im += a.im;	return *this;}// define complex subtraction 																							(this=this-a)complex& complex::operator-=(const complex a){	re -= a.re;	im -= a.im;	return *this;}// define complex multiplication																						(this=this*a)complex& complex::operator*=(const complex a){	double real = a.re*re - a.im*im;	im = a.im*re + a.re*im;	re = real;	return *this;}// define complex division																									(this=this/a)complex& complex::operator/=(const complex a){	double d=a.re*a.re-a.im*a.im;	double real = (re*a.re+im*a.im)/d;	im = (im*a.re - re*a.im)/d;	re = real;	return *this;}// define complex addition																									(this=a+b)complex operator+(const complex a, const complex b){	return complex(a.re+b.re, a.im+b.im); }// define complex subtraction																								(this=a-b)complex operator-(const complex a, const complex b){	return complex(a.re-b.re, a.im-b.im); }// define complex unary minus 																							(this=-this)complex complex::operator-(){	re=-re;	im=-im;	return *this;}// define complex multiplication																						(this=a*b)complex operator*(const complex a, const complex b){ return complex(a.re*b.re-a.im*b.im, a.im*b.re + a.re*b.im); }// define complex division																									(this=a/b)complex operator/(const complex a, const complex b){	double d=b.re*b.re+b.im*b.im;	return complex((a.re*b.re+a.im*b.im)/d, (a.im*b.re - a.re*b.im)/d);}// define complex power operator																						(this=a^b)complex operator^(const complex a, const complex exponent){	if (a.re>0 && a.im==0 && exponent.im==0)				// calculations using real positive base		return complex (pow(a.re,exponent.re),0);	else																						// complex numbers used otherwise	{		if (a.re==exp(1))															// base=e, use polar complex conversion			return polar_rect(exp(exponent.re), exponent.im);		else																					// otherwise use DeMoivre's Theorem			return polar_rect(pow(magnitude(a),exponent.re), arg(a)*exponent.re);	}}// define output operator (rectangular form)ostream& operator<<(ostream& output_stream, const complex a){		// Output real and imaginary components in 8 character field,	// using scientific notation	output_stream.width(8);	output_stream.setf(ios::right,ios::adjustfield);	output_stream.setf(ios::scientific,ios::floatfield);	output_stream << a.re << "+";	output_stream.width(8);	output_stream.setf(ios::right,ios::adjustfield);	output_stream.setf(ios::scientific,ios::floatfield);	output_stream << a.im << "j";										// output in 'a+bj' form	return output_stream;}// define input operator (rectangular form)istream& operator>>(istream& input_stream, complex& complex_number){	char j_place_holder;	// expected input in the form 'a+bj'	input_stream >> complex_number.re >> complex_number.im >> j_place_holder;	return input_stream;}/*---------------------------------------------------------------------------------------  ---------------------------- End of complex.c++ ---------------------------------------  ---------------------------------------------------------------------------------------*/