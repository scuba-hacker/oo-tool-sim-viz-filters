/************************************************************************************** * CODE FILE: Data Manager.c++ * PURPOSE	: define members of data_manager class **************************************************************************************/#include "Data Manager.h"// Define CLI using cin/cout streams for accessing data_manager functionsvoid data_manager::interface(){	const int MAX_IO=1000;														// Define Buffer size for input/output	char input_string[MAX_IO]="";											// Initialise primary input char array	char input[MAX_IO]="";														// Initialise second input char array	char output[MAX_IO]="";	string_class name;																// Define name holder					cout << "\nData Manager> ";														// Output manager prompt	while (cin >> input_string)														// Main interface loop	{		if (strcmp(input_string,"help")==0)									// Command displaying commands		{			display_help();			goto prompt2;		}		if (strcmp(input_string,"newrecord")==0)						// Command for adding record		{			cin >> name;																			// Get identifier for record			cin.getline(input, MAX_IO);												// Get record parameters			new_record(name, input);													// Add new record to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delrecord")==0)						// Command for deleting record		{			cin >> name;																			// Get identifier for record			delete_record(name);															// Delete 'name' record from list 			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"records")==0)							// Command to output record list		{			cout << record_list;															// Output record list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newdataset")==0)						// Command for adding data_set		{			string_class record_name;			int length=0;			cin >> name;																			// Get identifier for data_set			cin >> record_name;																// Get record_name for data_set			cin >> length;																		// Get length for data_set			new_data(name, record_name, length);							// Add data_set to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"deldataset")==0)						// Command for deleting data_set		{			cin >> name;																			// Get identifier for data_set			delete_data(name);																// Delete data_set from list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"datas")==0)								// Command to output data_set list		{			cout << data_list;																// Output data_list list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newinput")==0)							// Command for adding set_input		{			cin >> name;																			// Get identifier for set_input			string_class set_input_name;			int lower_i, upper_i;			double start_val, incrementer;			cin >> lower_i >> upper_i >> start_val >> incrementer;	// Get set_input parameters			new_set_input(name, lower_i, upper_i, start_val, incrementer);				// Add to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delinput")==0)							// Command for deleting set_input		{			cin >> name;																			// Get identigier for set_input			delete_set_input(name);														// Delete set_input from list			goto prompt2;																			// Jump to end of interface loop		}		if (strcmp(input_string,"inputs")==0)								// Command outputs set_input list		{			cout << set_input_list;														// Output set_input list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newmap")==0)								// Command for adding IO_map		{			cin >> name;																			// Get identifier for IO_map			string_class calc_identifier, output_field, input_fields;			cin.getline(input, MAX_IO);												// Get input fields of IO_map			cout << "now enter output fields\n";			cin.getline(output, MAX_IO);											// Get output fields of IO_map			new_map(name, input, output);											// Add IO_map to map_list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delmap")==0)								// Command for deleting IO_map		{			cin >> name;																			// Get identifier for IO_map			delete_map(name);																	// Delete IO_map from map_list			goto prompt2;																			// Jump to end of interface loop		}		if (strcmp(input_string,"maps")==0)									// Command to output map_list		{			cout << map_list;																	// Output map_list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"resetmanager")==0)					// Command to output map_list		{			reset_manager();			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"return")==0)								// Break out of the CLI		{			break;		}				prompt2:																						// End of loop label		cout << "\nData Manager> ";													// Output manager prompt	}}void data_manager::display_help(){	cout << "Commands Available:\n";									// Dump commands to standard output	cout << "\t newrecord <record_name> <field_name>...\n";	cout << "\t delrecord <record_name>\n";	cout << "\t records\n";	cout << "\t newdataset <data_name> <record_name> <length>\n";	cout << "\t deldataset <data_name>\n";	cout << "\t datas\n";	cout << "\t newinput <input_name> lower_index upper_index start_value step\n";	cout << "\t delinput <input_name>\n";	cout << "\t inputs\n";	cout <<		"\t newmap <map_name> <input_field_name>... (newline) <output_field_name>...\n";	cout << "\t delmap <map_name>\n";	cout << "\t maps\n";	cout << "\t resetmanager\n";	cout << "\t help\n";	cout << "\n\n";}// Define method for adding record with identifying name to record_liststatus data_manager::new_record(string_class record_name, string_class record){ // Add to list using ascending lexical order	cout << "name is:" << record_name << ", records are " << record << "\n";	char record_chars[1000];											// Buffer1 to hold record fields as whole	char field_chars[100];												// Buffer2 to hold individual record field		record.string_copy(record_chars);							// Extract char array from record	istrstream record_stream(record_chars);				// Record_stream points to buffer1		ulist<string_object> field_names;							// List for holding all record field names	while(record_stream >> field_chars)						// Get names from record_stream	{	// Add each field name to list using ascending lexical order 		if (field_names.add(string_object(field_chars), DATA, ASCENDING)==ERROR)		{			cout << "ERROR: field name '" << field_chars << "' is not unique to this list\n";			return ERROR;		}	}		// Add record_object to the record_list using ascending lexical order on record_name	if (record_list.add(record_object(record_name, field_names), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: record name is not unique to this list\n";		return ERROR;	}	return SUCCESS;}// Define method for deleting record with identifying name from record_liststatus data_manager::delete_record(string_class name){	if (record_list.remove(name, COUNTER)==ERROR)	{		cout << "ERROR: record name not found\n";		return ERROR;	}	else		return SUCCESS;}// Define method for outputting record_listvoid data_manager::output_record_list(){ cout << record_list; }// Define method for adding data_set with identifying name to data_liststatus data_manager::new_data(string_class data_set_name, string_class record_name,															int length){	record_object record(record_name);	// look up record name to make sure its valid	if (record_list.search_node(record, COUNTER)==ERROR)	{		cout << "ERROR: No such '" << record_name << "' exists - aborted\n";		return ERROR;	}			// Add data_set_obj to data_list, using ascending lexical order on data_set_name	if (data_list.add(data_set_obj(data_set_name, data_set(record, length)),																 COUNTER,ASCENDING)==ERROR)	{		cout << "ERROR: Data object name must be unique to this data manager - aborted\n";		return ERROR;	}	else		return SUCCESS;}// Define method for deleting data_set with identifying name from data_liststatus data_manager::delete_data(string_class name){	if (data_list.remove(name, COUNTER)==ERROR)										// Attempt remove on name	{		cout << "ERROR:'" << name << "' data object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting data_listvoid data_manager::output_data_list(){ cout << data_list; }// Define method check data_set_obj exists in data_set list with 'data_name' name,// check all strings in inputfields are valid data_set field names, check all mapnames// strings match to IO_map_objects in map_list with same names, check all field names// referenced inside each IO_map_object are present in specified data_set and return// pointer to data_set_obj with 'data_name' name in 'target'.status data_manager::check_data_list(string_class data_name,	ulist<string_object> inputfields, ulist<string_object> mapnames, data_set_obj* &target){	data_set_obj data;	int found=0;	if (data_list.reset_transverse()==ERROR)									// Error if data_list is empty	{		cout << "ERROR: data_list empty\n";		return ERROR;	}		// Traverse through data_list	do																		// Search data_list for node indexed by 'data_name'	{		data_list.get_transverse(data);													// Get current data_set_object		if (data.get_index()==data_name)												// If match is found...		{			target=data_list.get_transverse_node_pointer();				// Set pointer to this object			found=1;																							// Set found flag			break;																								// Break out of for loop		}	}	while (data_list.progress_transverse()==SUCCESS);					// Search entire data_list	if (!found)																								// If object not found	{		cout << "ERROR: data object named '" << data_name << "' not found\n";			return ERROR;	}		int width=data.get_width();											// Get number of fields in data_set	string_class *fields=new string_class[width];		// Allocate array to hold field names	data.get_fields(fields);												// Copy data_set field names into array	string_object extracted;	// Check all inputfields strings are valid field names	if (inputfields.reset_transverse()==ERROR)				// Error if inputfields list is empty	{		cout << "ERROR: checking data_set fields against empty list of inputfields\n";		return ERROR;	}		// Traverse through inputfields list	do																								{		inputfields.get_transverse(extracted);										// Get current string object		found=0;		// Extract string from string object and check it matches field name of data_set		for (int field_index=0; field_index<width; field_index++)			if 	(fields[field_index]==extracted.get_data())						// If match is found...			{				found=1;																								// Set found flag				break;																									// Break out of for loop			}		if (!found)																									// If string not found		{			cout << "ERROR: field name '" << extracted.get_data() <<							"' referenced in inputfields not found in data_set fields\n";			return ERROR;		}	}	while (inputfields.progress_transverse()==SUCCESS);				// Search through all strings			// Check mapfields strings contained in 'fields'	string_object string_node;	IO_map_object temp;	if (mapnames.reset_transverse()==SUCCESS)									// If mapnames list not empty	{		// Traverse through entire mapnames list		do		{			mapnames.get_transverse(string_node);									// Get current IO_map object			temp=IO_map_object(string_node.get_data());						// Load with current mapname			// If found, call to search_node loads IO_map of temp with found IO_map			if (map_list.search_node(temp,COUNTER)==ERROR)				// If mapname not valid...			{				cout << "ERROR: map object with name '" << string_node.get_data() <<							"' not found\n";				return ERROR;			}						// Check all input fields of map_object are data_set fields			// Store all input field names in IO_map in 'input_fields' array			int no_of_input_fields=temp.get_number_of_input_fields();			string_class *input_fields=new string_class[no_of_input_fields];			temp.get_input_fields(input_fields);			// Check every field name in input_fields array for being present in data_set			for (int i=0; i<no_of_input_fields; i++)		// For all elements in input_fields			{				found=0;																	// Reset found flag				for (int j=0; j<width; j++)								// For all elements in data_set 'fields'					if (fields[j]==input_fields[i])					// If match found					{						found=1;															// Set found flag						break;																// break out of inner for loop					}				if (!found)																// If input_field not found...				{					cout << "ERROR: input field name '" << extracted.get_data() <<									"' referenced in '" << temp.get_index() <<									"' map object not found in data_set fields\n";					return ERROR;				}			}			// Check all output fields of map_object are data_set fields			// Store all output field names in IO_map in 'output_fields' array			int no_of_output_fields=temp.get_number_of_output_fields();			string_class *output_fields=new string_class[width];			temp.get_output_fields(output_fields);						// Check every field name in output_fields array for being present in data_set			for (int i=0; i<no_of_output_fields; i++)		// For all elements in output_fields			{				found=0;																	// Reset found flag				for (int j=0; j<width; j++)								// For all elements in data_set 'fields'					if (fields[j]==output_fields[i])				// If match found					{						found=1;															// Set found flag						break;																// Break out of inner for loop					}				if (!found)																// If output_field not found				{					cout << "ERROR: input field name '" << extracted.get_data() <<									"' referenced in '" << temp.get_index() <<									"' map object not found in data_set fields\n";					return ERROR;				}			}		}		while (mapnames.progress_transverse()==SUCCESS);// Check all mapnames are in map_list		return SUCCESS;																	// All checked out okay	}	else																														// Empty mapnames list	{		cout << "ERROR: checking map list against empty list of names";		return ERROR;	}}// Define method for adding IO_map with identifying name to map_liststatus data_manager::new_map(string_class map_name, string_class input_fields,														 string_class output_fields){	char input_chars[1000];													// Buffer1 to hold fields as whole	char field_chars[100];													// Buffer2 to hold individual field	char output_chars[1000];												// Buffer1 to hold fields as whole		input_fields.string_copy(input_chars);					// Extract char array from input_fields	istrstream input_stream(input_chars);						// Input_stream points to buffer1		// Process input_fields	ulist<string_object> field_names;								// List for holding all field names	while(input_stream >> field_chars)							// Get names from input_stream	{ // Add each field name to list using ascending lexical order		if (field_names.add(string_object(field_chars), COUNTER, ASCENDING)==ERROR)		{			cout << "ERROR: input field name is not unique to this list\n";			return ERROR;		}	}	output_fields.string_copy(output_chars);					// Extract char array from input_fields	istrstream input_stream2(output_chars);						// Input_stream points to buffer1		// Process output_fields	ulist<string_object> field_names2;								// List for holding all field names	while(input_stream2 >> field_chars)							// Get names from input_stream	{ // Add each field name to list using ascending lexical order		if (field_names2.add(string_object(field_chars), COUNTER, ASCENDING)==ERROR)		{			cout << "ERROR: output field name is not unique to this list\n";			return ERROR;		}	}	// Add IO_map_object to the map_list using ascending lexical order on map_name	if (map_list.add(IO_map_object(map_name,			IO_map (field_names , field_names2) ), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: name is not unique to this list\n";		return ERROR;	}	return SUCCESS;}// Define method for deleting IO_map with identifying name from map_liststatus data_manager::delete_map(string_class name){	if (map_list.remove(name, COUNTER)==ERROR)	{		cout << "ERROR: '" << name << "' IO_map object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting map_listvoid data_manager::output_map_list(){	cout << map_list; }// Define method for adding set_input with identifying name to set_input_liststatus data_manager::new_set_input(string_class set_input_name, int lower_i,																	 int upper_i, double start_val, double increment){ // Add to list using ascending lexical order	if (set_input_list.add(set_input_object(set_input_name,				set_input (lower_i, upper_i, start_val, increment)), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: name is not unique to this list\n";		return ERROR;	}	else		return SUCCESS;}// Define method for deleting set_input with identifying name from set_input_liststatus data_manager::delete_set_input(string_class set_input_name){	if (set_input_list.remove(set_input_name, COUNTER)==ERROR)	{		cout << "ERROR: '" << set_input_name << "' IO_map object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting set_input_listvoid data_manager::output_set_input_list(){	cout << set_input_list; }// Define method for checking all names in sourcelist are names of set_input_objects// in set_input_liststatus data_manager::check_set_input_list(ulist<string_object> sourcelist){	string_object string_node;	if (sourcelist.reset_transverse()==SUCCESS)									// If sourcelist not empty	{		do		{			sourcelist.get_transverse(string_node);									// Get current string object			// Search for set_input_object indexed by string object data in set_input_list			if (set_input_list.search_node				 (set_input_object(string_node.get_data()),COUNTER)==ERROR)				// If not found			{				cout << "ERROR: set_input object with name '" << string_node.get_data() <<							"' not found\n";				return ERROR;			}		}		while (sourcelist.progress_transverse()==SUCCESS);				// Check all string objects		return SUCCESS;																						// All checked out okay.	}	else																												// Sourcelist is empty	{		cout << "ERROR: checking set_input list against empty list of names";		return ERROR;	}}// Define method for clearing all manager listsvoid data_manager::reset_manager(){	record_list.clearlist();										// Clear record list	data_list.clearlist();											// Clear data list	map_list.clearlist();												// Clear map list	set_input_list.clearlist();									// Clear set_input list}/*---------------------------------------------------------------------------------------  ---------------------------- End of data_manager.c++ ----------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: record_object.c++ * PURPOSE	: define members of record_object class **************************************************************************************/#include "record_object.h"// Define default constructorrecord_object::record_object(){	next_record_object = NULL;	name=record_object::undefined_index;}// Define constructor using string_class to initialiserecord_object::record_object(string_class name_string){	name=name_string;	next_record_object = NULL;}// Define constructor using string_class and ulist<string_object> to initialiserecord_object::record_object(string_class name_string, ulist<string_object> data_list){	name=name_string;	data=data_list;	next_record_object = NULL;}// Define copy constructorrecord_object::record_object(record_object &original){	name=original.name;	data=original.data;	next_record_object=original.next_record_object;}// Define assignment of record_object objects by record_object objectsrecord_object& record_object::operator=(record_object &original){	name=original.name;	data=original.data;	next_record_object=original.next_record_object;	return *this;}// Define method for extracting index fieldstring_class record_object::get_index(){ return name; }// Define method for setting index fieldstatus record_object::set_index(const string_class setting)	{	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid record_object::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid record_object::set_to_next_index(const string_class ref){	name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare record_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldulist<string_object> record_object::get_data(){ return data; }	// Define method for setting data fieldstatus record_object::set_data(ulist<string_object> setting)	{	data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare record_object::compare_data( ulist<string_object> name1, 																		 ulist<string_object> name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;																// Arbitrary ulist<string_object> ordering}// Define method for setting pointer fieldvoid record_object::set_pointer_to(record_object *p){ next_record_object=p; }// Define method for extracting pointer fieldrecord_object* record_object::get_pointer(){ return next_record_object; }	// Define method for outputting name_object contents on standard outputvoid record_object::print_node(){cout << name << "-> " << data;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, record_object a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define undefined index as empty stringstring_class record_object::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of record_object.c++ ---------------------------------  ---------------------------------------------------------------------------------------*/  /************************************************************************************** * CODE FILE: data_set.c++ * PURPOSE	: define members of data_set class **************************************************************************************/#include "data_set.h"// Define default constructordata_set::data_set(){	record_name="";	length=0;	width=0;	data_array=NULL;	fields=NULL;}// Define constructor using record_object and integer to initialisedata_set::data_set(record_object record_obj, const int array_length){	width=0;	length=array_length;	ulist<string_object> field_list=record_obj.get_data();		// get copy of record fields	record_name=record_obj.get_index();							// store name of record_obj in data_set	if (field_list.reset_transverse()==ERROR)		cout << "Warning: generation of data_set with null fields list\n";		do																// find out how many objects are in the records list	{ width++; }	while (field_list.progress_transverse()==SUCCESS);		fields=new string_class[width];										// Create array to hold field names	string_object temp_string_object;	field_list.reset_transverse();										// Reset to first string_object	for (int i=0; i<width; i++)												// Build look-up array:	{																									// - maps element number->field name		field_list.get_transverse(temp_string_object);	// Get current string_object		fields[i]=temp_string_object.get_data();		field_list.progress_transverse();								// Progress to next string_object	}	data_array=new complex[length*width];							// Dynamically create data_array 																											clear_data_array();																// Initialise all elements to 0+0j}// Define copy constructordata_set::data_set(const data_set &original){ *this=original; }// Define assignment of data_set objects by data_set objectsdata_set& data_set::operator=(const data_set &original){	// Copy across all non-dynamic data...	record_name=original.record_name;	length=original.length;	width=original.width;		// Now deal with dynamically allocated data...	if (original.fields!=NULL)								// Copy piecewise dynamic field strings array	{		fields=new string_class[width];					// Array maps element index->field name		for (int i=0; i<width; i++)							// Copy across all elements of original array			fields[i]=original.fields[i];	}	else		fields=NULL;														// No field array defined		if (original.data_array!=NULL)						// Copy piecewise dynamic data_array	{		data_array=new complex[length*width];		// Dynamically allocate large enough array		for (int i=0; i<length*width; i++)			data_array[i]=original.data_array[i];	}	else		data_array=NULL;												// No data_array defined	return *this;}// Define destructordata_set::~data_set(){	delete [] data_array;											// Deallocate two dimensional data array	delete [] fields;													// Deallocate single dimensional fields array}// Define method of reading data_array associatively on field name and index integerstatus data_set::get_element_assoc(complex &result, const int index,																	 const string_class field){	if (data_array!=NULL)																// Refuse non-defined array access	{		int field_index=-1;																// Set field_index to invalid value		for (int i=0; i<width; i++)												// Find out index for 'field'			if (fields[i]==field)														// Matching field name found...			{				field_index=i;																// Record corresponding index, and				break;																				// exit loop.			}		if (field_index==-1 || index<0 || index>=length)	// Index(s) invalid...		{			result=complex(0,0);														// Nullify result			return ERROR;		}		result=*(data_array+width*index+field_index);			// Get requested element of array		return SUCCESS;	}	else																								// Data_array is not defined...	{		result=complex(0,0);															// Nullify result		return ERROR;	}	}// Define method of reading data_array (non-associative: indexed field/indexed integer)status data_set::get_element(complex &result, const int index, const int field_index){	if (data_array!=NULL)																// Refuse non-defined array access	{	// Check both indexes for valid range		if (field_index<0 || field_index>=width || index<0 || index>=length)		{			result=complex(0,0);														// Nullify result			return ERROR;		}		result=*(data_array+width*index+field_index);			// Return array mapped result		return SUCCESS;	}	else																								// Data_array is not defined...	{		result=complex(0,0);															// Nullify result		return ERROR;	}	}// Define method of writing data_array associatively on field name and index integerstatus data_set::set_element_assoc(const complex new_value, const int index,																	 const string_class field){	if (data_array!=NULL)																// Refuse non-defined array access	{		int field_index=-1;																// Set field_index to invalid value		for (int i=0; i<width; i++)												// Find out index for 'field'			if (fields[i]==field)														// Matching field name found...			{				field_index=i;																// Record corresponding index, and				break;																				// exit loop.			}		if (field_index==-1 || index<0 || index>=length)	// Index(s) invalid...			return ERROR;					*(data_array+width*index+field_index)=new_value;	// Set requested element of array 		return SUCCESS;	}	else																								// Data_array is not defined...		return ERROR;}// Define method of writing data_array associatively on field name and index integerstatus data_set::set_element(const complex new_value, const int index,														 const int field_index){	if (data_array!=NULL)																// Refuse non-defined array access	{	// Check both indexes for valid range		if (field_index<0 || field_index>=width || index<0 || index>=length)			return ERROR;						*(data_array+width*index+field_index)=new_value;	// Set requested element of array		return SUCCESS;	}	else																								// Data_array is not defined...		return ERROR;}// Define method to set all elements in data array to 0+0jstatus data_set::clear_data_array(){	if (data_array!=NULL)																// If data array is defined	{		for (int i=0; i<width*length; i++)								// Initialise all complex elements			data_array[i]=complex (0,0);			return SUCCESS;	}	else	{		cout << "ERROR: can't clear_data_array as data array is not set\n";		return ERROR;	}}// Define overloaded output operator for data_set objectostream& operator<<(ostream& output_stream, data_set output_set){	complex number;		if (output_set.data_array!=NULL)												// If data array is initialised	{		output_stream << "Record Base: " << output_set.record_name << "\n";		output_stream << "Dimensions: " << output_set.length << "x";		output_stream <<  output_set.width << "\n";		output_stream << "Field Names: (" << output_set.width << ")\n\t\t";		for (int i=0; i<output_set.width; i++)											// Output all field names			output_stream << output_set.fields[i] << '\t';		output_stream << "\n";				for (int i=0; i<output_set.length; i++)		{			output_stream.width(3);																// Use character field width			output_stream << 'i' << '=' << i << ")\t";						// Output all elements of			for (int j=0; j<output_set.width; j++)								// data_array			{				output_set.get_element(number, i, j);				output_stream << number << "\t\t";			}			output_stream << "\n";		}				}	else		output_stream << "data_set not initialised\n";	return output_stream;}// Provide read-access to private data membersint data_set::get_length(){ return length; }int data_set::get_width(){	return width; }string_class data_set::get_record_name(){ return record_name; }void data_set::get_fields(string_class *storage){	if (data_array!=NULL)																// Refuse non-defined array access	{		for (int i=0; i<width; i++)			storage[i]=fields[i];	}}/*---------------------------------------------------------------------------------------  ---------------------------- End of data_set.c++ --------------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: data_set_obj.c++ * PURPOSE	: define members of data_set_obj class **************************************************************************************/#include "data_set_obj.h"// Define default constructordata_set_obj::data_set_obj(){	next_data_set_obj = NULL;	name=data_set_obj::undefined_index;}// Define constructor using string_class to initialisedata_set_obj::data_set_obj(string_class name_string){	name=name_string;	next_data_set_obj = NULL;}// Define constructor using string_class and data_set to initialisedata_set_obj::data_set_obj(string_class name_string, data_set data_list){	name=name_string;	data=data_list;	next_data_set_obj = NULL;}// Define copy constructordata_set_obj::data_set_obj(data_set_obj &original){ *this=original; }// Define assignment of data_set_obj objects by data_set_obj objectsdata_set_obj& data_set_obj::operator=(data_set_obj &original){	name=original.name;	data=original.data;	next_data_set_obj = original.next_data_set_obj;	return *this;}// Define method for extracting index fieldstring_class data_set_obj::get_index(){ return name; }// Define method for setting index fieldstatus data_set_obj::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid data_set_obj::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid data_set_obj::set_to_next_index(const string_class ref){ name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare data_set_obj::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fielddata_set data_set_obj::get_data(){ return data; }	// Define method for setting data fieldstatus data_set_obj::set_data(data_set setting){		data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare data_set_obj::compare_data(const data_set name1, const data_set name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;																				// Arbitrary ordering for data_set}// Define method for setting pointer fieldvoid data_set_obj::set_pointer_to(data_set_obj *p){ next_data_set_obj=p; }// Define method for extracting pointer fielddata_set_obj* data_set_obj::get_pointer(){ return next_data_set_obj; }	// Define method for outputting name_object contents on standard outputvoid data_set_obj::print_node(){cout << name << "-> " << data;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, data_set_obj a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define methods for accessing public data members inside data field (data_set)status data_set_obj::get_element_assoc(complex &result, const int index,																			 const string_class field){ return data.get_element_assoc(result, index, field); }status data_set_obj::set_element_assoc(const complex new_value, const int index,																			 const string_class field){ return data.set_element_assoc(new_value, index, field); }status data_set_obj::get_element(complex &result, const int index, const int field_index){ return data.get_element(result, index, field_index); }status data_set_obj::set_element(const complex new_value, const int index,																 const int field_index){ return data.set_element(new_value, index, field_index); }int data_set_obj::get_length(){ return data.get_length(); }int data_set_obj::get_width(){	return data.get_width(); }void data_set_obj::get_fields(string_class *storage){	data.get_fields(storage); }status data_set_obj::clear_data_array(){ return data.clear_data_array();}// Define method for applying set_input to field 'field' of data_set in this data_set_objstatus data_set_obj::load_real_input(set_input &input, string_class field){	int index_low, index_high;													// Variables to hold 'input' fields	double start_value, increment;											// Variables to hold 'input' fields	int width=data.get_width();													// Holds width of data_set	string_class *fields=new string_class[width];				// Holds record fields from data_set	data.get_fields(fields);														// Extract record fields	status found=ERROR;																	// Error flag	int field_index=0;																	// integer index of selected field		for (int i=0; i<width; i++)											// Find the integer index of the 'field'		if (fields[i]==field)		{			field_index=i;			found=SUCCESS;		}	delete [] fields;																	// Fields array not required any more		if (found==ERROR)																	// Catch invalid 'field' name	{		cout << "ERROR: field '" << field << "' is not valid for this data_set\n";		return ERROR;	}		// extract parameters stored inside input_set 'input'	input.get_parameters(index_low, index_high, start_value, increment);			if (index_low<0 || index_high>=data.get_length())		// ERROR if out of range index	{		cout << "ERROR: attempt to set out of range element in data_set\n";		return ERROR;	}		int current_value=start_value;	for (int i=index_low; i<=index_high; i++)						// Load appropriate field with data	{		if (data.set_element(complex(start_value,0), i, field_index)==ERROR)		{			cout << "ERROR: set_element in data_set_obj::load_real_input\n";			return ERROR;		}		start_value+=increment;	}	return SUCCESS;}// Define function to return address of data_set datadata_set* data_set_obj::get_data_set_pointer(){	return &data;}// Define undefined index as empty stringstring_class data_set_obj::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of data_set_obj.c++ ----------------------------------  ---------------------------------------------------------------------------------------*/ /************************************************************************************** * CODE FILE: set_input.c++ * PURPOSE	: define members of set_input class **************************************************************************************/#include "set_input.h"// Define default constructorset_input::set_input(){ lower_index=upper_index=start_value=incrementer=0; }// Define parameterized constructorset_input::set_input(int lower_i, int upper_i, double start_val, double inc){ set_parameters(lower_i, upper_i, start_val, inc); }// Define destructorset_input::~set_input(){	// do nothing as there is no dynamic allocation}// Define copy constructorset_input::set_input(set_input &original){ *this=original; }// Define assignment of set_input objects by set_input objectsset_input& set_input::operator=( set_input &original){	lower_index=original.lower_index;	upper_index=original.upper_index;	start_value=original.start_value;	incrementer=original.incrementer;	return *this;}// Define overloaded output operator for set_inputostream& operator<<(ostream& output_stream, const set_input output_set){	output_stream << "lower index=" << output_set.lower_index << "\n";	output_stream << "upper index=" << output_set.upper_index << "\n";	output_stream << "start value=" << output_set.start_value << "\n";	output_stream << "incrementer=" << output_set.incrementer << "\n";		output_stream << "\n";		return output_stream;}// define method for setting private data membersvoid set_input::set_parameters(int lower_i, int upper_i, double start_val, double inc){	if (lower_index>upper_index)								// swap over the indexes	{			int temp=upper_index;		upper_index=lower_index;		lower_index=temp;	}	lower_index=lower_i;	upper_index=upper_i;	start_value=start_val;	incrementer=inc;}// define method for extracting private data membersvoid set_input::get_parameters(int &lower_i, int &upper_i, double &start_val, double &inc){	lower_i=lower_index;	upper_i=upper_index;	start_val=start_value;	inc=incrementer;}/*---------------------------------------------------------------------------------------  ---------------------------- End of set_input.c++ -------------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: set_input_object.c++ * PURPOSE	: define members of set_input_object class **************************************************************************************/#include "set_input_object.h"// Define default constructorset_input_object::set_input_object()  {	next_set_input_object = NULL;	name=set_input_object::undefined_index;}// Define constructor using string_class to initialiseset_input_object::set_input_object(string_class name_string){	next_set_input_object = NULL;	name=name_string;}// Define constructor using string_class and set_input to initialiseset_input_object::set_input_object(string_class name_string, set_input data){	name=name_string;	load_data=data;	next_set_input_object = NULL;	}// Define copy constructorset_input_object::set_input_object(set_input_object &original){	*this=original; }// Define assignment of set_input_object objects by set_input_object objectsset_input_object& set_input_object::operator=(set_input_object &original){	name=original.name;	load_data=original.load_data;	next_set_input_object = original.next_set_input_object;		return *this;}// Define method for extracting index fieldstring_class set_input_object::get_index(){ return name; }// Define method for setting index fieldstatus set_input_object::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid set_input_object::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid set_input_object::set_to_next_index(const string_class ref){	name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare set_input_object::compare_index(const string_class index1,																				const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldset_input set_input_object::get_data()	{ return load_data; }	// Define method for setting data fieldstatus set_input_object::set_data(set_input setting){		load_data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare set_input_object::compare_data(const set_input name1, const set_input name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;															// Arbitrary ordering for set_input objects}// Define method for setting pointer fieldvoid set_input_object::set_pointer_to(set_input_object *p){ next_set_input_object=p; }// Define method for extracting pointer fieldset_input_object* set_input_object::get_pointer(){ return next_set_input_object; }		// Define method for outputting name_object contents on standard outputvoid set_input_object::print_node(){cout << name << "-> " << load_data;}// Define overloaded output operator for set_input_objectostream& operator<<(ostream& output_stream, set_input_object a){	output_stream << a.name << "->" << a.load_data;	return output_stream;}// Define undefined index as empty stringstring_class set_input_object::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of set_input_object.c++ ------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: IO_map.c++ * PURPOSE	: define members of IO_map class **************************************************************************************/#include "IO_map.h"// Define default constructorIO_map::IO_map(){	input_length=0;	input_fields=NULL;	output_length=0;	output_fields=NULL;}// Define parameterized constructorIO_map::IO_map(ulist<string_object> in_fields, ulist<string_object> out_fields){	input_length=output_length=0;												// Initialise lengths to 0		// First deal with in_fields data	do																	// find out how many objects are in the string list	{	input_length++;	}	while (in_fields.progress_transverse()==SUCCESS);		// Progress through entire list	string_object temp_string_object;	input_fields=new string_class[input_length];				// Array holds in_field names	in_fields.reset_transverse();												// Reset to first node in list	for (int i=0; i<input_length; i++)									// Build look-up array:	{																										// maps element number->field name		in_fields.get_transverse(temp_string_object);			// Get current string object		input_fields[i]=temp_string_object.get_data();		in_fields.progress_transverse();									// Progress to next string object	}		// Now deal with out_fields data	do																	// find out how many objects are in the string list	{	output_length++;	}	while (out_fields.progress_transverse()==SUCCESS);	// Progress through entire list	output_fields=new string_class[output_length];			// Array holds in_field names	out_fields.reset_transverse();											// Reset to first node in list	for (int i=0; i<output_length; i++)									// Build look-up array:	{																										// maps element number->field name		out_fields.get_transverse(temp_string_object);		// Get current string object		output_fields[i]=temp_string_object.get_data();		out_fields.progress_transverse();									// Progress to next string object	}}// Define copy constructorIO_map::IO_map(IO_map &original){ *this=original; }// Define assignment of IO_map objects by IO_map objectsIO_map& IO_map::operator=(const IO_map &original){	// Copy across all non-dynamic data...	input_length=original.input_length;	output_length=original.output_length;	input_fields=NULL;	// Now deal with input_fields...	if (original.input_fields!=NULL)															// Copy only if >0 fields	{		input_fields=new string_class[input_length];	// Array maps element index->field name		for (int i=0; i<input_length; i++)						// Copy across all elements of original			input_fields[i]=original.input_fields[i];	}	else		input_fields=NULL;																		// Original has no input_fields	// Now deal with output_fields...	if (original.output_fields!=NULL)												// Copy only if >0 fields	{		output_fields=new string_class[output_length];// Array maps element index->field name		for (int i=0; i<output_length; i++)						// Copy across all elements of original			output_fields[i]=original.output_fields[i];	}	else		output_fields=NULL;																		// Original has no input_fields	return *this;}// Define destructorIO_map::~IO_map(){	delete [] input_fields;	delete [] output_fields;}// Define access functions to private member dataint IO_map::get_number_of_input_fields(){	return input_length; }int IO_map::get_number_of_output_fields(){	return output_length; }void IO_map::get_output_fields(string_class *storage){	if (output_fields!=NULL)													// Refuse access to non-defined array  	{				for (int i=0; i<output_length; i++)							// Make copy of all field elements			storage[i]=output_fields[i];									// for returning in 'storage'	}}void IO_map::get_input_fields(string_class *storage){	if (input_fields!=NULL)														// Refuse access to non-defined array  	{				for (int i=0; i<input_length; i++)							// Make copy of all field elements			storage[i]=input_fields[i];										// for returning in 'storage'	}}// Define overloaded output operator for IO_map objectostream& operator<<(ostream& output_stream, const IO_map output_map){	if (output_map.input_fields!=NULL)					// Refuse output when input fields undefined	{		output_stream << "		  Input Fields: ";		for (int i=0; i<output_map.input_length; i++)			cout << output_map.input_fields[i] << ", ";		output_stream << '\n';		output_stream << "		  Output Fields: ";		for (int i=0; i<output_map.output_length; i++)			cout << output_map.output_fields[i] << ", ";		output_stream << '\n';	}	else		output_stream << "ERROR: IO_map not initialised\n";	return output_stream;	}/*---------------------------------------------------------------------------------------  ---------------------------- End of IO_map.c++ ----------------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: IO_map_object.c++ * PURPOSE	: define members of IO_map_object class **************************************************************************************/#include "IO_map_object.h"// Define default constructorIO_map_object::IO_map_object(){	next_IO_map_object = NULL;	name=IO_map_object::undefined_index;}// Define constructor using string_class to initialiseIO_map_object::IO_map_object(string_class map_name){	next_IO_map_object = NULL;	name=map_name;} // Define constructor using string_class and IO_map to initialiseIO_map_object::IO_map_object(string_class map_name, IO_map new_map){		next_IO_map_object = NULL;	name=map_name;	map=new_map;}// Define copy constructorIO_map_object::IO_map_object(IO_map_object &original){	name=original.name;	map=original.map;	next_IO_map_object=original.next_IO_map_object;}// Define assignment of IO_map_object objects by IO_map_object objectsIO_map_object& IO_map_object::operator=(IO_map_object &original){	name=original.name;	map=original.map;	next_IO_map_object=original.next_IO_map_object;	return *this;}// Define method for extracting index fieldstring_class IO_map_object::get_index(){ return name; }// Define method for setting index fieldstatus IO_map_object::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid IO_map_object::set_to_first_index(){	name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid IO_map_object::set_to_next_index(const string_class ref)	{	name=ref+"a";	}// Define method for comparing two index objects - lexical comparison of string_classcompare IO_map_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldIO_map IO_map_object::get_data()	{ return map; }	// Define method for setting data fieldstatus IO_map_object::set_data(IO_map setting){			map=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare IO_map_object::compare_data(const IO_map name1, const IO_map name2){	#pragma unused (name1)	#pragma unused (name2)	return SMALLER; 																				// Arbitrary ordering on IO_map}// Define method for setting pointer fieldvoid IO_map_object::set_pointer_to(IO_map_object *p){ next_IO_map_object=p; }	// Define method for extracting pointer fieldIO_map_object* IO_map_object::get_pointer(){ return next_IO_map_object; }	// Define method for outputting name_object contents on standard outputvoid IO_map_object::print_node(){cout << name << "-> " << map;}// Define overloaded output operator for IO_map_objectostream& operator<<(ostream& output_stream, IO_map_object a){	output_stream << a.name << "->" << a.map;	return output_stream;}// Define methods for accessing public data members inside data field (IO_map)void IO_map_object::get_input_fields(string_class *stored_input_fields){ map.get_input_fields(stored_input_fields); }int IO_map_object::get_number_of_input_fields(){	return map.get_number_of_input_fields(); }void IO_map_object::get_output_fields(string_class *stored_output_fields){ map.get_output_fields(stored_output_fields); }int IO_map_object::get_number_of_output_fields(){	return map.get_number_of_output_fields(); }// Define undefined index as empty stringstring_class IO_map_object::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of IO_map_object.c++ ---------------------------------  ---------------------------------------------------------------------------------------*/