/************************************************************************************** * CODE FILE: CalculatorManager.c++ * PURPOSE	: define members of calculator_manager class **************************************************************************************/#include "CalculatorManager.h"extern const int MAX_IO=1000;												// Ref. Buffer size for input/output// Define CLI using cin/cout streams for accessing calculator_manager functionsvoid calculator_manager::interface(){	char input_string[MAX_IO]="";											// Initialise primary input char array	char input[MAX_IO]="";														// Initialise second input char array	string_class preprocessed_string;	string_class name;	string_class errors;	complex result;			cout << "\nCalculator Manager.";														// Output manager prompt	if (current_calc==NULL)																			// If no calculators in list		cout << "NULL> ";																					// Output NULL name	else		cout << current_calc->get_index() << "> ";								// Output current calc name	while (cin >> input_string)																	// Main interface loop	{		if (strcmp(input_string,"add")==0)						// Command for adding calculator to list		{			cin >> name;																// Get identifier for calculator			add_calculator(name);												// Add new calculator to list			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"remove")==0)					// Command for removing calc from list		{			cin >> name;																// Get identifier for calculator			remove_calculator(name);										// Remove calculator from list			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"set_current")==0)		// Command for setting current calc 		{			cin >> name;																// Get identifier for calculator			set_current_calc(name);											// Set current calculator to 'name'			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"storage")==0)				// Command for dumping vars/eqns to cout		{																							// for current calculator.			current_storage(cout);											// Output variables and equations			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"errors")==0)					// Command for dumping errors in current		{																							// calculator to cout.			current_errors(cout);												// Output error report.			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"clear_errors")==0)		// Command for clearing errors in curr.		{			current_clear_errors();											// Clear error report in current calc.			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"clear_memory")==0)		// Command to clear all variables and		{																							// equations in current calculator			cout << clear_memory();											// Clear all memories, report any errors			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"clear")==0)					// Command to clear single variable or		{																							// equation in current calculator			cin >> name;																// Get identifier for var/eqn			cout << clear_single_memory(name);					// Clear the memory, report any errors			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"resetmanager")==0)		// Command to re-initialise manager,		{																							// ie clear calculator list			reset_manager();			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"verify")==0)					// Command for verifying all equations		{																							// in current calculator			validate_current();													// Validate all equations			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"auto_verify_on")==0)	// Command for activating auto-verify		{			auto_verify_on();			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"auto_verify_off")==0)	// Command to deactivate auto-verify		{			auto_verify_off();			goto prompt;																	// Jump to end of interface loop		}				if (strcmp(input_string,"dump")==0)					// Command to output all calculators names		{																						// and contents in calculator list			cout << *this;			goto prompt;															// Jump to end of interface loop		}				if (strcmp(input_string,"order")==0)			// Command for sending expression/assignment		{																					// /definition to current calculator			cin.get(input, MAX_IO);									// Get all user input up to newline			result=process_order(input);						// Evaluate the order using current calc.			if (current_calc!=NULL)									// If current calculator is set...			{				// If errors stored in current calc, output those errors to cout				if (current_calc->get_number_of_errors()!=0)						cout << "Errors are present in '" << current_calc->get_index() << "'\n";				// Output result of order to cout				cout << "result is: '" << result << "'\n";			}						goto prompt;															// Jump to end of interface loop		}				if (strcmp(input_string,"help")==0)				// Command for displaying CLI command list		{			display_help();			goto prompt;														// Jump to end of interface loop		}				if (strcmp(input_string,"return")==0)			// Break out of the CLI		{			break;		}				cout << "No Command\n";																		// Catch invalid commands				prompt:																										// End of loop label				cout << "\nCalculator Manager.";													// Output manager prompt		if (current_calc==NULL)																		// If no calculators in list			cout << "NULL> ";																				// Output NULL name		else			cout << current_calc->get_index() << "> ";							// Output current calc name	}}// Define function to display all calculator manager commands to the screenvoid calculator_manager::display_help(){	cout << "Commands Available:\n";	cout << "\t add <name>\n";	cout << "\t remove <name>\n";	cout << "\t set_current <name>\n";	cout << "\t storage\n";	cout << "\t errors\n";	cout << "\t clear_errors\n";	cout << "\t clear_memory\n";	cout << "\t clear <name>\n";	cout << "\t resetmanager\n";	cout << "\t verify\n";	cout << "\t auto_verify_on\n";	cout << "\t auto_verify_off\n";	cout << "\t dump\n";	cout << "\t return\n";	cout << "\t order <expression> | <assignment> | <equation>\n";	cout << "\t help\n\n";}// Define function to clear calculator list and set current_calc to NULLvoid calculator_manager::reset_manager(){	calc_list.clearlist();											// Clear calculator list	current_calc=NULL;													// Initialise current calc to no calc}// Define Default Constructorcalculator_manager::calculator_manager(calc_preprocessor *preprocess){	preprocessor=preprocess;																// Connect a preprocessor object	// Define new validator using preprocessor as reference	// Preprocessor needed by validator for returning list of variable/equation names	equation_checker = new validator(preprocessor);	current_calc=NULL;																// Initialise current calc to no calc}// Define Destructorcalculator_manager::~calculator_manager(){	delete equation_checker;											// Destroy dynamically allocated validator}// Define Copy Constructor - uses overloaded = operatorcalculator_manager::calculator_manager(calculator_manager &original){	calc_list=original.calc_list; }// Define Overloaded = operatorcalculator_manager& calculator_manager::operator=(calculator_manager &source){	calc_list=source.calc_list;																// Copy across calculator list	equation_checker=source.equation_checker;	current_calc=source.current_calc;	return *this;}// Define method for adding a calculator with 'name' to calculator liststatus calculator_manager::add_calculator(const string_class name){	// Add to list using ASCENDING lexical ordering on name	if ((calc_list.add(calc_object(name), COUNTER, ASCENDING))==ERROR)	{		cout << "manager ERROR : New Calculator must have unique name to this manager\n";		return ERROR;	}	else	{		set_current_calc(name);									// Set current_calc to point to new calculator		current_calc->set_validator(equation_checker);		// Connect validator to new calc		return SUCCESS;	}}// Define method for removing a calculator with 'name' from calculator liststatus calculator_manager::remove_calculator(const string_class name){	if (calc_list.remove(calc_object(name), COUNTER)==SUCCESS)	{		set_current_calc();					// Set current to first calc in list or NULL if list empty		return SUCCESS;	}	else	{		cout << "Manager ERROR - " << name << " calculator was not removed because '" << 																  name <<"' calculator doesn't exist\n";		return ERROR;	}}// Define method for outputting current calculator's lists of variables and equationsostream& calculator_manager::current_storage(ostream &output_stream){	if (current_calc==NULL)																		// If calculator list is empty	{		cout << "Current Calculator not set\n";		output_stream << "Manager ERROR - current calculator not set\n";	}	else		output_stream << *current_calc;													// Output contents of current	return output_stream;}// Define method for outputting current calculator's lists error reportostream& calculator_manager::current_errors(ostream &output_stream){	if (current_calc==NULL)																		// If calculator list is empty	{		cout << "Current Calculator not set\n";		output_stream << "Manager ERROR - current calculator not set\n";	}	else		current_calc->peek_errors(output_stream);								// Output error report 	return output_stream;}// Define method for validating all equations in current calculatorstatus calculator_manager::validate_current(){	if (current_calc!=NULL)																	// If calculator list not empty	{		if (equation_checker->validate(&current_calc->get_data())==SUCCESS)	// Check equations		{			cout << "Calculator Manager declares '" << current_calc->get_index() <<						  "' to have integrity\n";			return SUCCESS;		}		else		{			cout << "ERROR : Calculator Manager finds circular definition in '" <<							current_calc->get_index() << "'\n";			cout << "		 Error Trace: " << equation_checker->error_trace << "\n";			return ERROR;		}	}	else	{		cout << "Manager ERROR - current calculator not set\n";		// Calculator list is empty		return ERROR;	}}// Define method for clearing error report in current calculatorstring_class calculator_manager::current_clear_errors(){	if (current_calc==NULL)																			// If calculator list empty	{		cout << "Current Calculator not set\n";		return "Manager ERROR - current calculator not set\n";	}	else		return current_calc->flush_errors();											// Clear error report}// Define method for clearing all variables & equations in current calculatorstring_class calculator_manager::clear_memory(){	if (current_calc==NULL)																			// If calculator list empty		return "Manager ERROR - current calculator not set\n";	else	{		current_calc->all_clear();																// Clear all memories		return "";	}}// Define method for clearing a single variable or equation in current calculatorstring_class calculator_manager::clear_single_memory(string_class name){	if (current_calc==NULL)																			// If calcalator list empty		return "Manager ERROR - current calculator not set\n";	else	{		if(current_calc->clear_single_memory(name)==ERROR)				// Name not found			return "Invalid name\n";		else			return "Cleared\n";	}}// Define method to send an order (expression/assignment/equation) to current calculatorcomplex calculator_manager::process_order(const string_class &calc_order){	if (current_calc==NULL)																			// If calcalator list empty		cout << "Current Calculator not set\n";	else	{		string_class preprocessed_string;		complex result;		preprocessor->preprocess(calc_order, preprocessed_string);				// Preprocess order		result=current_calc->evaluate(preprocessed_string);								// Evaluate order		return result;																				// Return complex number result	}	return complex (0,0);																							// Return NULLcomplex}// Define method for activating auto_verify for current_calculatorvoid calculator_manager::auto_verify_on(){	if (current_calc==NULL)																			// If calculator list empty		cout << "Current Calculator not set\n";	else	{		if(current_calc->auto_verify_on()==ERROR)			cout << "Circular equations detected - remove them - auto verify off";		else			cout << "Auto Verify Activated\n";	}}// Define method for deactivating auto_verify for current_calculatorvoid calculator_manager::auto_verify_off(){	if (current_calc==NULL)																			// If calculator list empty		cout << "Current Calculator not set\n";	else	{		cout << "Auto Verify Deactivated\n";		current_calc->auto_verify_off();	}}// Define method for returning name of current calculatorstring_class calculator_manager::get_current_calc(){	if (current_calc==NULL)																			// If calculator list empty		return "";	else		return current_calc->get_index();}// Define method for setting current calculator to calculator identified by 'name_string'status calculator_manager::set_current_calc(const string_class name_string){	calc_object *calculator_p;	if (calc_list.reset_transverse()==ERROR)						// Reset to head of calculator list	{		if (name_string!="")			cout << "Manager ERROR - can't set current calculator when calculator list is empty!\n";		current_calc=NULL;												// Reset current calculator to no calculator		return ERROR;	}		if (name_string=="")													// If first calculator in list is required	{		current_calc=calc_list.get_transverse_node_pointer();		return SUCCESS;	}		// Search calculator list for calculator identified by name_string	do	{		calculator_p=calc_list.get_transverse_node_pointer();				// Get current calculator		if (calculator_p->get_index()==name_string)									// If names match...		{						current_calc=calculator_p;																// Set current calculator			return SUCCESS;		}	}	while(calc_list.progress_transverse()==SUCCESS);							// Progress to next calc		cout << "Manager ERROR - setting current calculator failed as calculator with name '"			 << name_string << "' does not exist\n";	return ERROR;}// Define overloaded output operator for calculator_manager classostream& operator<<(ostream& output_stream, calculator_manager &output){	output_stream << "\nCalculator Manager List:\n\n";	if (output.calc_list.reset_transverse()==ERROR)									// Calculator list empty	{		output_stream << "No Calculators Present\n";		return output_stream;	}		calc_object calc;		do 															// Output contents of all calculators in calculator list	{		output.calc_list.get_transverse(calc);										// Get current calculator		cout << calc << "\n";																			// Output current calculator	}	while (output.calc_list.progress_transverse()==SUCCESS);		// Progress to next calc		return output_stream;}/*---------------------------------------------------------------------------------------  ---------------------------- End of CalculatorManager.c++ -----------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: rCalculatorUserTypes.c++ * PURPOSE	: define members of token_name class & calculator_symbol class **************************************************************************************/#include "rCalculatorUserTypes.h"// Define Default Constructortoken_name::token_name(){	name="";	token=0;}// Define Parameterized Constructortoken_name::token_name(const char *tokenname, const char token_character){	name=tokenname;	token=token_character;}// Define overloaded output operatorostream& operator<<(ostream& output_stream, const token_name output){	return output_stream << output.name << " -> " << output.token; }// Define method for initialising all data membersvoid calculator_symbol::clear(){	token=NAME;	name_string="";	number_value=complex (0,0);}/*---------------------------------------------------------------------------------------  ---------------------------- End of rCalculatorUserTypes.c++ --------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: extraclasses.c++ * PURPOSE	: define members of complex_container class **************************************************************************************/#include "extraclasses.h"#include "calc_preprocessor.h"extern const int MAX_INPUT_STRING_LENGTH=1000;										// Max input buffer size// Define default constructorcomplex_container::complex_container(){	indicator=CONSTANT;	complex_number=complex (0,0);	equation="";}// Define parameterized constructor - storing complex numbercomplex_container::complex_container(macro_type store_indicator,									 complex store_complex_number){	// Set indicator data member	switch (store_indicator)	{		case CONSTANT:			indicator=store_indicator;			break;					case EQUATION:			indicator=CONSTANT;			cout << "Warning - complex_container given EQUATION & complex number\n";			break;		default:			indicator=CONSTANT;			cout << "Warning - complex_container given illegal enum & complex number\n";			break;			}	complex_number=store_complex_number;																// Set complex number}// Define parameterized constructor - storing stringcomplex_container::complex_container(string_class equation_string){	indicator=EQUATION;	equation=equation_string;}// Define overloaded output operatorostream& operator<<(ostream& output_stream, const complex_container container){	switch (container.indicator)	{		case CONSTANT:																					// Output complex number stored			return output_stream << container.complex_number << "\n";		case EQUATION:																	// Output postprocessed equation string		{			string_class postprocessed_string;			complex_container::postprocessing->postprocess(container.equation,																										 postprocessed_string);			return output_stream << "EQUATION=" << postprocessed_string << "\n";		}		default:			return output_stream << "Undefined Enum Value\n" << "\n";	}}// Define overloaded input operatoristream& operator>>(istream& input_stream, complex_container& container){	char buffer[MAX_INPUT_STRING_LENGTH]="\0";	char next_char=0;		int x=0;																									// Character offset for string		// Read in control string - CONSTANT/EQUATION	while(input_stream.get(next_char) && isspace(next_char)) ;					// Skip white space	if (next_char!=0)																			// Putback last character read in		input_stream.putback(next_char);								// if data was present in input_stream			while(input_stream.get(buffer[x]) && x<MAX_INPUT_STRING_LENGTH-1)			// Read in string	{		if (isspace(buffer[x]))														// Terminate reading on whitespace		{			input_stream.putback(buffer[x]);								// Put white space back into stream			buffer[x]='\0';																	// Terminator buffer string			break;		}		x++;																							// Increment character offset	}		if(input_stream.get(next_char) && !isspace(next_char))		// Check for overlong input		cout << "String stream input too long > 1000 chars\n";	if (strcmp(buffer, "CONSTANT")==0)												// Control string was CONSTANT	{		container.indicator=CONSTANT;														// Store CONSTANT in indicator		input_stream >> container.complex_number;								// Read in complex number	}	else	{		if (strcmp(buffer,"EQUATION")==0)												// Control string was EQUATION		{			container.indicator=EQUATION;													// Store EQUATION in indicator			input_stream >> container.equation;										// Read in string from input		}		else																										// Invalid control string			container.indicator=CONSTANT;	}	return input_stream;}// Define method for comparing two complex container objectscompare compare_containers(complex_container left, complex_container right){	// Order on CONSTANT, VARIABLE, EQUATION - ie order on enum int value	// then order on real of complex_container.complex_number, then imag of	// complex_container.complex_number - for EQUATION lexically compare strings 		if (left.indicator<right.indicator)										// CONSTANT < VARIABLE < EQUATION		return SMALLER;	else		if (left.indicator>right.indicator)			return LARGER;		else			if (left.indicator==CONSTANT)														// Comparing complex numbers			{					if (left.complex_number.re<right.complex_number.re)			// Compare real components					return SMALLER;				else					if (left.complex_number.re>right.complex_number.re)						return LARGER;					else						if (left.complex_number.im<right.complex_number.im)	// Compare imag components							return SMALLER;						else							if (left.complex_number.re>right.complex_number.im)								return LARGER;							else								return EQUAL;			}			else			{																												// Comparing equation strings			// Note this ordering is done using equations containing tokens rather than user			// function names.				if (left.equation<right.equation)					return SMALLER;				else					if (left.equation>right.equation)						return LARGER;					else						return EQUAL;			}}// Static declaration of class data membercalc_preprocessor* complex_container::postprocessing;/*---------------------------------------------------------------------------------------  ---------------------------- End of extraclasses.c++ ----------------------------------  ---------------------------------------------------------------------------------------*/  /************************************************************************************** * CODE FILE: name_object.c++ * PURPOSE	: define members of name_object class **************************************************************************************/#include "name_object.h"// Define default constructorname_object::name_object(){	next_name_object = NULL;	name=name_object::undefined_index;}// Define constructor using string_class and complex_container to initialisename_object::name_object(const string_class string, const complex_container complex_field){	name = string;	data = complex_field;	next_name_object = NULL;}// Define constructor using char array and complex_container to initialisename_object::name_object(const char *string, const complex_container complex_field){	name = string;	data = complex_field;	next_name_object = NULL;}// Define copy constructorname_object::name_object(const name_object &original){	name=original.name;	data=original.data;	next_name_object=original.next_name_object;}// Define assignment of name_object objects by name_object objectsname_object& name_object::operator=(name_object &source){	name=source.name;	data=source.data;	next_name_object=source.next_name_object;	return *this;}// Define method for extracting index fieldstring_class name_object::get_index(){ return name; }// Define method for setting index fieldstatus name_object::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid name_object::set_to_first_index(){	name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid name_object::set_to_next_index(const string_class ref){ name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare name_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldcomplex_container name_object::get_data(){ return data; }	// Define method for setting data fieldstatus name_object::set_data(const complex_container setting){	data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare name_object::compare_data(const complex_container name1,																	const complex_container name2){ return (compare_containers(name1, name2)); }// Define method for setting pointer fieldvoid name_object::set_pointer_to(name_object *p){ next_name_object=p; }// Define method for extracting pointer fieldname_object* name_object::get_pointer()	{ return next_name_object; }	// Define method for outputting name_object contents on standard outputvoid name_object::print_node(){cout << name << "-> " << data;}// Define methods for accessing public data members inside data field (complex_container)complex name_object::get_complex(){ return data.complex_number; }void name_object::set_complex(const complex new_complex){ data.complex_number=new_complex; }macro_type name_object::get_indicator(){ return data.indicator; }void name_object::set_indicator(const macro_type new_indicator){ data.indicator=new_indicator; }string_class name_object::get_equation(){ return data.equation; }void name_object::set_equation(const string_class new_equation){	data.indicator = EQUATION;	data.equation = new_equation;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, const name_object a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define undefined index as empty stringstring_class name_object::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of name_object.c++ -----------------------------------  ---------------------------------------------------------------------------------------*/  /************************************************************************************** * CODE FILE: calcobject.c++ * PURPOSE	: define members of calc_object class **************************************************************************************/#include "calcobject.h"// Define default constructorcalc_object::calc_object(){	next_calc_object = NULL;	identifier=calc_object::undefined_index;}// Define constructor using string_class to initialisecalc_object::calc_object(const string_class name){	next_calc_object = NULL;	identifier=name;}// Define copy constructorcalc_object::calc_object(const calc_object &original){	identifier=original.identifier;	data=original.data;	next_calc_object=original.next_calc_object;}// Define assignment of name_object objects by name_object objectscalc_object& calc_object::operator=(calc_object &source){	identifier=source.identifier;	data=source.data;	next_calc_object=source.next_calc_object;	return *this;}// Define method for extracting index fieldstring_class calc_object::get_index(){ return identifier; }// Define method for setting index fieldstatus calc_object::set_index(const string_class setting){	identifier=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid calc_object::set_to_first_index(){ identifier="a"; }// Define method for defining incremental indexing across the list, head->tailvoid calc_object::set_to_next_index(const string_class ref){	identifier=ref+"a";	}// Define method for comparing two index objects - lexical comparison of string_classcompare calc_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldcalculator calc_object::get_data(){ return data; }	// Define method for setting data fieldstatus calc_object::set_data(const calculator setting)	{		data=setting;	return SUCCESS;}	// Define method for comparing two data objectscompare calc_object::compare_data(const calculator calc1, const calculator calc2){#pragma unused (calc1)#pragma unused (calc2)	return (SMALLER);																						// Define arbitrary ordering}// Define method for setting pointer fieldvoid calc_object::set_pointer_to(calc_object *p){	next_calc_object=p; }// Define method for extracting pointer fieldcalc_object* calc_object::get_pointer()	{	return next_calc_object; }	// Define method for outputting name_object contents on standard outputvoid calc_object::print_node(){	cout << "Calculator:" << identifier << "->\n";	cout << "Variable List:\n" << data.get_var_list();	cout << "Equation List:\n" << data.get_equation_list();}// Define overloaded output operator for calc_objectostream& operator<<(ostream& output_stream, calc_object a){	output_stream << "Calculator '" << a.identifier << "' contains:\n" << a.data;	return output_stream;}// Define methods for accessing public data members inside data field (calculator)complex calc_object::evaluate(string_class input_string){ return data.evaluate(input_string); }string_class calc_object::flush_errors(){ return data.flush_errors(); }ostream& calc_object::peek_errors(ostream& output_stream){ return data.peek_errors(output_stream); }int calc_object::get_number_of_errors(){ return data.get_number_of_errors(); }void calc_object::all_clear(){ data.all_clear(); }status calc_object::clear_single_memory(string_class name){ return data.clear_single_memory(name); }void calc_object::auto_verify_off(){ data.auto_verify_off(); }status calc_object::auto_verify_on(){ return data.auto_verify_on(); }void calc_object::set_validator(validator *checker){ data.set_validator(checker); }// Define undefined index as empty stringstring_class calc_object::undefined_index="";/*---------------------------------------------------------------------------------------  ---------------------------- End of calcobject.c++ ------------------------------------  ---------------------------------------------------------------------------------------*//************************************************************************************** * CODE FILE: rCalculatorClass.c++ * PURPOSE	: define members of calculator class **************************************************************************************/#include "rCalculatorClass.h"// Define default constructor (generates a SUPER_CALCULATOR)calculator::calculator(){	equation_checker=NULL;																	// Initialise validator pointer	var_list = new ulist<name_object>;											// Stores this calcs variables	equation_list = new ulist<name_object>;									// Stores this calcs equations	rank=SUPER_CALCULATOR;																	// Indicates top of hierarchy	binding_segment=0;																			// Parenthesis level 0	init_math_array();																			// Initialise mathfunc array	input_stream=NULL;																			// Initialise pointers	input_char_array=NULL;	error_stream=NULL;	error_string=NULL;	number_of_errors=NULL;	auto_verify=1;																					// Auto_verify on as default	new_error_stream();																			// Allocate new error stream}// Define copy constructor using overloaded = operatorcalculator::calculator(const calculator &original){ *this=original; }// Define overloaded = operator, allowing assignment between calculator objectscalculator& calculator::operator=(const calculator &original){	equation_checker=original.equation_checker;							// Use same equation checker	var_list = new ulist<name_object>;											// Allocate new lists	equation_list = new ulist<name_object>;	*var_list=*original.var_list;														// Make copy of lists	*equation_list=*original.equation_list;	rank=original.rank;																			// Duplicate other static data	binding_segment=original.binding_segment;	*number_of_errors=*original.number_of_errors;	current_symbol=original.current_symbol;	input_stream=NULL;									// Initialise input/error streams/strings in target	input_char_array=NULL;	error_stream=NULL;	error_string=NULL;		if (strcmp(original.error_string,"")!=0)	// Copy across errors stored in original calc	{		error_string=new char[calculator::ERROR_STREAM_SIZE];		error_stream=new ostrstream(error_string, calculator::ERROR_STREAM_SIZE-1);		(*error_stream) << original.error_string;									// Copy across error string	}	else																								// No errors present in source calc		new_error_stream();															// Allocate new error stream in target	auto_verify=original.auto_verify;									// Copy across auto_verify flag	return *this;}// Define method for deleting error stringstream and allocating new error stringstreamvoid calculator::new_error_stream(){	if (number_of_errors!=NULL)												// If number_of_errors is being used		delete number_of_errors;												// Delete current instance	number_of_errors=new int;													// Allocate new number_of_errors int	*number_of_errors=0;															// Initialise errors to 0	if (error_string!=NULL)																// If error_string is being used		delete[] error_string;															// Delete current instance	error_string=new char[calculator::ERROR_STREAM_SIZE];			// Allocate new error_string	error_string[0]='\0';																			// Initialise error_string	if (error_stream!=NULL)																// If error_stream is being used		delete error_stream;																// Delete current instance																												// Allocate new error_stream	error_stream=new ostrstream(error_string, calculator::ERROR_STREAM_SIZE-1);}// Define method to return current error_string and initialise errors to 0string_class calculator::flush_errors(){	if (rank==SUPER_CALCULATOR)	// Terminate error stream only if this is a super-calculator		(*error_stream) << '\0';																			// Add string terminator	string_class return_string=error_string;									// Backup current error_string	new_error_stream();																				// Re-initialise error_stream	return return_string;																			// Return error_string}// Define method to allow examination of errors without initialising errors to 0ostream& calculator::peek_errors(ostream& output_stream){	if (rank==SUPER_CALCULATOR)	// Terminate error stream only if this is a super-calculator	{		// Get current letter pointer (offset) of error_stream		long offset = (error_stream->rdbuf()->pubseekoff(0,ios::cur, ios::out)).offset();		// Copy all chars up to offset into a new string		if (offset>0)																			// If there are errors to return...		{			char errors[1000];															// Define temporary buffer			memcpy(errors, error_string, offset);						// Error_string not NULL terminated			errors[offset]='\0';														// Add terminating character			output_stream << errors;												// Output error string		}		else			output_stream << "0 errors";										// Output zero error string	}	return output_stream;}// Define PRIVATE constructor - can only be used by a SUPER CALCULATOR calculator object// All calculator objects generated in this way have SUB CALCULATOR rank.calculator::calculator(ulist<name_object> *v_list, ulist<name_object> *exp_list,											 ostrstream *errors, int *number_of_err){	equation_checker=NULL;									// No defining of eqns occurs in sub_calculators	var_list=v_list;												// Point to SUPER CALCULATOR variable list	equation_list=exp_list;									// Point to SUPER CALCULATOR equation list	rank=SUB_CALCULATOR;										// All of these are SUB CALCULATORS	binding_segment=0;											// Initialise parentheses level to 0	input_stream = NULL;										// Initialise input stream/string	input_char_array=NULL;	error_stream=errors;										// Write all errors to SUPER CALC error stream	number_of_errors=number_of_err;					// Inherit number of errors from SUPER CALC	error_string=NULL;											// No private error_string - ref SUPER CALC	auto_verify=0;													// No assigning of eqn can be done in SUB CALC}// Define method for initialising math func array - determine if it has been set alreadyvoid calculator::init_math_array(){	if (math_function_array_initialised==0)													// If not already set...	{		math_function_array_initialised=1;														// Flag as set		initialise_math_function_array();															// Call init array	}}// Define destructor functioncalculator::~calculator(){	if (rank==SUPER_CALCULATOR)	// Dynamic allocation of lists/streams occurs only in SUPER	{		delete var_list;														// Delete all previously allocated objects		delete equation_list;		delete[] error_string;		delete error_stream;		delete number_of_errors;	}	else	{		// No deleting to do as SUB CALCULATORS references dynamic objects in SUPER CALC		// which must stay in existence after all SUB CALCULATORS have deceased	}}// Define method for initialising input_stream to point to new input_stringstatus calculator::set_input(string_class input_string){	if (input_stream!=NULL)														// If input_stream already defined...		reset_input();																	// Deallocate current input stream	input_char_array=new char[input_string.length()+1];		// Allocate new input stream	input_string.string_copy(input_char_array);						// Make char array copy in string	input_stream = new istrstream(input_char_array);			// Input_stream acts on char array	return SUCCESS;}// Define method for initialising input_stream to point to NULL (ie stream unused)status calculator::reset_input(){	if (input_stream!=NULL)														// If input_stream already defined	{		delete input_stream;														// Deallocate and NULLify stream		input_stream=NULL;		delete[] input_char_array;											// Deallocate and NULLify char array		input_char_array=NULL;		return SUCCESS;	}	else																			// Can't reset a stream that is already reset	{		cout << "WARNING - trying to reset a non-set input stream\n";		return ERROR;	}}// Define method for evaluating the complex number result of expression in input_stringcomplex calculator::evaluate(string_class input_string){		set_input(input_string);										// Set input stream to process input_string	current_symbol.clear();											// Initialise current token symbol	complex complex_result;											// Used to hold complex result of evaluate	while (*input_stream)												// While end of input_stream not reached	{		get_token();															// Get the next token in input_stream		if (current_symbol.token == END)					// If token signifies END of stream, break			break;		if (current_symbol.token == PRINT)				// If token signifies PRINT, break			continue;		complex_result=level1();									// Call LEVEL1 func to evaluate input	}	// Evaluation of input_string complete...	if (*number_of_errors>0)										// If errors occurred output to cout...		cout << "Number_of_errors was " << (int) *number_of_errors << '\n';	reset_input();															// Reset the input_stream	return complex_result;											// Return complex result derived from input}// Define LEVEL1 precedence function, processes PLUS/MINUS tokenscomplex calculator::level1(){	complex left = level2();																			// Call LEVEL2 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case PLUS:																								// ADDITION found				if (get_token()==END)																		// Detect 'a+' error					return error("Incomplete binary operation");				left += level2();																				// Compute addition				break;																									// Break out of loop			case MINUS:																								// SUBTRACTION found				if (get_token()==END)																		// Detect 'a-' error					return error("Incomplete binary operation");									left -= level2();																				// Compute subtraction				break;																									// Break out of loop			default:													// This level does not process the current token				return left;		}}// Define LEVEL2 precedence function, processes MUL/DIV tokenscomplex calculator::level2(){	complex left = level3();																			// Call LEVEL3 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case MUL:																									// MULTIPLICATION found				if (get_token()==END)																		// Detect 'a*' error					return error("Incomplete binary operation");				left *= level3();																				// Compute multiplication				break;																									// Break out of loop			case DIV:																									// DIVISION found			{				if (get_token()==END)																		// Detect 'a/' error					return error("Incomplete binary operation");				complex divisor = level3();															// Read in divisor				if (invalid_operands(DIV, divisor))											// Check divisor					return error("divide by 0");				left = left / divisor;																	// Compute division				break;																									// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL3 precedence function, processes POW/ROOTX/LOGX tokenscomplex calculator::level3(){	complex left = level4();																			// Call LEVEL4 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case POW:																									// POWER found			{				if (get_token()==END)																		// Detect 'a^' error					return error("Incomplete binary operation");				complex exponent = level4();														// Read in exponent				if (invalid_operands(POW, left, exponent))							// Check exponent					return error("invalid POWER operands");				left = left^exponent;																		// Compute power result				break;																									// Break out of loop			}			case ROOTX:																								// Xth ROOT found			{				if (get_token()==END)																		// Detect 'a rootx' error					return error("Incomplete binary operation");				complex base = level3();												// Read in base from input				if (invalid_operands(ROOTX, left, base))				// Check base & left operand					return error("invalid ROOTX operands");				left = base^(complex (1/left.re, 0));						// Compute xth root result				break;																					// Break out of loop			}			case LOGX:			{				if (get_token()==END)														// Detect 'a logx' error					return error("Incomplete binary operation");				complex value = level3();												// Read in no. to take log of				if (invalid_operands(LOGX, left, value))				// Check both operands					return error("invalid LOGX operands");				left.re = logx(value.re, left.re);							// Compute Xth log				break;																					// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL4 precedence function, processes FACTORIAL tokencomplex calculator::level4(){	complex left = level5();																	// Call LEVEL5 evaluation	for (;;)																									// Loop forever		switch (current_symbol.token)		{			case FACTORIAL:																				// FACTORIAL found			{				get_token();																		// Skip over FACTORIAL symbol				if (invalid_operands(FACTORIAL, left))					// Check operand					return error("invalid FACTORIAL operand: non-integer / non-real");				left.re = factorial(left.re);										// Compute factorial				break;																					// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL5 precedence function, processes ENGINEERING SYMBOL tokenscomplex calculator::level5(){	complex left = primary();																	// Call PRIMARY evaluation	for (;;)																									// Loop forever		switch (current_symbol.token)		{			case MILLI:																						// ENG found			case MICRO:			case NANO:			case PICO:			case FEMTO:			case KILO:			case MEGA:			case GIGA:			case TERA:			case PETA:			case EXA:			{				token_value token_found=current_symbol.token;				// Store current token				get_token();																				// Skip over ENG symbol				left = engineering_conversion(token_found,left);		// Evaluate result				break;			}			default:				return left;		}}// Define PRIMARY precedence function, processes tokens with highest precedence, ie// numbers, names, unary minus, Parentheses, Modulus, Square Root, Cube Root, Trig Fns,// Compound fns etc. TOKENs processed : NUMBER, NAME, MINUS, LP, RP, LM, RM, SQRT, CBRT,// SIN, COS, TAN, ASIN, ACOS, ATAN, SINH, COSH, TANH, ASINH, ACOSH, ATANH, LN, LOG10,// LOG2, ARGUMENT, REAL, IMAGINARY, WINDOW, SUMMATION, PRODATION, ENDcomplex calculator::primary(){	// This function deals with unary operators, and all may form the start of an equation	switch (current_symbol.token)	{		case NUMBER:																							// Digit read in			get_token();																						// Get next token			if (current_symbol.token==NUMBER || current_symbol.token==NAME)	// Check errors				error ("Name/Number cannot proceed a Number\n");			return current_symbol.number_value;											// RETURN digit read in					case NAME:																								// Name read in		{				complex_container new_name;			complex temp_complex;			string_class temp_string;			complex_container temp_name;			int constant_found=0;													// Flag signifies NAME matches const			int variable_found=0;													// Flag signifies NAME matches var			int equation_found=0;													// Flag signifies NAME matches eqn			temp_string=current_symbol.name_string;				// Backup NAME read in			name_object temp_name_object(temp_string);		// Generate Name object holding NAME			status name_known;														// Flag signifies if NAME in a list						// ******** FIND OUT IF NAME REFERENCES AN ITEM STORED IN A CALCULATOR LIST ********			// First search the equation_list, then search the var_list, then			// search the constant_list for a match to NAME.			// If the search is successful, the corresponding data associated with NAME is			// loaded from the list node into the DATA field of temp_name_object.			if (equation_list->search_node(temp_name_object, COUNTER)==ERROR)		// NAME not eqn				if(var_list->search_node(temp_name_object, COUNTER)==ERROR)				// NAME not var				{					if (constant_list.search_node(temp_name_object, COUNTER)==ERROR)// NAMEnot const						name_known=ERROR;												// NAME not stored in this calculator					else					{						name_known=SUCCESS;											// NAME is a constant						constant_found=1;												// Flag CONSTANT found					}				}					else				{					name_known=SUCCESS;												// NAME is a variable					variable_found=1;													// Flag VARIABLE found				}			else			{				name_known=SUCCESS;													// NAME is an equation				equation_found=1;														// Flag EQUATION found			}						// ********* DETERMINE IF THIS IS AN ASSIGNMENT OR A REFERENCE TO NAME *************			switch(get_token())																				// Get next token on input			{				case NAME:																		// NAME/NUMBER cannot proceed a NAME				case NUMBER:					error ("Name/Number cannot proceed a Name\n");					return complex(0,0);												// RETURN null result					break;									case ASSIGN_CONSTANT:									// Treat NAME as VARIABLE, and do assignment				{					if (equation_found==1)									// If name already used for equation...					{						error ("Illegal Assignment to equation name\n");						return complex(0,0);									// RETURN null result					}					if (constant_found==1)									// If name already used for constant...					{						error ("Illegal Assignment to Constant");						return complex(0,0);									// RETURN null result					}										get_token();																					// Get next token on input					int old_errors=*number_of_errors;								// Backup number_of_errors value					temp_complex=level1();											// Get right hand side of assignment					if (*number_of_errors==old_errors)			// If no errors on right-side of assign					{																				// add NAME assignment to var list...						temp_name_object.set_indicator(CONSTANT);				// Storing a constant number						temp_name_object.set_complex(temp_complex);			// Set complex number field						// NOTE: if NAME already appears on var list, the complex number associated						// with it will be updated appropriately. One name_object on ulist will have						// NAME identifier after this function call.						var_list->maintain(temp_name_object, COUNTER, ASCENDING);	// Add to list					}					else																				// ERRORS found on RHS of assignment						error ("Right hand side of assignment is faulty");					return temp_complex;												// Return right hand side of assign					break;				}									case DEFINE_EQUATION:									// Treat NAME as EQUATION, and do assignment				{					if (variable_found==1)									// If name already used for variable...					{						error ("Illegal tagging of variable name to equation\n");						return complex(0,0);									// RETURN null result					}					if (constant_found==1)									// If name already used for constant...					{						error ("Illegal tagging of constant to definition");						return complex(0,0);									// RETURN null result					}										// Get remainder of input as string and store in definition_string...					string_class definition_string=get_definition();					temp_name_object.set_indicator(EQUATION);					// Storing an equation string 					temp_name_object.set_equation(definition_string);						// Set string field					equation_list->maintain(temp_name_object, COUNTER, ASCENDING);	// Add to list					// NOTE: if NAME already appears on eqn list, the string associated					// with it will be updated appropriately. One name_object on ulist will have					// NAME identifier after this function call.					// If the new equation causes a circular definition and auto_verify is on,					/// remove it from eqn list...					if (auto_verify==1 && equation_checker!=NULL &&							equation_checker->validate(this)==ERROR)					{						equation_list->remove(temp_name_object, COUNTER);					// Remove NAME node						string_class err("Circular equation not stored - error trace '");						err=err+equation_checker->error_trace+"'\n";					// Return error trace						error(err);																						// Report error message					}					return complex (0,0);																		// Return NULL result					break;				}								default:									// NAME is being used as a REFERENCE - look up its value				{						if (name_known==ERROR)							// NAME not present in const/var/eqn list...					{						char error_string[100]="'";						temp_string.string_copy(error_string+1);						strcat(error_string, "'  Name not found");						error (error_string);																		// Report error						return complex (0,0);																		// Return NULL result					}					else																// NAME present in const/var/eqn list					{						switch (temp_name_object.get_indicator())		// Find out if var/eqn						{							case CONSTANT:													// NAME is a constant complex number								return temp_name_object.get_complex();				// Return associated number							case EQUATION:											// NAME is references an equation string							{								string_class equation(temp_name_object.get_equation());	// Get eqn string								// Next, we need a new calculator to do the evaluation								{									complex sub_output;							// Store evaluation from sub_calculator									// Create new calculator to evaluate equation string, pass references									// to var/eqn lists and error stream/string.									calculator *sub_calculator=new calculator(var_list, equation_list,																												 error_stream, number_of_errors);									sub_output=sub_calculator->evaluate(equation);	// Evaluate eqn string									delete sub_calculator;													// Delete sub_calc.									return sub_output;						// RETURN evaluation result from sub calc								}								break;							}							default:								return error ("Illegal enumeration value for macro_indicator");						}					}					break;				}			}		}		// NOTE: at this point current_symbol.token has been set to the next symbol because		// of the get_token() call in the previous switch statement.		case MINUS:																										// Unary MINUS read in			get_token();																								// Get next token			return -primary();											// Calculate next operand and take negative					case LP:																									// Left parenthesis read in		{			binding_segment++;																		// Increase parenthesis level			get_token();																					// Get next token from input			complex expression_value = level1();									// Evaluate up to Right Paren.			if (current_symbol.token != RP)												// If No Right Parenthesis...			{				binding_segment=0;																	// Reset parenthesis level				return error(") expected");													// RETURN ERROR			}			get_token();																					// Get next token from input			binding_segment--;																		// Decrease parenthesis level			return expression_value;								// RETURN complex number inside parentheses		}		case LM:																							// Left Modulus operator read in 		{			binding_segment++;																	// Increase parenthesis level			get_token();																				// Get next token from input			complex expression_value = level1();								// Evaluate up to right modulus			if (current_symbol.token != RM)											// If No right modulus...			{				binding_segment=0;																// Reset parenthesis level				return error("] expected");												// RETURN ERROR			}			get_token();																				// Get next token from input			binding_segment--;																	// Decrement parenthesis level			// Take complex modulus of expression inside modulus brackets			expression_value.set(magnitude(expression_value),0);			return expression_value;														// Return modulus value		}				case SQRT:																							// Square Root token read in		{			get_token();																					// Get first token of operand			complex equation = level3();													// Evaluate operand			if (invalid_operands(SQRT, equation))									// Check for invalid operand				return error("invalid SQRT");												// RETURN error			return sqrt_comp(equation);														// Return complex square root.		}		case CBRT:																							// Cube Root token read in		{			get_token();																					// Get first token of operand			complex equation = level3();													// Evaluate operand			if (invalid_operands(CBRT, equation))									// Check for invalid operand				return error("invalid CBRT");												// RETURN error			return cbrt(equation);																// Return complex cube root.		}				case SIN:																								// Trig function token read in		case COS:		case TAN:		case ASIN:		case ACOS:		case ATAN:		case SINH:		case COSH:		case TANH:		case ASINH:		case ACOSH:		case ATANH:		case LN:		case LOG10:		case LOG2:		{			token_value math_fn_requested=current_symbol.token;		// Backup trig token read in			get_token();																					// Get first token of operand			complex math_func_parameter = level3();								// Evaluate operand			if (invalid_operands(math_fn_requested, math_func_parameter))	// Check operand				return error("invalid SQRT/CBRT/SIN/COS/TAN/SINH/COSH/TANH/ASIN/ACOS/ATAN/ASINH/ACOSH/ATANH/LN/LOG10/LOG2 operand");			// Use math_func look up table of math function pointers to call correct math			// function, and evaluate result of applying operand to that function.			return complex ( (*(math_func[(unsigned char)math_fn_requested]))												 (math_func_parameter.re), 0);		}				case ARGUMENT:																			// Complex argument token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaluate operand			return complex (arg(complex_number),0);						// Calculate and return argument		}				case REAL:																					// Real token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaulate operand			return complex (complex_number.re,0);							// Return real part of operand		}		case IMAGINARY:																			// Imag token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaluate operand			return complex (complex_number.im,0);							// Return imag part of operand		}				case WINDOW:																				// Window function token read in		{			double lower_bound, upper_bound;									// Used to store window limits			string_class variable;														// Variable name to window			// Get window parameters from input, if error occurs then return NULL result			if (get_window_parameters(variable, lower_bound, upper_bound)==ERROR)				return complex (0,0);			current_symbol.token=NAME;											// Prime current_symbol.token			current_symbol.name_string=variable;						// Prime current_symbol.name_string			complex complex_number=primary();								// Evaluate value of NAME			// If result is within bound, then return real part of result...			if (complex_number.re>=lower_bound && complex_number.re<=upper_bound)				return complex (1, 0);			else 				return complex (0,0);				// otherwise result is outside window - return 0		}				case SUMMATION:																						// Summation token read in			return compound(PLUS);																	// Return summation result.		case PRODATION:																						// Prodation token read in.			return compound(MUL);																		// Return prodation result.		case END:																									// END of input token read.			return complex (0,0);																		// RETURN null result		default:																									// No primary token found			return error("primary expected");												// Report error	}}// Define method which reads characters from input_stream, and interprets these as// tokens - storing approriate token name in current_symbol.token_value calculator::get_token(){	char input_char;	// Read token from input stream.	do	{		if ( !(*input_stream).get(input_char)) 											// End of input reached...		{			// permitted tokens  at this point are: (all tokens in terminator tokens table)			if (binding_segment<=0 &&												// Look up token in terminator table					terminator_table[(unsigned char)current_symbol.token]!='!')				error ("Illegal Terminating Token\n");			return current_symbol.token = END;		}	}	while (input_char != '\n' && isspace(input_char));				// Skip white space except \n		switch (input_char)													// Input char holds the single token read in	{		case ';':		case '\n':			return current_symbol.token=PRINT;										// Indicates end of equation		case '!':		// Factorial		case '^':		// Power		case '@':		// Square Root		case '':		// Cube Root		case '$':		// Xth Root		case '':		// Sine		case '':		// Cosine		case '#':		// Tangent		case '~':		// Hyperbolic Sine		case '':		// Hyperbolic Cosine		case '':		// Hyberbolic Tangent		case '':		// ArcSine		case '':		// ArcCosine		case '':		// ArcTangent		case '':		// Hyperbolic ArcSine		case '':		// Hyperbolic ArcCosine		case '':		// Hyberbolic ArcTangent		case '':		// Natural Logarithm		case '':		// Logarithm to Base 10		case '':		// Logarithm to Base 2		case '':		// Logarithm to any Base		case '':		// Complex argument		case '*':		// Multiply		case '/':		// Divide		case '+':		// Add		case '-':		// Minus		case '(':		// Left Parenthesis		case ')':		// Right Parenthesis		case '[':		// Modulus start		case ']':		// Modulus end		case '=':		// Assign constant		case ':':		// Define equation		case '':		// MILLI		case '':		// MICRO		case '':		// NANO		case '':		// PICO		case '':		// FEMTO		case '':		// KILO		case '':		// MEGA		case '':		// GIGA		case '':		// TERA		case '':		// PETA		case '':		// EXA		case '':		// SUMMATION		case '':		// PRODATION		case ',':		// COMMA operator (used in summation/prodation)		case '':		// REAL		case '':		// IMAGINARY		case '':		// WINDOW			return current_symbol.token=token_value(input_char);// store token and return symbol					case '0': case '1': case '2': case '3': case '4': 		// Digit/Decimal point read in		case '5': case '6': case '7': case '8': case '9':		case '.':		{			(*input_stream).putback(input_char);								// Putback last char to stream			(*input_stream) >> current_symbol.number_value.re;	// Read whole number as a double			return current_symbol.token=NUMBER;									// Return NUMBER		}		default:			if (isalpha(input_char))														// NAME is being read in			{				string_class temp;				*input_stream->putback(input_char);								// Putback last char to stream				*input_stream >> current_symbol.name_string;			// Read string from stream 				return current_symbol.token=NAME;									// Return NAME			}			error ("bad token");																// Undefined token read in			return current_symbol.token=PRINT;									// RETURN NULL result	}}// Define method for reading in parameters for SUMMATION/PRODATION from input_streamstatus calculator::get_compound_parameters(token_value method, string_class &variable,																					 int &lower_bound, int &upper_bound){	lower_bound=0;	string_class error_string;												// Holds errors occurring in this fn.	switch (method)	{		case PLUS:			error_string="SUMMATION: ";										// SUMMATION parameters to be read			lower_bound=0;																// Define lower bound for variable			break;		case MUL:			error_string="PRODATION: ";										// PRODATION parameters to be read			lower_bound=1;																// Define lower bound for variable			break;		default:			error ("Illegal Compound method");			return ERROR;			break;	}	// 1)	read in- '(' '<variable_name>' ',' '<upperbound>' ')'	get_token();	if (current_symbol.token==LP)													// If Left Parenthesis read in	{		get_token();																				// Get next token		if (current_symbol.token==NAME)											// If variable name read in		{			variable=current_symbol.name_string;							// Backup variable name			get_token();			if (current_symbol.token==COMMA)									// If comma read in			{				get_token();				upper_bound=level1().re;							// Read in upper_bound - keep real component				// Note a get_token operation has been done by level1()				if (current_symbol.token!=RP)										// If Right Parenthesis not read				{	// Then lower bound & upper bound specified, requires COMMA followed by NUMBER					if (current_symbol.token==COMMA)							// If COMMA read in					{						get_token();						lower_bound=upper_bound;								// Accept first NUMBER as lower_bound						upper_bound=level1().re;			// Read in new upper_bound - keep real component						// note a get_token operation has been done by level1()						if (current_symbol.token!=RP)								// If no Right Parenthesis read in						{							error (error_string+"illegal syntax - right parenthesis absent");							return ERROR;						}						else						{							if (lower_bound>upper_bound)									// If bounds badly ordered...							{								error (error_string+"illegal bounds - lower_bound>upper_bound");								return ERROR;							}							else											// Both lower and upper bounds have been specified							{								// All summation/prodation parameters stored and validated								return SUCCESS;							}						}					}					else																								// COMMA missing from input					{						error (error_string+"illegal syntax - comma absent/right parenthesis absent");						return ERROR;					}				}									else																				// Only upper bound has been specified				{						// All parameters read in ok					if (lower_bound>upper_bound)											// If bounds badly ordered...					{						error (error_string+"illegal bounds - lower_bound>upper_bound");						return ERROR;					}					else					{						// All summation/prodation parameters stored and validated						return SUCCESS;					}				}			}			else																									// COMMA missing from input			{				error (error_string+"illegal syntax - comma absent");				return ERROR;			}		}		else																										// Variable name missing		{			error (error_string+"illegal syntax - variable name absent");			return ERROR;		}	}	else																											// Left Parenthesis missing	{		error (error_string+"illegal syntax - left parenthesis absent");		return ERROR;	}}// Define method for reading in parameters for window operation from input_streamstatus calculator::get_window_parameters(string_class &variable, double &lower_bound,																				 double &upper_bound){	lower_bound=0;	upper_bound=0;	string_class error_string;	get_token();	if (current_symbol.token==LP)														// If Left Parenthesis read in	{		get_token();																					// Get next token		if (current_symbol.token==NAME)												// If variable name read in		{			variable=current_symbol.name_string;								// Backup variable name			get_token();			if (current_symbol.token==COMMA)										// If comma read in			{				get_token();				lower_bound=level1().re;							// Read in lower_bound - keep real component				if (current_symbol.token==COMMA)									// If COMMA read in				{					get_token();					upper_bound=level1().re;				// Read in new upper_bound - keep real component					// Note a get_token operation has been done by level1()					if (current_symbol.token!=RP)										// If right parenthesis not read					{						error (error_string+"illegal syntax - right parenthesis absent");						return ERROR;					}					else					{						if (lower_bound>upper_bound)										// If bounds badly ordered...						{							error (error_string+"illegal bounds - lower_bound>upper_bound");							return ERROR;						}						else						{							// All window parameters stored and validated							return SUCCESS;						}					}				}				else																									// COMMA missing from input				{					error (error_string+"illegal syntax - comma absent absent");					return ERROR;				}							}			else																										// COMMA missing from input			{				error (error_string+"illegal syntax - comma absent absent");				return ERROR;			}		}						else																											// Variable name missing		{			error (error_string+"illegal syntax - variable name absent");			return ERROR;		}	}	else																												// Left Parenthesis missing	{		error (error_string+"illegal syntax - left parenthesis absent");		return ERROR;	}}// Define method for calculating SUMMATION/PRODATION of expression, with one variable// ranged between a lower and upper bound.complex calculator::compound(token_value method){	string_class variable, error_string;	int lower_bound;	int upper_bound;	complex total;	// Retrieve parameters from input_stream.	if (get_compound_parameters(method, variable, lower_bound, upper_bound)==ERROR)		return complex (0,0);																						// RETURN NULL result	switch (method)																					// Initialise accumulated total	{		case PLUS:																						// SUMMATION requires 0 start			total=complex(0,0);			break;		case MUL:																							// PRODATION requires 1 start			total=complex(1,0);			break;		default:			error ("Illegal Compound method");			return complex (0,0);			break;	}	// 1) Make sure the variable name specified is not an equation name	if (equation_list->search_node(name_object(variable), COUNTER)==SUCCESS)	{		error ("Illegal compound function variable name - clashes with valid equation name");		return complex(0,0);																						// RETURN NULL result	}		// 2)	Record current offset position in input_array so that we may return here again,	//    for multiple evaluations.	long offset = (input_stream->rdbuf()->pubseekoff(0,ios::cur, ios::in)).offset();	char *expression_start=input_char_array+offset;		// Set pointer to start of expression	name_object temp_name_object=name_object(variable);		// 3) Now carry out required number of calculations, adjusting 'variable' value	//    appropriately before each loop. After each evaluation must make a new input_stream	//    pointing to character at expression_start.	for (int i=lower_bound; i<=upper_bound; i++)	{		get_token();																				// Get next token		temp_name_object.set_complex(complex(i,0));					// Variable set for this iteration		var_list->maintain(temp_name_object, COUNTER, ASCENDING);			// Update variable list		switch (method)		{			case PLUS:																									// Do a SUMMATION				total=total+level2();																			// SUM result to total				break;			case MUL:																										// Do a PRODATION				total=total*level2();																			// TIMES result to total				break;			default:				break;		}		if (i!=upper_bound)													// If FOR not finishing, need a new stream		{			delete input_stream;			// Make new stream pointing to expression_start			input_stream = new istrstream(expression_start);		}	}	return total;																			// Return total of SUMMATION/PRODATION}// Define method for storing remainder of input_stream into a string.string_class calculator::get_definition(){		string_class definition_string;	char input_char;	do	{		if (!(*input_stream).get(input_char))					// Break if end of input_stream reached			break;		definition_string=definition_string+input_char;		// Append char to definition_string	}	while (input_char!=(char)END && input_char!=(char)PRINT); // Continue until end reached	return definition_string;																		// RETURN the string}// Define method for initialising math_func look-up table with math function pointers// and terminator table with terminator tokens.void calculator::initialise_math_function_array(){	math_func[(unsigned char)SIN]=&sin;	math_func[(unsigned char)COS]=&cos;	math_func[(unsigned char)TAN]=&tan;	math_func[(unsigned char)ASIN]=&asin;	math_func[(unsigned char)ACOS]=&acos;	math_func[(unsigned char)ATAN]=&atan;	math_func[(unsigned char)SINH]=&sinh;	math_func[(unsigned char)COSH]=&cosh;	math_func[(unsigned char)TANH]=&tanh;	math_func[(unsigned char)ASINH]=&asinh;	math_func[(unsigned char)ACOSH]=&acosh;	math_func[(unsigned char)ATANH]=&atanh;	math_func[(unsigned char)LN]=&log;	math_func[(unsigned char)LOG10]=&log10;	math_func[(unsigned char)LOG2]=&log2;	for (int i=0; i<15; i++)		terminator_table[(unsigned char)terminator_tokens[i]]='!';}// Define method for applying engineering conversion to complex number.complex calculator::engineering_conversion(const token_value token, const complex x){	int multiplier=0;	switch (token)	{		case MILLI:			multiplier=-3;																// x10^-3			break;		case MICRO:			multiplier=-6;																// x10^-6			break;		case NANO:			multiplier=-9;																// x10^-9			break;		case PICO:			multiplier=-12;																// x10^-12			break;		case FEMTO:			multiplier=-15;																// x10^-15			break;		case KILO:			multiplier=3;																	// x10^-3			break;		case MEGA:			multiplier=6;																	// x10^6			break;		case GIGA:			multiplier=9;																	// x10^9			break;		case TERA:			multiplier=12;																// x10^12			break;		case PETA:			multiplier=15;																// x10^15			break;		case EXA:			multiplier=18;																// x10^18			break;		default:			return error("Unsuitable token passed to engineering conversion");	}	// Multiply complex number x by appropriate power of 10	return complex ((x.re*pow(10,multiplier)), (x.im*pow(10,multiplier)));}// Define method for determining if operands are invalid for particular tokens.int calculator::invalid_operands(const token_value token, const complex value1,																 const complex value2){	// Functions which can accept complex numbers (.im!=0)	switch (token)	{		case DIV:																			// DIVISION:			return (value1.re==0 && value1.im==0);			// prevent (a+bj)/(0+0j)		case POW:																			// POWER:			return (value1.re==0 && value1.im==0 && value2.re==0 || // prevent (0+0j)^0						 (value1.re!=exp(1) && value2.im!=0));			  // prevent a^(a+bj) iff a!=exp		case SQRT:																		// SQUARE ROOT		case CBRT:																		// CUBE ROOT			return 0;																		// No restrictions		case ROOTX:																		// Xth root			return (value1.re==0);											// Prevent 0th root					default:											// Check that complex number not being given to fn below			if (value1.im!=0 || value2.im!=0)				return 1;																			// ERROR complex number being used	}		// Functions which cannot accept complex numbers (.im==0)	switch (token)	{		case FACTORIAL:			return value1.re!=(int)value1.re || value1.re<0;				// Must be non-negative int		case TAN:			return !(fmod(value1.re,pi/2) != 0.0);									// Prevent tan 90, etc		case ASIN:		case ACOS:			return !(value1.re>=-1 && value1.re<=1);								// Must be in -1 -> 1		case ACOSH:			return !(value1.re>=1);																	// Must be >=1		case ATANH:			return !(value1.re>-1 && value1.re<1);									// Must be in -1 -> 1		case LN:																									// Natural Log		case LOG10:																								// Base 10 Log		case LOG2:																								// Base 2 Log			return !(value1.re>0);																	// Must be >0		case LOGX:																								// Base X Log			return !(value1.re>0 && value2.re>0);										// Both operands >0		default:			return 0;							// No checking required for other tokens, always return valid	}}// Define method for accessing equation list pointer (only used by preprocessor)ulist<name_object>* calculator::get_equation_list(){ return equation_list; }// Define method for accessing variable list pointer (only used by preprocessor)ulist<name_object>* calculator::get_var_list(){	return var_list; }// Define method for accepting an array of constants, and using this data to produce a// generic constant list for all calculatorsvoid calculator::build_internal_constants(const name_object *const_array,																					const int length){	ulist<name_object> build_list;		for (int i=0; i<length; i++)					// Add name objects to constant list in name order		build_list.add(const_array[i], COUNTER, ASCENDING);	calculator::constant_list=build_list;							// Copy list into static storage space}// Define method for internal error recording - accepts char arraycomplex calculator::error(const char* s){	(*error_stream) << "error: " << s << '\n';			// Output error message to error_stream	(*number_of_errors)++;													// Increment int number of errors	return complex (0,0);														// Return NULL result}// Define method for internal error recording - accepts string_classcomplex calculator::error(const string_class s){	(*error_stream) << "error: " << s << '\n';			// Output error message to error_stream	(*number_of_errors)++;													// Increment int number of errors	return complex (0,0);														// Return NULL result}// Define method for clearing both variable and equation list of calculator to empty statevoid calculator::all_clear(){	var_list->clearlist();	equation_list->clearlist();}// Define method for clearing a single variable/equation in this calc specified by namestatus calculator::clear_single_memory(string_class name){	if (var_list->remove(name,COUNTER)==ERROR)				// Removal from variable list fails...		return (equation_list->remove(name,COUNTER));		// Attempt removal from eqn list	else		return SUCCESS;																	// Removed successfully from var list}// Define method for outputting contents of calculator - overloaded output operatorostream& operator<<(ostream& output_stream, calculator a){		output_stream << "Variable List:\n ";							// Output variable list...	output_stream << *(a.var_list);	output_stream << "EQUATION List:\n ";							// Followed by the equation list...	output_stream << *(a.get_equation_list());	return output_stream;}// Define method for finding out how many errors have occurred since the last time// flush_errors was called (or if flush_errors has never been called, since this calc// object had been instantiated)int calculator::get_number_of_errors(){ return *number_of_errors; }// Define method for turning auto verification of equations off.void calculator::auto_verify_off(){ auto_verify=0; }// Define method for turning auto verification of equations on.// Verify is then done on all equations every time a new equation is defined.status calculator::auto_verify_on(){	// Check first to make sure there are no circular definitions currently in calculator	if (equation_checker->validate(this)==ERROR)		return ERROR;	else	{		auto_verify=1;		return SUCCESS;	}}// Define method for setting the validator which this calculator and all its SUB// CALCULATORS will use for validating/verifying equations for circular definitions.void calculator::set_validator(validator *checker){ equation_checker=checker; }// Rest of file consists of all static member data required by the calculator classint calculator::math_function_array_initialised=0;char calculator::terminator_table[256];double (*calculator::math_func[256])(double);ulist<name_object> calculator::constant_list;int calculator::ERROR_STREAM_SIZE=1000;// This array defines all those tokens which may terminate an expressionconst token_value calculator::terminator_tokens[15]={token_value(NUMBER),token_value(NAME),token_value(FACTORIAL),token_value(PRINT),token_value(MILLI),token_value(MICRO),token_value(NANO),token_value(PICO),token_value(FEMTO),token_value(KILO),token_value(MEGA),token_value(GIGA),token_value(TERA),token_value(PETA),token_value(EXA)};// This array maps an OPERATION string to a single character calculator symbol.const token_name calculator::token_names[50]={token_name ("PLUS",'+'),token_name ("MINUS", '-'),token_name ("MULTIPLY", '*'),token_name ("DIVIDE", '/'),token_name ("POWER",'^'),token_name ("FACTORIAL", '!'),token_name ("SQUARE_ROOT", '@'),token_name ("CUBE_ROOT", ''),token_name ("ROOTX", '$'),token_name ("SINE",''),token_name ("COSINE", ''),token_name ("TANGENT",'#'),token_name ("ARCSINE", ''),token_name ("ARCCOSINE", ''),token_name ("ARCTANGENT", ''),token_name ("SINE-H", '~'),token_name ("COSINE-H", ''),token_name ("TANGENT-H",''),token_name ("ARCSINE-H",''),token_name ("ARCCOSINE-H", ''),token_name ("ARCTANGENT-H", ''),token_name ("NATURAL_LOG", ''),token_name ("LOG10", ''),token_name ("LOG2", ''),token_name ("LOGX", ''),token_name ("PRINT", ';'),token_name ("ASSIGN_CONSTANT",'='),token_name ("LEFT_BRACKET",'('),token_name ("RIGHT_BRACKET", ')'),token_name ("LEFT_MODULUS",'['),token_name ("RIGHT_MODULUS", ']'),token_name ("ARGUMENT",''),token_name ("MILLI",''),token_name ("MICRO",''),token_name ("NANO",''),token_name ("PICO",''),token_name ("FEMTO",''),token_name ("KILO", ''),token_name ("MEGA", ''),token_name ("GIGA",''),token_name ("TERA",''),token_name ("PETA", ''),token_name ("EXA",''),token_name ("DEFINE_EQUATION",':'),token_name ("SUMMATION", ''),token_name ("PRODATION", ''),token_name ("COMMA", ','),token_name ("REAL", ''),token_name ("IMAGINARY", ''),token_name ("WINDOW",'')};/*---------------------------------------------------------------------------------------  ---------------------------- End of rCalculatorClass.c++ ------------------------------  ---------------------------------------------------------------------------------------*/