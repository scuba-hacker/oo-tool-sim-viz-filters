#include "graphObject.h"graph::graph(port_info newport, border_info newborder, scale_info newhoriz_scale, scale_info newvert_scale,	range_info newhoriz_range,  range_info newvert_range, tick_info newticks){	mainPtr=NULL;	set_port(newport);				// initialise bounds	set_border(newborder);			// initialise bounds	horiz_scale=newhoriz_scale;	vert_scale=newvert_scale;	horiz_range=newhoriz_range;	vert_range=newvert_range;	ticks=newticks;		scaleSize=10;}void graph::showGraph(){	SetPort(mainPtr);	ShowWindow(mainPtr);	SelectWindow(mainPtr);}void graph::hideGraph(){	HideWindow(mainPtr);}void graph::clear_window(){	SetPort(mainPtr);	EraseRect(&windRect);}void graph::blank_graph(){	clear_window();	SetPort(mainPtr);	vertical_ticks();	horizontal_ticks();	draw_axes();}void graph::translate_to_grafport(double &x, double &y){	x=bound.left+(x-horiz_range.Min)*bound.width/horiz_range.range();	y=bound.bottom-(y-vert_range.Min)*bound.height/vert_range.range();}double graph::translate_x(double x){	return bound.left+(x-horiz_range.Min)*bound.width/horiz_range.range();}double graph::translate_y(double y){	return bound.bottom-(y-vert_range.Min)*bound.height/vert_range.range();}void graph::draw_x_line(double x, long int brightness){		RGBColor grey;	RGBColor current;	grey.red=grey.green=grey.blue=brightness;	GetForeColor(&current);	RGBForeColor(&grey);	PenPat(&qd.gray);	MoveTo(translate_x(x),bound.bottom);	LineTo(translate_x(x),bound.top);	RGBForeColor(&current);	PenPat(&qd.black);}void graph::draw_y_line(double y, long int brightness){	RGBColor grey;	RGBColor current;	grey.red=grey.green=grey.blue=brightness;	GetForeColor(&current);	RGBForeColor(&grey);	PenPat(&qd.gray);	MoveTo(bound.left,translate_y(y));	LineTo(bound.right,translate_y(y));	RGBForeColor(&current);	PenPat(&qd.black);}void graph::draw_axes(){	RGBColor grey;	grey.red=60000;	grey.green=40000;	grey.blue=70000;		ForeColor(redColor);	// x-axis always along bot	MoveTo(bound.left, bound.bottom);	LineTo(bound.right, bound.bottom);		// 	y-axis always along left	MoveTo(bound.left, bound.bottom);	LineTo(bound.left, bound.top);		RGBForeColor(&grey);	PenPat(&qd.gray);	// is 0 in the range of y?	if (vert_range.Max>0 && vert_range.Min<0)	{		// line for y=0		double y=translate_y(0);		MoveTo(bound.left,y);		LineTo(bound.right,y);	}	if (horiz_range.Max>0 && horiz_range.Min<0)	{		// line for x=0		double x=translate_x(0);		MoveTo(x, bound.bottom);		LineTo(x, bound.top);	}	ForeColor(blackColor);	PenPat(&qd.black);}void graph::vertical_ticks(){	ForeColor(redColor);	TextSize(scaleSize);	double y=bound.bottom;	double y_incrementer=((vert_scale.MajScale/vert_range.range())/(vert_scale.MinTicks+1))*bound.height;	int count=vert_scale.MinTicks;	double y_val=vert_range.Min;	char y_val_string[20];	do	{		MoveTo(bound.left,y);		LineTo(bound.left-ticks.MajTickSize, y);		Move(-25,scaleSize/2);		sprintf(y_val_string,"%.1f",y_val);		ForeColor(blackColor);		DrawString(c2pstr(y_val_string));		ForeColor(redColor);		if (y<=bound.top+y_incrementer*vert_scale.MinTicks)		{			draw_y_line(y_val, 40000);		// put in major tick line			break;		}		do		{			y-=y_incrementer;			MoveTo(bound.left,y);			LineTo(bound.left-ticks.MinTickSize, y);			draw_y_line(y_val+(count)*vert_scale.MajScale/(vert_scale.MinTicks+1), 55000);		}		while(count--);		count=vert_scale.MinTicks;		draw_y_line(y_val, 40000);		y_val+=vert_scale.MajScale;	}	while(1);	ForeColor(blackColor);}void graph::horizontal_ticks(){	ForeColor(redColor);	TextSize(scaleSize);		double x=bound.left;	double x_incrementer=((horiz_scale.MajScale/horiz_range.range())/(horiz_scale.MinTicks+1))*bound.width;	int count=horiz_scale.MinTicks;	double x_val=horiz_range.Min;	char x_val_string[20];	do	{		MoveTo(x, bound.bottom);		LineTo(x, bound.bottom+ticks.MajTickSize);		Move(-scaleSize,ticks.MajTickSize+scaleSize/2);		sprintf(x_val_string,"%.1f",x_val);		ForeColor(blackColor);		DrawString(c2pstr(x_val_string));		ForeColor(redColor);		if (x>=bound.right-x_incrementer*horiz_scale.MinTicks)		{			draw_x_line(x_val,40000);			break;		}		do		{			x+=x_incrementer;			MoveTo(x, bound.bottom);			LineTo(x, bound.bottom+ticks.MinTickSize);			draw_x_line(x_val+count*horiz_scale.MajScale/(horiz_scale.MinTicks+1), 55000);		}		while(count--);		count=horiz_scale.MinTicks;		draw_x_line(x_val,40000);		x_val+=horiz_scale.MajScale;	}	while(1);		ForeColor(blackColor);}void graph::PlaceCross(int Width){	RGBColor current;	GetForeColor(&current);		ForeColor(greenColor);		Move(-Width/2,-Width/2);	Line(Width, Width);	Move(-Width, 0);	Line(Width, -Width);		Move(-Width/2, Width/2);		RGBForeColor(&current);}void graph::set_port(port_info newport){	port=newport;	if (mainPtr!=NULL)		CloseWindow(mainPtr);	SetRect(&windRect, port.top,port.left, port.top+port.width, port.left+port.height);	mainPtr = NewCWindow(nil, &windRect, "\pMark's Land", true, documentProc, 				(WindowPtr) -1, false, 0);	// recalculate affected bounds	bound.right=port.width-border.right;	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}void graph::set_border(border_info newborder){	border=newborder;	// recalculate all bounds	bound.top=border.top;	bound.left=border.left;	bound.right=port.width-border.right;	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}void graph::set_horiz_scales(scale_info newhoriz_scale){	horiz_scale=newhoriz_scale;}void graph::set_vert_scales(scale_info newvert_scale){	vert_scale=newvert_scale;}void graph::set_horiz_range(range_info newhoriz_range){	horiz_range=newhoriz_range;}void graph::set_vert_range(range_info newvert_range){	vert_range=newvert_range;}void graph::set_ticks(tick_info newticks){	ticks=newticks;}