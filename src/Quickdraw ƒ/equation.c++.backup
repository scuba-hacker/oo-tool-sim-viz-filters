#include <Types.h>#include <Memory.h>#include <Quickdraw.h>#include <Fonts.h>#include <Events.h>#include <Menus.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <OSUtils.h>#include <ToolUtils.h>#include <SegLoad.h>#include <iostream.h>#include <SIOUX.h>#include <stdio.h>#include <string.h>#include <math.h>const double PI=asin(1)*2;const int portTop=50;const int portLeft=50;const int portWidth=500;const int portHeight=500;const double topBorder=50;const double botBorder=20;const double leftBorder=30;const double rightBorder=10;const double HorizMajScale=PI/4;const double HorizMinTicks=5;const double VertMajScale=1;const double VertMinTicks=5;const double MajTickSize=5;const double MinTickSize=2;const double HorizMax=2*PI;const double HorizMin=-0;const double VertMax=3;const double VertMin=-3;const double HorizRange=HorizMax-HorizMin;const double VertRange=VertMax-VertMin;// These dictate the area within the window the graph can occupy - set to 10 pixel borderconst double boundTop=topBorder;const double boundLeft=leftBorder;const double boundRight=portWidth-rightBorder;const double boundBot=portHeight-botBorder;const double boundWidth=boundRight-boundLeft;const double boundHeight=boundBot-boundTop;const int scaleSize=10;/* Globals */Rect	windRect;	/* Prototypes */void Initialize(void);void plot(long int x, long int y);void draw_axes();void vertical_ticks();void translate_to_grafport(double &x, double &y);double translate_x(double x);double translate_y(double y);WindowPtr mainPtr;void translate_to_grafport(double &x, double &y){	x=boundLeft+(x-HorizMin)*boundWidth/HorizRange;	y=boundBot-(y-VertMin)*boundHeight/VertRange;}double translate_x(double x){	return boundLeft+(x-HorizMin)*boundWidth/HorizRange;}double translate_y(double y){	return boundBot-(y-VertMin)*boundHeight/VertRange;}// note using 55000 for RGB for maj ticks// use 65000 for RGB for min ticksvoid draw_x_line(double x, long int brightness){		RGBColor grey;	RGBColor current;	grey.red=grey.green=grey.blue=brightness;	GetForeColor(&current);	RGBForeColor(&grey);	PenPat(&qd.gray);	MoveTo(translate_x(x),boundBot);	LineTo(translate_x(x),boundTop);	RGBForeColor(&current);	PenPat(&qd.black);}void draw_y_line(double y, long int brightness){	RGBColor grey;	RGBColor current;	grey.red=grey.green=grey.blue=brightness;	GetForeColor(&current);	RGBForeColor(&grey);	PenPat(&qd.gray);	MoveTo(boundLeft,translate_y(y));	LineTo(boundRight,translate_y(y));	RGBForeColor(&current);	PenPat(&qd.black);}void draw_axes(){	RGBColor grey;	grey.red=60000;	grey.green=40000;	grey.blue=70000;		ForeColor(redColor);	// x-axis always along bot	MoveTo(boundLeft, boundBot);	LineTo(boundRight, boundBot);		// 	y-axis always along left	MoveTo(boundLeft, boundBot);	LineTo(boundLeft, boundTop);		RGBForeColor(&grey);	PenPat(&qd.gray);	// is 0 in the range of y?	if (VertMax>0 && VertMin<0)	{		// line for y=0		double y=translate_y(0);		MoveTo(boundLeft,y);		LineTo(boundRight,y);	}	if (HorizMax>0 && HorizMin<0)	{		// line for x=0		double x=translate_x(0);		MoveTo(x, boundBot);		LineTo(x, boundTop);	}	ForeColor(blackColor);	PenPat(&qd.black);}void vertical_ticks(){	ForeColor(redColor);	TextSize(scaleSize);	double y=boundBot;	double y_incrementer=((VertMajScale/VertRange)/(VertMinTicks+1))*boundHeight;	int count=VertMinTicks;	double y_val=VertMin;	char y_val_string[20];	do	{		MoveTo(boundLeft,y);		LineTo(boundLeft-MajTickSize, y);		Move(-25,scaleSize/2);		sprintf(y_val_string,"%.1f",y_val);		ForeColor(blackColor);		DrawString(c2pstr(y_val_string));		ForeColor(redColor);		if (y<=boundTop+y_incrementer*VertMinTicks)		{			draw_y_line(y_val, 40000);		// put in major tick line			break;		}		do		{			y-=y_incrementer;			MoveTo(boundLeft,y);			LineTo(boundLeft-MinTickSize, y);			draw_y_line(y_val+(count)*VertMajScale/(VertMinTicks+1), 55000);		}		while(count--);		count=VertMinTicks;		draw_y_line(y_val, 40000);		y_val+=VertMajScale;	}	while(1);	ForeColor(blackColor);}void horizontal_ticks(){	ForeColor(redColor);	TextSize(scaleSize);		double x=boundLeft;	double x_incrementer=((HorizMajScale/HorizRange)/(HorizMinTicks+1))*boundWidth;	int count=HorizMinTicks;	double x_val=HorizMin;	char x_val_string[20];	do	{		MoveTo(x, boundBot);		LineTo(x, boundBot+MajTickSize);		Move(-scaleSize,MajTickSize+scaleSize/2);		sprintf(x_val_string,"%.1f",x_val);		ForeColor(blackColor);		DrawString(c2pstr(x_val_string));		ForeColor(redColor);		if (x>=boundRight-x_incrementer*HorizMinTicks)		{			draw_x_line(x_val,40000);			break;		}		do		{			x+=x_incrementer;			MoveTo(x, boundBot);			LineTo(x, boundBot+MinTickSize);			draw_x_line(x_val+count*HorizMajScale/(HorizMinTicks+1), 55000);		}		while(count--);		count=HorizMinTicks;		draw_x_line(x_val,40000);		x_val+=HorizMajScale;	}	while(1);		ForeColor(blackColor);}void PlaceCross(int Width){	RGBColor current;	GetForeColor(&current);		ForeColor(greenColor);		Move(-Width/2,-Width/2);	Line(Width, Width);	Move(-Width, 0);	Line(Width, -Width);		Move(-Width/2, Width/2);		RGBForeColor(&current);}void main(void){	SIOUXSettings.asktosaveonclose = FALSE;	SIOUXSettings.showstatusline = TRUE;	SIOUXSettings.columns = 10;	SIOUXSettings.rows = 5;	SIOUXSettings.toppixel = 600;	SIOUXSettings.leftpixel = 500;	Initialize();	SetPort(mainPtr);	vertical_ticks();	horizontal_ticks();	draw_axes();	double Sample_Period=0.1;		MoveTo(translate_x(HorizMin),translate_y(sin(HorizMin)));	// first sample position	ForeColor(blueColor);	for (double x=HorizMin; x<HorizMax; x+=Sample_Period)	{		PlaceCross(4);		LineTo(translate_x(x+Sample_Period), translate_y(sin(x+Sample_Period)*sqrt(x)));	}	do	{	}	while (!Button());	CloseWindow(mainPtr);/*	do	{		cin >> x >> y;		SetPort(mainPtr);		plot(x,y);	}	while (x!=0);*/}//MW specified argument and return type.void Initialize(void){	OSErr		error;	SysEnvRec	theWorld;				/* Initialize all the needed managers. */	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	SetRect(&windRect, portTop,portLeft, portTop+portWidth, portLeft+portHeight);	mainPtr = NewCWindow(nil, &windRect, "\pMark's Land", true, documentProc, 						(WindowPtr) -1, false, 0);			SetPort(mainPtr);						/* set window to current graf port */}void plot(long int x, long int y){	MoveTo(x,y);	LineTo(x,y);}