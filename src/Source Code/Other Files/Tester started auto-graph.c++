#include "rCalculatorClass.h"#include "calc_preprocessor.h"#include "validator.h"#include "CalculatorManager.h"#include "newstring.h"#include "complex.h"#include "ulist.h"#include "stringobject.h"#include "name_object.h"#include "IO_map_object.h"#include "IO_map.h"#include "set_input.h"#include "set_input_object.h"#include "Data Manager.h"#include "graphObject.h"#include "extraclasses.h"#include "graph_device.h"#include "graph_spec.h"#include "graph_spec_obj.h"#include "Graph Manager.h"#include "ulist.c++"#include <SIOUX.h>const int preprocessor_array_length=49;// loading record_object ("first", ulist<string_object>field_list) works// loading data_set_obj("first_data_obj",data_set data) works// now make a list of record_objects - works ok// now make a list of data_set_obj - works ok// now try initialising data_set - works ok// load IO_map ("1st calc", ulist<string_object> in_fields, "out_field") - works ok// try initialising IO_map - works ok// now make a list of IO_map_object - works okconst user_label labels[preprocessor_array_length]={	user_label ("sqrt", "SQUARE_ROOT"),	user_label ("cbrt", "CUBE_ROOT"),	user_label ("rootx", "ROOTX"),	user_label ("sin", "SINE"),	user_label ("cos", "COSINE"),	user_label ("tan", "TANGENT"),	user_label ("asin", "ARCSINE"),	user_label ("acos", "ARCCOSINE"),	user_label ("atan", "ARCTANGENT"),	user_label ("sinh", "SINE-H"),	user_label ("cosh", "COSINE-H"),	user_label ("tanh", "TANGENT-H"),	user_label ("asinh", "ARCSINE-H"),	user_label ("acosh", "ARCCOSINE-H"),	user_label ("atanh", "ARCTANGENT-H"),	user_label ("ln", "NATURAL_LOG"),	user_label ("log10", "LOG10"),	user_label ("log2", "LOG2"),	user_label ("logx", "LOGX"),	user_label ("arg", "ARGUMENT"),	user_label ("MILLI", "MILLI"),	user_label ("MICRO", "MICRO"),	user_label ("NANO","NANO"),	user_label ("PICO","PICO"),	user_label ("FEMTO", "FEMTO"),	user_label ("KILO", "KILO"),	user_label ("MEGA", "MEGA"),	user_label ("GIGA", "GIGA"),	user_label ("TERA", "TERA"),	user_label ("PETA", "PETA"),	user_label ("EXA",  "EXA"),	user_label ("SUM", "SUMMATION"),	user_label ("PROD", "PRODATION"),	user_label ("re", "REAL"),	user_label ("im", "IMAGINARY")};name_object calc_constants[3]={	name_object ("pi", complex_container (CONSTANT, complex(3.1415926535897932385,0))),	name_object ("e", complex_container (CONSTANT, complex(2.7182818284590452354,0))),	name_object ("j", complex_container (CONSTANT, complex(0,1)))};int number_of_constants=3;ulist<IO_map_object> _t1;ulist<set_input_object> _t2;ulist<data_set_obj> _t3;ulist<record_object> _t4;ulist<string_object> _t5;ulist<name_object> _t6;ulist<graph_spec_obj> _t7;status extract_graph_specs(calculator_manager &calc_manager, graph_device &graph_);void display_graph(calculator_manager &calc_manager, graph_device &graph_);// Graph name constantsstring_class x_min_string="xmin";string_class x_max_string="xmax";string_class x_scale_string="xscale";string_class x_div_string="xdiv";string_class y_min_string="ymin";string_class y_max_string="ymax";string_class y_scale_string="yscale";string_class y_div_string="ydiv";string_class sample_res_string="res";string_class x_string="x";string_class y_string="y";double auto_graph, x_min, x_max, x_scale, x_tick, y_min, y_max, y_scale, y_tick;double sample_res;void Initialize(void);void main(void){	SIOUXSettings.asktosaveonclose = FALSE;	SIOUXSettings.showstatusline = TRUE;	SIOUXSettings.columns = 80;	SIOUXSettings.rows = 45;	SIOUXSettings.toppixel = 50;	SIOUXSettings.leftpixel = 340;	cout << _t1 << _t2 << _t3 << _t4 << _t5 << _t6 << _t7 << "\n";	// done to build ostreams!		Initialize();		calculator::build_internal_constants(calc_constants, number_of_constants);	calc_preprocessor preprocessor(labels, calculator::token_names, preprocessor_array_length);	complex_container::postprocessing=&preprocessor;	calculator_manager calc_manager(&preprocessor);	graph_device graph_(port_info (0,40,340,380), border_info (), scale_info (2,4), scale_info (2,4), range_info (-10,10), range_info (-10,10), tick_info (5,2));	graph_.blank_graph();	// data_manager data_man;	// graph_manager graph_man;	// data_man.interface();	// graph_man.interface();			for (;;)	{				calc_manager.interface();		if (extract_graph_specs(calc_manager,graph_)==SUCCESS)		{				display_graph(calc_manager,graph_);		}		else		{			cout << "No Graph calculator\n";		}	}}status extract_graph_specs(calculator_manager &calc_manager, graph_device &graph_){	// get current calc	string_class current=calc_manager.get_current_calc();	if (calc_manager.set_current_calc("graph")==ERROR)		return ERROR;	x_min=calc_manager.process_order(x_min_string).re;	x_max=calc_manager.process_order(x_max_string).re;	graph_.set_horiz_range(range_info (x_min, x_max));	sample_res=calc_manager.process_order(sample_res_string).re;	if (sample_res<0)		sample_res=-sample_res;			auto_graph=calc_manager.process_order(auto_graph_string).re;	if (auto_graph==0)			// not doing an autograph so get the details	{		x_scale=calc_manager.process_order(x_scale_string).re;		x_tick=calc_manager.process_order(x_div_string).re;		graph_.set_horiz_scales(scale_info (x_scale, x_tick));		y_min=calc_manager.process_order(y_min_string).re;		y_max=calc_manager.process_order(y_max_string).re;		graph_.set_vert_range(range_info (y_min, y_max));		y_scale=calc_manager.process_order(y_scale_string).re;		y_tick=calc_manager.process_order(y_div_string).re;		graph_.set_vert_scales(scale_info (y_scale, y_tick));	}	if (current!="")		calc_manager.set_current_calc(current);	return SUCCESS;}void display_graph(calculator_manager &calc_manager, graph_device &graph_){	int number of samples=(x_max-x_min)/sample_res;	// pre-calculate graph	results=new double[number_of_samples, 2];		// store input and output	int index=0;		for (double variable=x_min; variable<=x_max; variable+=sample_res)	{		sprintf(order,"var=%f",variable);			// warning precision		calc_manager.process_order(order);		results[index][0]=calc_manager.process_order(x_string).re;		results[index][1]=calc_manager.process_order(y_string).re;				index++;	}	// find limits of the graph	double x_minimum=results[0][0];				// substitute min and max macros	double x_maximum=results[0][0];				// substitute min and max macros	double y_minimum=results[0][1];				// substitute min and max macros	double y_maximum=results[0][1];				// substitute min and max macros	for (int i=1; i<index; i++)	{		results[i][0]<x_minimum ? x_minimum=results[i][0];		results[i][0]>x_maximum ? x_maximum=results[i][0];		results[i][1]<y_minimum ? y_minimum=results[i][1];		results[i][1]>y_maximum ? y_maximum=results[i][1];	}		// tidy limits	graph_.blank_graph();		char order[1000];	double x,y;			ForeColor(blueColor);	for (double variable=x_min; variable<=x_max; variable+=sample_res)	{		sprintf(order,"var=%f",variable);			// warning precision		calc_manager.process_order(order);		y=calc_manager.process_order(y_string).re;		x=calc_manager.process_order(x_string).re;		MoveTo(graph_.translate_x(x),graph_.translate_y(y));		graph_.PlaceCross(4);	}	}void Initialize(void){	/* Initialize all the managers. */	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();}