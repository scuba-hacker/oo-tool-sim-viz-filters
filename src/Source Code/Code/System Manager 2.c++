/************************************************************************************** * CODE FILE: System Manager 2.c++ * PURPOSE	: Main code file - defines version 2 of the system *            Full implementation - defines 'system manager' as co-ordinator for *						calculator manager, data manager and graph manager. Fully integrated. **************************************************************************************/#include "rCalculatorClass.h"#include "calc_preprocessor.h"#include "validator.h"#include "CalculatorManager.h"#include "newstring.h"#include "complex.h"#include "ulist.h"#include "stringobject.h"#include "name_object.h"#include "IO_map_object.h"#include "IO_map.h"#include "set_input.h"#include "set_input_object.h"#include "Data Manager.h"#include "extraclasses.h"#include "graph_device.h"#include "graph_spec.h"#include "graph_spec_obj.h"#include "Graph Manager.h"#include "system_process.h"#include "ulist.c++"#include <SIOUX.h>// Declare and define array matching user labels to OPERATIONSconst int preprocessor_array_length=50;const user_label labels[preprocessor_array_length]={	user_label ("sqrt", "SQUARE_ROOT"),	user_label ("cbrt", "CUBE_ROOT"),	user_label ("rootx", "ROOTX"),	user_label ("sin", "SINE"),	user_label ("cos", "COSINE"),	user_label ("tan", "TANGENT"),	user_label ("asin", "ARCSINE"),	user_label ("acos", "ARCCOSINE"),	user_label ("atan", "ARCTANGENT"),	user_label ("sinh", "SINE-H"),	user_label ("cosh", "COSINE-H"),	user_label ("tanh", "TANGENT-H"),	user_label ("asinh", "ARCSINE-H"),	user_label ("acosh", "ARCCOSINE-H"),	user_label ("atanh", "ARCTANGENT-H"),	user_label ("ln", "NATURAL_LOG"),	user_label ("log10", "LOG10"),	user_label ("log2", "LOG2"),	user_label ("logx", "LOGX"),	user_label ("arg", "ARGUMENT"),	user_label ("MILLI", "MILLI"),	user_label ("MICRO", "MICRO"),	user_label ("NANO","NANO"),	user_label ("PICO","PICO"),	user_label ("FEMTO", "FEMTO"),	user_label ("KILO", "KILO"),	user_label ("MEGA", "MEGA"),	user_label ("GIGA", "GIGA"),	user_label ("TERA", "TERA"),	user_label ("PETA", "PETA"),	user_label ("EXA",  "EXA"),	user_label ("SUM", "SUMMATION"),	user_label ("PROD", "PRODATION"),	user_label ("re", "REAL"),	user_label ("im", "IMAGINARY"),	user_label ("wind", "WINDOW")};// Declare and define array holding constants for use by all calculatorsconst int number_of_constants=3;name_object calc_constants[number_of_constants]={	name_object ("pi", complex_container (CONSTANT, complex(3.1415926535897932385,0))),	name_object ("e", complex_container (CONSTANT, complex(2.7182818284590452354,0))),	name_object ("j", complex_container (CONSTANT, complex(0,1)))};// Declare one instance of every type of ulist available.ulist<IO_map_object> _t1; ulist<set_input_object> _t2; ulist<data_set_obj> _t3;ulist<record_object> _t4; ulist<string_object> _t5; ulist<name_object> _t6;ulist<graph_spec_obj> _t7;// Function prototypes for this file:void display_help();void Initialize(void);void interface(calculator_manager &calc_man, data_manager &data_man,								graph_manager &graph_man, system_process &process, graph_device &graph_);void process_help();status set_process_object(system_process &process);status calculate_process(calculator_manager &calc_man, data_manager &data_man,											 system_process &process);status display_rect_graph(data_manager &data_man, graph_manager &graph_man,												system_process process, string_class x_axis, string_class y_axis,												int start, int finish, graph_device &graph_);status display_cornu_graph(data_manager &data_man, graph_manager &graph_man,												 system_process process, string_class vector, int start,												 int finish, graph_device &graph_);void main(void){	// Initialise Simple Input/Output User eXchange terminal.	SIOUXSettings.asktosaveonclose = FALSE;	SIOUXSettings.showstatusline = TRUE;	SIOUXSettings.columns = 80;	SIOUXSettings.rows = 45;	SIOUXSettings.toppixel = 50;	SIOUXSettings.leftpixel = 380;		// Call to cout to instantiate overloaded output stream operators for all ulists	cout << _t1 << _t2 << _t3 << _t4 << _t5 << _t6 << _t7 << "\n";		Initialize();																		// Initialise Macintosh Toolbox Managers		// Initialise calculator class with constants array	calculator::build_internal_constants(calc_constants, number_of_constants);	// Instantiate a preprocessor object - mapping all user_label elements in 'labels' array	// to all token_name elements in 'token_names' array.	calc_preprocessor preprocessor(labels, calculator::token_names,																 preprocessor_array_length);	// Initialise complex_container class with pointer to preprocessor object	complex_container::postprocessing=&preprocessor;	// Instantiate calculator manager - linked to preprocessor object	calculator_manager calc_man(&preprocessor);	data_manager data_man;																			// Instantiate data manager	graph_manager graph_man;																		// Instantiate graph manager	system_process process;											// Used to hold system manager instructions		// Instantiate single graphing window object	graph_device graph_(port_info (10,40,350,380), border_info (), scale_info (2,4),						scale_info (2,4), range_info (-10,10), range_info (-10,10),						tick_info (5,2));	graph_.blank_graph();														// Draw default axes in graphing window	display_help();																	// Display commands for system manager	// Set the system manager to work...	interface(calc_man, data_man, graph_man, process, graph_);		graph_.showGraph();	for (int i=0; i<1000000; i++);};// Define function containing CLI of system manager - allows access to calculator, data// and graph managers. Allows 'process' parameters to be viewed and set. Allows // a process to be carried out and graphed.void interface(calculator_manager &calc_man, data_manager &data_man,								graph_manager &graph_man, system_process &process, graph_device &graph_){	const int MAX_IO=1000;														// Define Buffer size for input/output	char input_string[MAX_IO]="";											// Initialise primary input char array					cout << "\nSystem Manager> ";													// Output manager prompt	while (cin >> input_string)														// Main interface loop	{		if (strcmp(input_string,"help")==0)									// Command displaying commands		{			display_help();			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"quit")==0)									// Command for quitting program			break;																						// Break out of while loop					if (strcmp(input_string,"reset")==0)								// Command for resetting system		{			calc_man.reset_manager();													// Reset all managers			data_man.reset_manager();			graph_man.reset_manager();			process=system_process();													// Set process to default values			cout << "Global reset done\n";			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"calcman")==0)							// Command to switch context to		{																										// calculator manager.			calc_man.display_help();													// Display calc manager commands			calc_man.interface();															// Invoke calc manager interface			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"dataman")==0)							// Command to switch context to 		{																										// data manager.			data_man.display_help();													// Display data manager commands			data_man.interface();															// Invoke data manager interface			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"graphman")==0)							// Command to switch context to		{																										// graph manager.			graph_man.display_help();													// Display graph manager commands			graph_man.interface();														// Invoke graph manager interface			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"setprocess")==0)						// Command to set 'process'		{			cout << "Current process settings:\n";			cout << process << "\n";			process_help();																		// Output set process commands			set_process_object(process);											// Switch context to set process			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"viewprocess")==0)					// Command to view 'process'		{			cout << "Current process settings:\n";			cout << process << "\n";			goto prompt4;																			// Jump to end of while loop		}				if (strcmp(input_string,"doprocess")==0)						// Command to carry out process		{			cout << "Calculating process\n";			calculate_process(calc_man, data_man, process);		// Call processing function			goto prompt4;																			// Jump to end of while loop		}		if (strcmp(input_string,"graphprocess")==0)					// Command to graph process		{			string_class graphtype, x_axis, y_axis;			int start, finish;			cin >> graphtype;																	// Read in graph type (rect/cornu)			if (graphtype=="rect")														// Rectangular graphing chosen			{				cout << "Enter <x axis variable> <y axis variable> <start index> <end index>\n";				cin >> x_axis >> y_axis >> start >> finish;			// Read rect graph parameters				display_rect_graph(data_man, graph_man,process,  x_axis,	// Display rect graph													 y_axis, start, finish, graph_);				// and plot points			}			else				if (graphtype=="cornu")													// Polar vector graphing chosen				{					cout << "Enter <axis-variable> <start index> <end index>\n";					cin >> x_axis >> start >> finish;							// Read cornu graph parameters					display_cornu_graph(data_man, graph_man, process,			// Display cornu graph															x_axis, start, finish, graph_);		// and plot points				}				else					cout << "ERROR: Invalid graph type\n";			goto prompt4;																			// Jump to end of while loop		}			prompt4:																						// End of loop label		cout << "\System Manager> ";												// Output manager prompt	}}// Define function for outputting all system manager commands.void display_help(){	cout << "Commands Available:\n";	cout << "\t graphman\n";	cout << "\t dataman\n";	cout << "\t calcman\n";	cout << "\t graphprocess\n";	cout << "\t setprocess\n";	cout << "\t viewprocess\n";	cout << "\t doprocess\n";	cout << "\t reset\n";	cout << "\t help\n";	cout << "\t quit\n";}// Define function for outputting prompt when inputting process parametersvoid process_help(){	cout << "Change which field?\n"; 	cout << "\t(c)aluator_name <name>,\n";	cout << "\t(d)ata_set_name <name>,               (g)raph_spec_name <name>,\n";	cout << "\t(s)et_input_names <name1> <name2>..., (m)ap_names <name1> <name2>...\n";}// Define function for reading process parameters from standard input and storing them// in system_process process (passed back using variable function parameter)status set_process_object(system_process &process){	const int MAX_IO=1000;														// Define Buffer size for input/output	char input[MAX_IO];	string_class command;	cin >> command;																				// Read in set process command	cin.getline(input, MAX_IO);														// Read remainder of input line	istrstream input_stream(input);												// Use input stream to access chars	if (command=="d")																			// Set data_set_name chosen		input_stream >> process.data_set_name;							// Read string into data_set_name	else		if (command=="g")																		// Set graph_spec_name chosen			input_stream >> process.graph_spec_name;					// Read string into graph_spec_name		else			if (command=="s")																	// Set set_input_names chosen			{				process.load_list(input_stream,0);							// Pass stream to process object 				cout << "Provide corresponding data_set field names for set_inputs:\n";				cin.getline(input,MAX_IO);											// Store line of chars in 'input'				istrstream input_stream2(input);								// Set stream to point to 'input'				process.load_list(input_stream2,1);							// Pass stream to process object			}			else				if (command=="m")																// Set map_names chosen					process.load_list(input_stream,2);						// Pass stream to process object				else					if (command=="c")															// Set calc_name chosen						input_stream >> process.calc_name;					// Read string into calc_name					else					{						cout << "ERROR: Invalid process command\n";						return ERROR;					}	return SUCCESS;																				// Setting all ok.}// Define function to carry out instructions contained in system_process process.// Uses calculator manager and datamanager to do all evaluations and store input// data and results in data_set of your choice.status calculate_process(calculator_manager &calc_man, data_manager &data_man,											 system_process &process){	// Pointer to data_set_obj containing target data_set for storing inputs derived	// from set_input objects and storing evaluation results from calculator	data_set_obj *target=NULL;	// Set current calc to process.calc_name in calculator manager - check outcome	// Following checks are applied to lists in the data manager:	// Check data_set indexed by data_set_name exists - reference data_list	// Check all set_input_names exist in set_input_list	// Check set_input_fields correspond to field names in relevant data_set object.	// Check all map_names exist in map_list.	// Check all map_name input and output field names are in relevant data_set object.	// If any of these checks fail, return ERROR...	// Second expression sets target to point to relevant data_set_obj in data_list.	// This is where the data array which is to be used for all processing/evaluating.	if (calc_man.set_current_calc(process.calc_name)==ERROR ||			data_man.check_set_input_list(process.set_input_names)==ERROR ||			data_man.check_data_list(process.data_set_name, process.set_input_fields,															 process.map_names, target)==ERROR)		return ERROR;			target->clear_data_array();																	// Next clear data_set array		string_object input_name;	string_object input_field;	set_input_object input_object;		// Next - apply all set_inputs to data_set array	process.set_input_names.reset_transverse();			// Reset to head of set_input_names list	process.set_input_fields.reset_transverse();		// Reset to head of set_input_fields list	do	{		process.set_input_names.get_transverse(input_name);			// Get current set_input name		process.set_input_fields.get_transverse(input_field);		// Get current input field name		// Set input_object to have same name as that in data of string_object input_name		input_object=set_input_object(input_name.get_data());		// Search_node loads input_object data field with set_input data found in named object		data_man.set_input_list.search_node(input_object, COUNTER);		// Load target data_set array (column labelled with name stored in input_field)		// with values specified by set_input_object found		target->load_real_input(input_object.get_data(), input_field.get_data());	}		while (process.set_input_fields.progress_transverse()==SUCCESS &&	// Apply all set_inputs				 process.set_input_names.progress_transverse()==SUCCESS);		// to data_set				 	// Next - apply IO_maps to each set of data_set input fields, storing result in data_set	// output_field	int length=target->get_length();									// Get length of target data_set array	IO_map_object map_order;	IO_map_object map;	string_object *map_name;	string_class *input_fields=NULL;								// Array of input fields for current map	string_class *output_fields=NULL;								// Array of output fields for current map	complex result;																	// Stores evaluation from calculator	char order[1000];																// Stores string order for calculator	int no_of_input_fields, no_of_output_fields;		// Holds no of fields for current map	char input[1000];	for (int i=0; i<length; i++)										// Apply to all rows of array in data_set	{		cout << "Processing row " << i << "\n";		process.map_names.reset_transverse();					// Reset to head of map_names list		do																						// Apply all maps to each row of array		{			// Get input field names from current IO_map:			// Get pointer to current string_object in map_name list			map_name=process.map_names.get_transverse_node_pointer();			// Load index field of IO_map_object with name stored in data field of			// string_object node.			map=IO_map_object(map_name->get_data());			// Search_node looks up IO_map_object in map_list with correct name, and copies its			// IO_map into IO_map field of 'map'.			data_man.map_list.search_node(map, COUNTER);						// Get input and output fields for IO_map now stored in 'map'			no_of_input_fields=map.get_number_of_input_fields();			input_fields=new string_class[no_of_input_fields];			no_of_output_fields=map.get_number_of_output_fields();			output_fields=new string_class[no_of_output_fields];			map.get_input_fields(input_fields);										// Copy info into input_fields			map.get_output_fields(output_fields);									// Copy info into output_fields						// Set each input_field variable in calculator to value stored in			// corresponding data_set.data_array column.			for (int j=0; j<no_of_input_fields; j++)														// For all inputs			{				// Extract data from relevant element of target data_set.data_array				if (target->get_element_assoc(result,i,input_fields[j])==ERROR)				{					cout << "out of range index in set_input named '" << map_name->get_data()							 << "'\n";					return ERROR;				}				input_fields[j].string_copy(input);						// Convert string name to char array				// Build order for calculator - eg "var=10+2j"				sprintf(order,"%s=%e+%e*j",input, result.re,result.im);				// Calculator manager gets current calculator to process the order				calc_man.process_order(string_class(order));			}						// now get result from calculator for each output variable - store in corresponding			// output_fields labelled column of current row of data_set.data_array			for (int j=0; j<no_of_output_fields; j++)						// For all outputs				target->set_element_assoc(calc_man.process_order(output_fields[j]),																  i,output_fields[j]);			delete [] input_fields;															// Deallocate input_fields array			delete [] output_fields;														// Deallocate output_fields array		}		while (process.map_names.progress_transverse()==SUCCESS);					// Apply all IO_maps	}	return SUCCESS;	// Data array in target data_set stores all inputs and evaluated outputs}// Define function to draw graph on rectangular axes in graphing windowstatus display_rect_graph(data_manager &data_man, graph_manager &graph_man,												system_process process, string_class x_axis, string_class y_axis,												int start, int finish, graph_device &graph_){	// First get graph spec referenced by process.graph_spec_name - search in graph list	// in data manager - loads up spec_obj with relevant graph_spec info	graph_spec_obj spec_obj(process.graph_spec_name);	if (graph_man.spec_list.search_node(spec_obj,COUNTER)==ERROR)	{		cout << "graph spec with name '" << process.graph_spec_name << "' not found\n";		return ERROR;	}	graph_spec spec(spec_obj.get_data());	// Load graph device with graph_spec parameters	graph_.set_params(spec.horiz_scale, spec.vert_scale, spec.horiz_range, spec.vert_range);	graph_.blank_graph();																		// Draw axes and scales on graph	// Get data set obj referenced by process.data_set_name - load data_obj with data_set.	data_set_obj data_obj(process.data_set_name);	if (data_man.data_list.search_node(data_obj,COUNTER)==ERROR)	{		cout << "data set with name '" << process.data_set_name << "' not found\n";		return ERROR;	}		if (data_obj.get_length()<=finish || finish<0 ||			// Check for out of range index			data_obj.get_length()<=start || start<0 ||				// element limits			start>finish)	{		cout << "indices out of range for this data_set\n";		return ERROR;	}		// Plot the data in fields 'x_axis' and 'y_axis' of data_set, delimited by start and	// finish elements	complex x,y;	data_obj.get_element_assoc(x,start,x_axis);								// Extract first x axis value	data_obj.get_element_assoc(y,start,y_axis);								// Extract first y axis value	// Move graphics pen to first data point on graph plane	MoveTo(graph_.translate_x(x.re),graph_.translate_y(y.re));		// Only use real components	// Place cross at first plot point, 4 pixel size	graph_.PlaceCross(4);	ForeColor(blueColor);																									// Set line colour	for (int index=start+1; index<=finish; index++)						// For all remaining elements	{		data_obj.get_element_assoc(x,index,x_axis);							// Extract x axis value		data_obj.get_element_assoc(y,index,y_axis);							// Extract y axis value		LineTo(graph_.translate_x(x.re),graph_.translate_y(y.re));	// Only use real components		graph_.PlaceCross(4);																		// Place 4 pixel cross at point	}	return SUCCESS;	}// Define function to draw polar vector graph (cf cornu spiral) in graphing windowstatus display_cornu_graph(data_manager &data_man, graph_manager &graph_man,												 system_process process, string_class vector, int start,												 int finish, graph_device &graph_){	// First get graph spec referenced by process.graph_spec_name - search in graph list	// in data manager - loads up spec_obj with relevant graph_spec info	graph_spec_obj spec_obj(process.graph_spec_name);	if (graph_man.spec_list.search_node(spec_obj,COUNTER)==ERROR)	{		cout << "graph spec with name '" << process.graph_spec_name << "' not found\n";		return ERROR;	}	graph_spec spec(spec_obj.get_data());	graph_.clear_window();																		// Blank graph window - no axes	// Get data set obj referenced by process.data_set_name	data_set_obj data_obj(process.data_set_name);	if (data_man.data_list.search_node(data_obj,COUNTER)==ERROR)	{		cout << "data set with name '" << process.data_set_name << "' not found\n";		return ERROR;	}		if (data_obj.get_length()<=finish || finish<0 ||					// Check for out of range index			data_obj.get_length()<=start || start<0 ||						// element limits			start>finish)	{		cout << "indices out of range for this data_set\n";		return ERROR;	}	// Move to origin for polar vector plot.	// Use scale.MajScale values stored in spec to hold horiz and vert stretch factors.	// Use scale.MinTicks values stored in spec to hold horiz and vert origin offsets.	MoveTo(graph_.x_origin(spec.horiz_scale.MinTicks*spec.horiz_scale.MajScale),				 graph_.y_origin(spec.vert_scale.MinTicks*spec.vert_scale.MajScale));	// graph_.PlaceCross(4);																		// Place 4 pixel cross at origin	complex x;	ForeColor(blueColor);																									// Set line colour	for (int index=start; index<=finish; index++)													// For all elements	{		data_obj.get_element_assoc(x,index,vector);										// Extract 'vector' value		// Use real component of x as horizontal component of vector.		// Use imag component of x as vertical component of vector.		// Draw line from current pen position along vector.		Line(x.re*spec.horiz_scale.MajScale,-x.im*spec.vert_scale.MajScale);		// graph_.PlaceCross(4);															// Place 4 pixel cross at new origin	}	return SUCCESS;																										// Graph plotted okay.}// Define function for initalising all Macintosh Operating System Managers// Enables use of graphics, windows, fonts, etc.void Initialize(void){	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();}