/************************************************************************************** * CODE FILE: extraclasses.c++ * PURPOSE	: define members of complex_container class **************************************************************************************/#include "extraclasses.h"#include "calc_preprocessor.h"extern const int MAX_INPUT_STRING_LENGTH=1000;										// Max input buffer size// Define default constructorcomplex_container::complex_container(){	indicator=CONSTANT;	complex_number=complex (0,0);	equation="";}// Define parameterized constructor - storing complex numbercomplex_container::complex_container(macro_type store_indicator,									 complex store_complex_number){	// Set indicator data member	switch (store_indicator)	{		case CONSTANT:			indicator=store_indicator;			break;					case EQUATION:			indicator=CONSTANT;			cout << "Warning - complex_container given EQUATION & complex number\n";			break;		default:			indicator=CONSTANT;			cout << "Warning - complex_container given illegal enum & complex number\n";			break;			}	complex_number=store_complex_number;																// Set complex number}// Define parameterized constructor - storing stringcomplex_container::complex_container(string_class equation_string){	indicator=EQUATION;	equation=equation_string;}// Define overloaded output operatorostream& operator<<(ostream& output_stream, const complex_container container){	switch (container.indicator)	{		case CONSTANT:																					// Output complex number stored			return output_stream << container.complex_number << "\n";		case EQUATION:																	// Output postprocessed equation string		{			string_class postprocessed_string;			complex_container::postprocessing->postprocess(container.equation,																										 postprocessed_string);			return output_stream << "EQUATION=" << postprocessed_string << "\n";		}		default:			return output_stream << "Undefined Enum Value\n" << "\n";	}}// Define overloaded input operatoristream& operator>>(istream& input_stream, complex_container& container){	char buffer[MAX_INPUT_STRING_LENGTH]="\0";	char next_char=0;		int x=0;																									// Character offset for string		// Read in control string - CONSTANT/EQUATION	while(input_stream.get(next_char) && isspace(next_char)) ;					// Skip white space	if (next_char!=0)																			// Putback last character read in		input_stream.putback(next_char);								// if data was present in input_stream			while(input_stream.get(buffer[x]) && x<MAX_INPUT_STRING_LENGTH-1)			// Read in string	{		if (isspace(buffer[x]))														// Terminate reading on whitespace		{			input_stream.putback(buffer[x]);								// Put white space back into stream			buffer[x]='\0';																	// Terminator buffer string			break;		}		x++;																							// Increment character offset	}		if(input_stream.get(next_char) && !isspace(next_char))		// Check for overlong input		cout << "String stream input too long > 1000 chars\n";	if (strcmp(buffer, "CONSTANT")==0)												// Control string was CONSTANT	{		container.indicator=CONSTANT;														// Store CONSTANT in indicator		input_stream >> container.complex_number;								// Read in complex number	}	else	{		if (strcmp(buffer,"EQUATION")==0)												// Control string was EQUATION		{			container.indicator=EQUATION;													// Store EQUATION in indicator			input_stream >> container.equation;										// Read in string from input		}		else																										// Invalid control string			container.indicator=CONSTANT;	}	return input_stream;}// Define method for comparing two complex container objectscompare compare_containers(complex_container left, complex_container right){	// Order on CONSTANT, VARIABLE, EQUATION - ie order on enum int value	// then order on real of complex_container.complex_number, then imag of	// complex_container.complex_number - for EQUATION lexically compare strings 		if (left.indicator<right.indicator)										// CONSTANT < VARIABLE < EQUATION		return SMALLER;	else		if (left.indicator>right.indicator)			return LARGER;		else			if (left.indicator==CONSTANT)														// Comparing complex numbers			{					if (left.complex_number.re<right.complex_number.re)			// Compare real components					return SMALLER;				else					if (left.complex_number.re>right.complex_number.re)						return LARGER;					else						if (left.complex_number.im<right.complex_number.im)	// Compare imag components							return SMALLER;						else							if (left.complex_number.re>right.complex_number.im)								return LARGER;							else								return EQUAL;			}			else			{																												// Comparing equation strings			// Note this ordering is done using equations containing tokens rather than user			// function names.				if (left.equation<right.equation)					return SMALLER;				else					if (left.equation>right.equation)						return LARGER;					else						return EQUAL;			}}// Static declaration of class data membercalc_preprocessor* complex_container::postprocessing;