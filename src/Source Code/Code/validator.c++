/************************************************************************************** * CODE FILE: validator.c++ * PURPOSE	: define members of validator class **************************************************************************************/#include "validator.h"// Constructor - instantiates validator and connects preprocessor service providervalidator::validator(calc_preprocessor *preprocessor){	connected_preprocessor=preprocessor; }// Define method for validating all equations inside a particular calculator objectstatus validator::validate(calculator *connect_calculator){	connected_calculator=connect_calculator;						// setup reference to the calculator	// Get list of all equations from connected_calculator	ulist<name_object> *equation_list=connected_calculator->get_equation_list();	name_object equation_node;									// Define object to hold current equation	error_trace="";															// Initialise error_trace		// Reset to head of equation_list	if (equation_list->reset_transverse()==ERROR)		// Equation list empty - no checks to do		return SUCCESS;											do	{		equation_list->get_transverse(equation_node);					// Get current equation		if (verify(equation_node.get_index())==ERROR)					// Verify the equation			return ERROR;																				// Circular definition found	}	while (equation_list->progress_transverse()==SUCCESS);	// Process all equations in list	error_trace="";														// no errors so make sure error_trace is blank	return SUCCESS;							// verified every equation in list - no circular definitions}// Define recursive method for verifying equation with identifier, name_stringstatus validator::verify(const string_class name_string, string_class dependents){	string_class output_string;										// result of preprocessing - not used	ulist<string_object> non_reserved_names;			// List of const/var/eqn names in equation	string_object string_node;										// Holds string containing RHS of equation	name_object equation(name_string);						// Search reference object	// Get list of equations in connected_calculator	ulist<name_object> *equation_list=connected_calculator->get_equation_list();	// Find out if name_string references an equation or not	if (equation_list->search_node(equation, COUNTER)==ERROR)	// check for non-equation name		return SUCCESS;						// Success if name_string references a constant or variable	// Call to search_node has loaded DATA field of 'equation' with string holding RHS of	// equation being verified.	// Get list of non-reserved names present in string stored in DATA field of 'equation'	connected_preprocessor->preprocess(equation.get_equation(), output_string,																		 &non_reserved_names);	if (non_reserved_names.reset_transverse()==ERROR)	// If non-reserved name list is empty		return SUCCESS;																	// then contains no circular defns		// Recursively verify all equations referenced by the non-reserved names.	do	{					non_reserved_names.get_transverse(string_node);												// Get next name		if (search_string(dependents, string_node.get_data())==SUCCESS)				// Circular defn		{			append_name(dependents, string_node.get_data());	// add name to list of dependents			error_trace=dependents;														// Update error_trace 			return ERROR;																			// Circular reference been found		}		else												// No circular definition so far - must continue verifying		{														// to bottom of recusive definition for this equation			string_class dependents_backup=dependents;							// Make backup of dependents 			// Add current name to list of dependents for parent equation 			append_name(dependents, string_node.get_data());			if (verify (string_node.get_data(), dependents)==ERROR)				// Circular defn found				return ERROR;												// Propagate ERROR up recursion stack			else																	// Bottom of tree reached - all okay				dependents=dependents_backup;				// Resume using backup dependents,																						// as last name has proved to be non-dependent		}	}	while (non_reserved_names.progress_transverse()==SUCCESS);					// Verify every name	return SUCCESS;													// All dependents of equation name_string found																					// to contain no circular definitions}