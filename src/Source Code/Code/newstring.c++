/************************************************************************************** * CODE FILE: newstring.c++ * PURPOSE	: define members of string_class class **************************************************************************************/#include "newstring.h"extern const int MAX_INPUT_STRING_LENGTH;// define default constructorstring_class::string_class()				// initialise string with NULL terminator, string_length=1{	letters=new char[1];				letters[0]='\0';				string_length=1;			}// define constructor using char array as sourcestring_class::string_class(const char *source){	if (source==NULL)	{		cout << "Trying to copy NULL address into string class - illegal\n";		letters=new char[(string_length=1)];										// initialise as in string_class()		letters[0]='\0';	}	else	{		letters = new char[(string_length=(strlen(source)+1))];		letters[0]='\0';		strcpy (letters, source);	}}// define copy constructorstring_class::string_class(const string_class &original){	letters = new char[(string_length=original.string_length)];	letters[0]='\0';	strcpy(letters, original.letters);}// define destructorstring_class::~string_class(){	if (letters!=NULL)		delete[] letters;	else	{		// bad construction, no memory has been allocated, so don't delete anything	}}// define method for extracting letters char array from string_class objectstatus string_class::string_copy(char *target)								// copy letters array into target{	if (target!=NULL)	{		target[0]='\0';		strcpy(target,letters);		return SUCCESS;	}	else	{		cout << "ERROR : attempted to string_copy into a NULL char pointer\n";		return ERROR;	}}// define assignment of string_class objects by string_class objectsstring_class& string_class::operator=(const string_class &source){	// first disallow x=x where left side is same as right side	// don't change a thing in this case	if (&source==this)		return *this;	delete[] letters;	letters = new char[(string_length=source.string_length)];	letters[0]='\0';	strcpy (letters, source.letters);	return *this;}// define assignment of string_class objects by char arraysstring_class& string_class::operator=(const char *source){	if (source==NULL)	{		cout << "Trying to assign NULL address into string class - illegal\n";	}	else	{		delete[] letters;		letters = new char[(string_length=(strlen(source)+1))];		letters[0]='\0';		strcpy (letters, source);	}	return *this;}// define assignment of string_class objects by single charstring_class& string_class::operator=(const char &source){	delete[] letters;	letters = new char[2];	letters[0]=source;	letters[1]='\0';	string_length=2;	return *this;}// define string_class+string_class appending operationstring_class operator+(const string_class source1, const string_class source2){	string_class return_string;	char *temp=			new char [(return_string.string_length=source1.string_length+source2.string_length-1)];	temp[0]='\0';		strcat (temp, source1.letters);	strcat (temp, source2.letters);			return_string=temp;	delete[] temp;	return return_string;}// define string_class+char_array appending operationstring_class operator+(const string_class source1, const char *source2){	string_class return_string;	char *temp = new char [(return_string.string_length=source1.string_length+strlen(source2))];	temp[0]='\0';		strcat (temp, source1.letters);	strcat (temp, source2);		return_string=temp;	delete[] temp;	return return_string;}// define char_array+string_class operationstring_class operator+(const char *source1, const string_class source2 ){	string_class return_string;	char *temp = new char [(return_string.string_length=source2.string_length+strlen(source1))];	temp[0]='\0';		strcat (temp, source1);	strcat (temp, source2.letters);		return_string=temp;	delete[] temp;	return return_string;}// define string_class+char operationstring_class operator+(const string_class source1, const char input_char){	int string_len=source1.string_length+1;	char *temp = new char [string_len];	temp[0]='\0';			strcpy (temp, source1.letters);	temp[string_len-2]=input_char;	temp[string_len-1]='\0';	string_class return_string(temp);	return_string=temp;	delete[] temp;	return return_string;}// define string_class[] subscriptingchar& string_class::operator[](const int index){	if (index<0 || index>string_length-2)	{		cout << "Error : string index " << index << " out of range\n";		return letters[string_length];																				// return NULL char	}	else		return letters[index];}// define const string_class[] subscriptingchar& string_class::operator[](const int index) const{	if (index<0 || index>string_length-2)	{		cout << "Error : string index " << index << " out of range\n";		return letters[string_length];																				// return NULL char	}	else		return letters[index];}// define method for finding out length of char array stored in string_classint string_class::length(){	return string_length-1;}// define overloaded output operatorostream& operator<<(ostream& output_stream, const string_class output_string){	return output_stream << output_string.letters;}// define overloaded input operatoristream& operator>>(istream& input_stream, string_class& input_string){	char buffer[MAX_INPUT_STRING_LENGTH]="";	char next_char=0;	int x=0;		// skip initial white space	while(input_stream.get(next_char) && isspace(next_char)) ;		// put back last character into stream if input held > 0 characters originally	if (next_char!=0)		input_stream.putback(next_char);		// read in string delimited by end of input stream and non-alphanumeric characters, reading	// maximum of MAX_INPUT_STRING_LENGTH-1 characters	while(input_stream.get(buffer[x]) && x<MAX_INPUT_STRING_LENGTH-1)	{		if (x==MAX_INPUT_STRING_LENGTH-1)			break;		if (!isalnum(buffer[x]))		{				input_stream.putback(buffer[x]);			// put non alnum back into stream and			buffer[x]='\0';												// chop off non-alnum at end of buffer and terminate			break;		}		x++;	}		// deal with the case where input has been truncated due to finite buffer	if(x==MAX_INPUT_STRING_LENGTH-1 && isalnum(buffer[x]))		cout << "String stream input too long > " << MAX_INPUT_STRING_LENGTH-1 <<						" chars... read in: " << buffer << '\n';	input_string=buffer;	return input_stream;}// Define 10 operators for lexically comparing string_class objects and char arraysint operator==(const string_class &string1, const string_class &string2){	return (strcmp(string1.letters, string2.letters) == 0); }int operator==(const string_class &string1, const char *string2){ return (strcmp(string1.letters, string2) == 0); }int operator==(const char *string1, const string_class &string2){	return (strcmp(string1, string2.letters) == 0); }int operator!=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters) != 0); }int operator!=(const string_class &string1, const char *string2){	return (strcmp(string1.letters, string2) != 0); }int operator!=(const char *string1, const string_class &string2){ return (strcmp(string1, string2.letters) != 0); }int operator>=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)>=0); }int operator<=(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)<=0); }int operator>(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)>0); }int operator<(const string_class &string1, const string_class &string2){ return (strcmp(string1.letters, string2.letters)<0); }// Define function which appends two strings, adding an additional space at the endvoid append_name(string_class &target, const string_class &source){		char *temp= new char [target.string_length+=source.string_length];	temp[0]='\0';		if (target.string_length==1)	{		strcpy (temp, source.letters);		strcat (temp, " ");	}	else	{		strcpy (temp, target.letters);		strcat (temp, source.letters);		strcat (temp, " ");	}			delete[] target.letters;	target.letters=temp;}// Define function which searches for target+' ' within sourcestatus search_string(const string_class &source, const string_class &target){	string_class temp=target.letters;	temp=temp+' ';	if (strstr(source.letters, temp.letters)==NULL)		return ERROR;	else		return SUCCESS;}