/************************************************************************************** * CODE FILE: Data Manager.c++ * PURPOSE	: define members of data_manager class **************************************************************************************/#include "Data Manager.h"// Define CLI using cin/cout streams for accessing data_manager functionsvoid data_manager::interface(){	const int MAX_IO=1000;														// Define Buffer size for input/output	char input_string[MAX_IO]="";											// Initialise primary input char array	char input[MAX_IO]="";														// Initialise second input char array	char output[MAX_IO]="";	string_class name;																// Define name holder					cout << "\nData Manager> ";														// Output manager prompt	while (cin >> input_string)														// Main interface loop	{		if (strcmp(input_string,"help")==0)									// Command displaying commands		{			display_help();			goto prompt2;		}		if (strcmp(input_string,"newrecord")==0)						// Command for adding record		{			cin >> name;																			// Get identifier for record			cin.getline(input, MAX_IO);												// Get record parameters			new_record(name, input);													// Add new record to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delrecord")==0)						// Command for deleting record		{			cin >> name;																			// Get identifier for record			delete_record(name);															// Delete 'name' record from list 			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"records")==0)							// Command to output record list		{			cout << record_list;															// Output record list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newdataset")==0)						// Command for adding data_set		{			string_class record_name;			int length=0;			cin >> name;																			// Get identifier for data_set			cin >> record_name;																// Get record_name for data_set			cin >> length;																		// Get length for data_set			new_data(name, record_name, length);							// Add data_set to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"deldataset")==0)						// Command for deleting data_set		{			cin >> name;																			// Get identifier for data_set			delete_data(name);																// Delete data_set from list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"datas")==0)								// Command to output data_set list		{			cout << data_list;																// Output data_list list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newinput")==0)							// Command for adding set_input		{			cin >> name;																			// Get identifier for set_input			string_class set_input_name;			int lower_i, upper_i;			double start_val, incrementer;			cin >> lower_i >> upper_i >> start_val >> incrementer;	// Get set_input parameters			new_set_input(name, lower_i, upper_i, start_val, incrementer);				// Add to list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delinput")==0)							// Command for deleting set_input		{			cin >> name;																			// Get identigier for set_input			delete_set_input(name);														// Delete set_input from list			goto prompt2;																			// Jump to end of interface loop		}		if (strcmp(input_string,"inputs")==0)								// Command outputs set_input list		{			cout << set_input_list;														// Output set_input list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"newmap")==0)								// Command for adding IO_map		{			cin >> name;																			// Get identifier for IO_map			string_class calc_identifier, output_field, input_fields;			cin.getline(input, MAX_IO);												// Get input fields of IO_map			cout << "now enter output fields\n";			cin.getline(output, MAX_IO);											// Get output fields of IO_map			new_map(name, input, output);											// Add IO_map to map_list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"delmap")==0)								// Command for deleting IO_map		{			cin >> name;																			// Get identifier for IO_map			delete_map(name);																	// Delete IO_map from map_list			goto prompt2;																			// Jump to end of interface loop		}		if (strcmp(input_string,"maps")==0)									// Command to output map_list		{			cout << map_list;																	// Output map_list			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"resetmanager")==0)					// Command to output map_list		{			reset_manager();			goto prompt2;																			// Jump to end of interface loop		}				if (strcmp(input_string,"return")==0)								// Break out of the CLI		{			break;		}				prompt2:																						// End of loop label		cout << "\nData Manager> ";													// Output manager prompt	}}void data_manager::display_help(){	cout << "Commands Available:\n";									// Dump commands to standard output	cout << "\t newrecord <record_name> <field_name>...\n";	cout << "\t delrecord <record_name>\n";	cout << "\t records\n";	cout << "\t newdataset <data_name> <record_name> <length>\n";	cout << "\t deldataset <data_name>\n";	cout << "\t datas\n";	cout << "\t newinput <input_name> lower_index upper_index start_value step\n";	cout << "\t delinput <input_name>\n";	cout << "\t inputs\n";	cout <<		"\t newmap <map_name> <input_field_name>... (newline) <output_field_name>...\n";	cout << "\t delmap <map_name>\n";	cout << "\t maps\n";	cout << "\t resetmanager\n";	cout << "\t help\n";	cout << "\n\n";}// Define method for adding record with identifying name to record_liststatus data_manager::new_record(string_class record_name, string_class record){ // Add to list using ascending lexical order	cout << "name is:" << record_name << ", records are " << record << "\n";	char record_chars[1000];											// Buffer1 to hold record fields as whole	char field_chars[100];												// Buffer2 to hold individual record field		record.string_copy(record_chars);							// Extract char array from record	istrstream record_stream(record_chars);				// Record_stream points to buffer1		ulist<string_object> field_names;							// List for holding all record field names	while(record_stream >> field_chars)						// Get names from record_stream	{	// Add each field name to list using ascending lexical order 		if (field_names.add(string_object(field_chars), DATA, ASCENDING)==ERROR)		{			cout << "ERROR: field name '" << field_chars << "' is not unique to this list\n";			return ERROR;		}	}		// Add record_object to the record_list using ascending lexical order on record_name	if (record_list.add(record_object(record_name, field_names), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: record name is not unique to this list\n";		return ERROR;	}	return SUCCESS;}// Define method for deleting record with identifying name from record_liststatus data_manager::delete_record(string_class name){	if (record_list.remove(name, COUNTER)==ERROR)	{		cout << "ERROR: record name not found\n";		return ERROR;	}	else		return SUCCESS;}// Define method for outputting record_listvoid data_manager::output_record_list(){ cout << record_list; }// Define method for adding data_set with identifying name to data_liststatus data_manager::new_data(string_class data_set_name, string_class record_name,															int length){	record_object record(record_name);	// look up record name to make sure its valid	if (record_list.search_node(record, COUNTER)==ERROR)	{		cout << "ERROR: No such '" << record_name << "' exists - aborted\n";		return ERROR;	}			// Add data_set_obj to data_list, using ascending lexical order on data_set_name	if (data_list.add(data_set_obj(data_set_name, data_set(record, length)),																 COUNTER,ASCENDING)==ERROR)	{		cout << "ERROR: Data object name must be unique to this data manager - aborted\n";		return ERROR;	}	else		return SUCCESS;}// Define method for deleting data_set with identifying name from data_liststatus data_manager::delete_data(string_class name){	if (data_list.remove(name, COUNTER)==ERROR)										// Attempt remove on name	{		cout << "ERROR:'" << name << "' data object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting data_listvoid data_manager::output_data_list(){ cout << data_list; }// Define method check data_set_obj exists in data_set list with 'data_name' name,// check all strings in inputfields are valid data_set field names, check all mapnames// strings match to IO_map_objects in map_list with same names, check all field names// referenced inside each IO_map_object are present in specified data_set and return// pointer to data_set_obj with 'data_name' name in 'target'.status data_manager::check_data_list(string_class data_name,	ulist<string_object> inputfields, ulist<string_object> mapnames, data_set_obj* &target){	data_set_obj data;	int found=0;	if (data_list.reset_transverse()==ERROR)									// Error if data_list is empty	{		cout << "ERROR: data_list empty\n";		return ERROR;	}		// Traverse through data_list	do																		// Search data_list for node indexed by 'data_name'	{		data_list.get_transverse(data);													// Get current data_set_object		if (data.get_index()==data_name)												// If match is found...		{			target=data_list.get_transverse_node_pointer();				// Set pointer to this object			found=1;																							// Set found flag			break;																								// Break out of for loop		}	}	while (data_list.progress_transverse()==SUCCESS);					// Search entire data_list	if (!found)																								// If object not found	{		cout << "ERROR: data object named '" << data_name << "' not found\n";			return ERROR;	}		int width=data.get_width();											// Get number of fields in data_set	string_class *fields=new string_class[width];		// Allocate array to hold field names	data.get_fields(fields);												// Copy data_set field names into array	string_object extracted;	// Check all inputfields strings are valid field names	if (inputfields.reset_transverse()==ERROR)				// Error if inputfields list is empty	{		cout << "ERROR: checking data_set fields against empty list of inputfields\n";		return ERROR;	}		// Traverse through inputfields list	do																								{		inputfields.get_transverse(extracted);										// Get current string object		found=0;		// Extract string from string object and check it matches field name of data_set		for (int field_index=0; field_index<width; field_index++)			if 	(fields[field_index]==extracted.get_data())						// If match is found...			{				found=1;																								// Set found flag				break;																									// Break out of for loop			}		if (!found)																									// If string not found		{			cout << "ERROR: field name '" << extracted.get_data() <<							"' referenced in inputfields not found in data_set fields\n";			return ERROR;		}	}	while (inputfields.progress_transverse()==SUCCESS);				// Search through all strings			// Check mapfields strings contained in 'fields'	string_object string_node;	IO_map_object temp;	if (mapnames.reset_transverse()==SUCCESS)									// If mapnames list not empty	{		// Traverse through entire mapnames list		do		{			mapnames.get_transverse(string_node);									// Get current IO_map object			temp=IO_map_object(string_node.get_data());						// Load with current mapname			// If found, call to search_node loads IO_map of temp with found IO_map			if (map_list.search_node(temp,COUNTER)==ERROR)				// If mapname not valid...			{				cout << "ERROR: map object with name '" << string_node.get_data() <<							"' not found\n";				return ERROR;			}						// Check all input fields of map_object are data_set fields			// Store all input field names in IO_map in 'input_fields' array			int no_of_input_fields=temp.get_number_of_input_fields();			string_class *input_fields=new string_class[no_of_input_fields];			temp.get_input_fields(input_fields);			// Check every field name in input_fields array for being present in data_set			for (int i=0; i<no_of_input_fields; i++)		// For all elements in input_fields			{				found=0;																	// Reset found flag				for (int j=0; j<width; j++)								// For all elements in data_set 'fields'					if (fields[j]==input_fields[i])					// If match found					{						found=1;															// Set found flag						break;																// break out of inner for loop					}				if (!found)																// If input_field not found...				{					cout << "ERROR: input field name '" << extracted.get_data() <<									"' referenced in '" << temp.get_index() <<									"' map object not found in data_set fields\n";					return ERROR;				}			}			// Check all output fields of map_object are data_set fields			// Store all output field names in IO_map in 'output_fields' array			int no_of_output_fields=temp.get_number_of_output_fields();			string_class *output_fields=new string_class[width];			temp.get_output_fields(output_fields);						// Check every field name in output_fields array for being present in data_set			for (int i=0; i<no_of_output_fields; i++)		// For all elements in output_fields			{				found=0;																	// Reset found flag				for (int j=0; j<width; j++)								// For all elements in data_set 'fields'					if (fields[j]==output_fields[i])				// If match found					{						found=1;															// Set found flag						break;																// Break out of inner for loop					}				if (!found)																// If output_field not found				{					cout << "ERROR: input field name '" << extracted.get_data() <<									"' referenced in '" << temp.get_index() <<									"' map object not found in data_set fields\n";					return ERROR;				}			}		}		while (mapnames.progress_transverse()==SUCCESS);// Check all mapnames are in map_list		return SUCCESS;																	// All checked out okay	}	else																														// Empty mapnames list	{		cout << "ERROR: checking map list against empty list of names";		return ERROR;	}}// Define method for adding IO_map with identifying name to map_liststatus data_manager::new_map(string_class map_name, string_class input_fields,														 string_class output_fields){	char input_chars[1000];													// Buffer1 to hold fields as whole	char field_chars[100];													// Buffer2 to hold individual field	char output_chars[1000];												// Buffer1 to hold fields as whole		input_fields.string_copy(input_chars);					// Extract char array from input_fields	istrstream input_stream(input_chars);						// Input_stream points to buffer1		// Process input_fields	ulist<string_object> field_names;								// List for holding all field names	while(input_stream >> field_chars)							// Get names from input_stream	{ // Add each field name to list using ascending lexical order		if (field_names.add(string_object(field_chars), DATA, ASCENDING)==ERROR)		{			cout << "ERROR: input field name is not unique to this list\n";			return ERROR;		}	}	output_fields.string_copy(output_chars);					// Extract char array from input_fields	istrstream input_stream2(output_chars);						// Input_stream points to buffer1		// Process output_fields	ulist<string_object> field_names2;								// List for holding all field names	while(input_stream2 >> field_chars)							// Get names from input_stream	{ // Add each field name to list using ascending lexical order		if (field_names2.add(string_object(field_chars), DATA, ASCENDING)==ERROR)		{			cout << "ERROR: output field name is not unique to this list\n";			return ERROR;		}	}	// Add IO_map_object to the map_list using ascending lexical order on map_name	if (map_list.add(IO_map_object(map_name,			IO_map (field_names , field_names2) ), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: name is not unique to this list\n";		return ERROR;	}	return SUCCESS;}// Define method for deleting IO_map with identifying name from map_liststatus data_manager::delete_map(string_class name){	if (map_list.remove(name, COUNTER)==ERROR)	{		cout << "ERROR: '" << name << "' IO_map object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting map_listvoid data_manager::output_map_list(){	cout << map_list; }// Define method for adding set_input with identifying name to set_input_liststatus data_manager::new_set_input(string_class set_input_name, int lower_i,																	 int upper_i, double start_val, double increment){ // Add to list using ascending lexical order	if (set_input_list.add(set_input_object(set_input_name,				set_input (lower_i, upper_i, start_val, increment)), COUNTER, ASCENDING)==ERROR)	{		cout << "ERROR: name is not unique to this list\n";		return ERROR;	}	else		return SUCCESS;}// Define method for deleting set_input with identifying name from set_input_liststatus data_manager::delete_set_input(string_class set_input_name){	if (set_input_list.remove(set_input_name, COUNTER)==ERROR)	{		cout << "ERROR: '" << set_input_name << "' IO_map object does not exist\n";		return ERROR;	}	return SUCCESS;}// Define method for outputting set_input_listvoid data_manager::output_set_input_list(){	cout << set_input_list; }// Define method for checking all names in sourcelist are names of set_input_objects// in set_input_liststatus data_manager::check_set_input_list(ulist<string_object> sourcelist){	string_object string_node;	if (sourcelist.reset_transverse()==SUCCESS)									// If sourcelist not empty	{		do		{			sourcelist.get_transverse(string_node);									// Get current string object			// Search for set_input_object indexed by string object data in set_input_list			if (set_input_list.search_node				 (set_input_object(string_node.get_data()),COUNTER)==ERROR)				// If not found			{				cout << "ERROR: set_input object with name '" << string_node.get_data() <<							"' not found\n";				return ERROR;			}		}		while (sourcelist.progress_transverse()==SUCCESS);				// Check all string objects		return SUCCESS;																						// All checked out okay.	}	else																												// Sourcelist is empty	{		cout << "ERROR: checking set_input list against empty list of names";		return ERROR;	}}// Define method for clearing all manager listsvoid data_manager::reset_manager(){	record_list.clearlist();										// Clear record list	data_list.clearlist();											// Clear data list	map_list.clearlist();												// Clear map list	set_input_list.clearlist();									// Clear set_input list}