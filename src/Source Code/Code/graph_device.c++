/************************************************************************************** * CODE FILE: graph_device.c++ * PURPOSE	: define members of graph_device class **************************************************************************************/#include "graph_device.h"// Define Default Constructorgraph_device::graph_device(){	mainPtr=NULL;																// All other data members take default values	scaleSize=10;}// Define Parameterized Constructorgraph_device::graph_device(port_info newport, border_info newborder,													 scale_info newhoriz_scale, scale_info newvert_scale,													 range_info newhoriz_range,  range_info newvert_range,													 tick_info newticks){	mainPtr=NULL;																								// Window pointer NULL	set_port(newport);																					// Set port values	set_border(newborder);																			// Set border values	horiz_scale=newhoriz_scale;																	// Set data members	vert_scale=newvert_scale;	horiz_range=newhoriz_range;	vert_range=newvert_range;	ticks=newticks;		scaleSize=10;																								// Preset text size}// Define method for setting scale and range parametersvoid graph_device::set_params(scale_info newhoriz_scale, scale_info newvert_scale,	range_info newhoriz_range,  range_info newvert_range){	horiz_scale=newhoriz_scale;	vert_scale=newvert_scale;	horiz_range=newhoriz_range;	vert_range=newvert_range;}// Define method for hi-liting graphing windowvoid graph_device::showGraph(){	SetPort(mainPtr);																		// Set hi-lited port to graph window	ShowWindow(mainPtr);																// Show window information	SelectWindow(mainPtr);															// Select graphing window}// Define method for clearing graphing windowvoid graph_device::clear_window(){	showGraph();																					// Show graph window	Rect clearRect;	SetRect (&clearRect,0,0,port.width, port.height);			// Define rectangle fitting window	SetPort(mainPtr);																			// Set port to graphing window	EraseRect(&clearRect);																// Erase graphing window}// Define method for clearing graph window, and then drawing fresh axes and scalesvoid graph_device::blank_graph(){	clear_window();	vertical_ticks();	horizontal_ticks();	draw_axes();}// Define method for translating x-axis value to graph window pixel co-ordinatedouble graph_device::translate_x(double x){ return bound.left+(x-horiz_range.Min)*bound.width/horiz_range.range(); }// Define method for translating y-axis value to graph window pixel co-ordinatedouble graph_device::translate_y(double y){	return bound.bottom-(y-vert_range.Min)*bound.height/vert_range.range(); }// Define method for drawing line at (x_axis value)=x on graph in grey (vertical)void graph_device::draw_x_line(double x, long int brightness){		RGBColor grey, current;	grey.red=grey.green=grey.blue=brightness;					// Set to grey - shade of 'brightness'	GetForeColor(&current);														// Preserve current foreground colour	RGBForeColor(&grey);															// Set foreground colour to grey	PenPat(&qd.gray);																	// Use QuickDraw 'gray' as pen pattern	MoveTo(translate_x(x),bound.bottom);							// Move pen to top side of graph	LineTo(translate_x(x),bound.top);									// Draw vertical line down graph	RGBForeColor(&current);														// Restore old foreground colour	PenPat(&qd.black);																// Restore pen pattern to black}// Define method for drawing line at (y_axis value)=y on graph in grey	(horizontal)void graph_device::draw_y_line(double y, long int brightness){	RGBColor grey, current;	grey.red=grey.green=grey.blue=brightness;					// Set to grey - shade of 'brightness'	GetForeColor(&current);														// Preserve current foreground colour	RGBForeColor(&grey);															// Set foreground colour to grey	PenPat(&qd.gray);																	// Use QuickDraw 'gray' as pen pattern	MoveTo(bound.left,translate_y(y));								// Move pen to left side of graph	LineTo(bound.right,translate_y(y));								// Draw horizontal line across graph	RGBForeColor(&current);														// Restore old foreground colour	PenPat(&qd.black);																// Restore pen pattern to black}// Define method for drawing scales and x=0, y=0 lines if within graphing window, and axesvoid graph_device::draw_axes(){	RGBColor zero;	zero.red=60000;															// Set axes colour to dark yellow	zero.green=40000;	zero.blue=70000;		ForeColor(redColor);												// Draw axes in red	MoveTo(bound.left, bound.bottom);						// x-axis always along bottom edge of graph	LineTo(bound.right, bound.bottom);		MoveTo(bound.left, bound.bottom);						// 	y-axis always along left edge of graph	LineTo(bound.left, bound.top);		RGBForeColor(&zero);												// Set foreground colour to yellow	PenPat(&qd.gray);														// Set pen pattern to 'gray'	if (vert_range.Max>0 && vert_range.Min<0)		// If line y=0 is in the graphing window...	{		MoveTo(bound.left,translate_y(0));				// Move to left edge of graph		LineTo(bound.right, translate_y(0));			// Draw y=0 line in yellow	}	if (horiz_range.Max>0 && horiz_range.Min<0)	{		MoveTo(translate_x(0), bound.bottom);			// Move to bottom edge of graph		LineTo(translate_x(0), bound.top);				// Draw x=0 line in yellow	}	ForeColor(blackColor);											// Set foreground colour to black	PenPat(&qd.black);													// Set pen pattern to black}// Define method for drawing tick marks (divisions) and numbering along vertical y-axis// and draw horizontal grid lines over graph area.void graph_device::vertical_ticks(){	ForeColor(redColor);																								// Draw ticks in red	TextSize(scaleSize);	double y=bound.bottom;	// y_incrementer holds number of pixels distance between each tick mark	double y_incrementer=				((vert_scale.MajScale/vert_range.range())/(vert_scale.MinTicks+1))*bound.height;	int count=vert_scale.MinTicks;	double y_val=vert_range.Min;	char y_val_string[20];		do								// Each loop draws a major tick, and an appropriate no. of minor ticks	{		MoveTo(bound.left,y);		LineTo(bound.left-ticks.MajTickSize, y);		// Draw horizontal major tick		Move(-25,scaleSize/2);											// Move to position to place number		sprintf(y_val_string,"%.1f",y_val);					// Store scale number (1 digit after dp)		ForeColor(blackColor);											// Scale numbers in black		DrawString(c2pstr(y_val_string));						// Place scale number on graph		ForeColor(redColor);												// Tick marks in red				if (y<=bound.top+y_incrementer*vert_scale.MinTicks)	// If major tick required 		{			draw_y_line(y_val, 40000);								// Draw major tick horizontal grid line			break;																		// Break out of while loop - all done		}				do																					// Draw minor ticks between major tick		{			y-=y_incrementer;													// Increment y axis value			MoveTo(bound.left,y);											// Move pen to new minor tick position			LineTo(bound.left-ticks.MinTickSize, y);	// Draw minor tick			// Draw minor tick horizontal grid line			draw_y_line(y_val+(count)*vert_scale.MajScale/(vert_scale.MinTicks+1), 55000);		}		while(count--);															// Repeat until count hits 0				count=vert_scale.MinTicks;									// Restore minor tick count to Minticks		draw_y_line(y_val, 40000);									// Draw horizontal major tick grid line		y_val+=vert_scale.MajScale;									// Update scale number for next iteration	}	while(1);																			// Loop forever - breaks out manually	ForeColor(blackColor);												// Set foreground colour to black}// Define method for drawing tick marks (divisions) and numbering along horizontal x-axis// and draw vertical grid lines over graph area.void graph_device::horizontal_ticks(){	ForeColor(redColor);																								// Draw ticks in red	TextSize(scaleSize);		double x=bound.left;	// x_incrementer holds number of pixels distance between each tick mark	double x_incrementer=			((horiz_scale.MajScale/horiz_range.range())/(horiz_scale.MinTicks+1))*bound.width;	int count=horiz_scale.MinTicks;	double x_val=horiz_range.Min;	char x_val_string[20];		do								// Each loop draws a major tick, and an appropriate no. of minor ticks	{		MoveTo(x, bound.bottom);		LineTo(x, bound.bottom+ticks.MajTickSize);			// Draw horizontal major tick				Move(-scaleSize,ticks.MajTickSize+scaleSize/2);	// Move to position to place number		sprintf(x_val_string,"%.1f",x_val);						// Store scale number (1 digit after dp)		ForeColor(blackColor);												// Scale numbers in black		DrawString(c2pstr(x_val_string));							// Place scale number on graph		ForeColor(redColor);													// Tick marks in red				if (x>=bound.right-x_incrementer*horiz_scale.MinTicks)	// If major tick line required		{			draw_x_line(x_val,40000);									// Draw major tick vertical grid line			break;																		// Break out of while loop - all done		}				do																					// Draw minor ticks between major tick		{			x+=x_incrementer;													// Incrementer x axis value			MoveTo(x, bound.bottom);									// Move pen to new minor tick position			LineTo(x, bound.bottom+ticks.MinTickSize);		// Draw minor tick			// Draw minor tick vertical grid line 			draw_x_line(x_val+count*horiz_scale.MajScale/(horiz_scale.MinTicks+1), 55000);		}		while(count--);															// Repeat until count hits 0				count=horiz_scale.MinTicks;									// Restore minor tick count to Minticks		draw_x_line(x_val,40000);										// Draw vertical major tick grid line		x_val+=horiz_scale.MajScale;								// Update scale number for next iteration	}	while(1);																			// Loop forever - breaks out manually	ForeColor(blackColor);												// Set foreground colour to black}// Define method for drawing a cross centred at current pen position, of size 'Width'void graph_device::PlaceCross(int Width){	RGBColor current;	GetForeColor(&current);														// Preserve current foreground colour		ForeColor(greenColor);														// Crosses are green		Move(-Width/2,-Width/2);													// Draw cross	Line(Width, Width);	Move(-Width, 0);	Line(Width, -Width);		Move(-Width/2, Width/2);													// Restore pen back to original pos.		RGBForeColor(&current);														// Restore original foreground colour}// Define size of 'graph port' or graphing window - returns a pointer to the windowvoid graph_device::set_port(port_info newport){	port=newport;	if (mainPtr!=NULL)															// If window already set, deallocate it		CloseWindow(mainPtr);													// MacOS QuickDraw function	// Set windRect to have dimensions equal to port co-ordinates	Rect windRect;	SetRect(&windRect, port.top,port.left, port.top+port.width, port.left+port.height);	// Instantiate window	mainPtr = NewCWindow(nil, &windRect, "\pGraph Title", true, documentProc, 				(WindowPtr) -1, false, 0);		SetPort(mainPtr);																// Set current window to graph window	bound.right=port.width-border.right;													// Recalculate bounds	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}// Define method for setting border info, updating bound info appropriatelyvoid graph_device::set_border(border_info newborder){	border=newborder;	bound.top=border.top;																					// Recalculate all bounds	bound.left=border.left;	bound.right=port.width-border.right;	bound.bottom=port.height-border.bottom;	bound.width=bound.right-bound.left;	bound.height=bound.bottom-bound.top;}// Define methods for setting private data members individuallyvoid graph_device::set_horiz_scales(scale_info newhoriz_scale){ horiz_scale=newhoriz_scale; }void graph_device::set_vert_scales(scale_info newvert_scale){ vert_scale=newvert_scale; }void graph_device::set_horiz_range(range_info newhoriz_range){ horiz_range=newhoriz_range; }void graph_device::set_vert_range(range_info newvert_range){ vert_range=newvert_range; }void graph_device::set_ticks(tick_info newticks){ ticks=newticks; }// Define method for translating x origin offset to graph window pixel co-ordinatedouble graph_device::x_origin(double x){ return bound.left+x; }// Define method for translating y origin offset to graph window pixel co-ordinatedouble graph_device::y_origin(double y){	return bound.bottom-y; }