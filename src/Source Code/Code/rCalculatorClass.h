/************************************************************************************** * HEADER FILE: rCalculatorClass.h * PURPOSE		: declare calculator class **************************************************************************************/ #ifndef _rCalculatorClass_h#define _rCalculatorClass_h#include "rCalculatorUserTypes.h"			 #include "complex.h"#include "complex functions.h"#include "iadditionalmath.h"#include "extraclasses.h"#include "ulist.h"#include "name_object.h"#include "validator.h"class validator;																						// Forward declarationclass calculator{	private:		static int math_function_array_initialised;							// Flag indicating init status		static double (*math_func[256])(double);								// Function pointer look-up		static char terminator_table[256];							// Expression terminator token look-up		static const token_value terminator_tokens[15];					// Terminator tokens		validator *equation_checker;														// Used for validating eqns		int *number_of_errors;																	// Number of errors occurred		calculator_type rank;																		// SUPER/SUB calculator flag		calculator_symbol current_symbol;												// Currently read token		int binding_segment;																		// Current parentheses level		ulist<name_object> *var_list;														// Variable list for calc		ulist<name_object> *equation_list;											// Equation list for calc		istrstream *input_stream;																// Dynamic Input stream		ostrstream *error_stream;																// Dynamic Error stream		char *input_char_array;																	// Feeds dynamic input stream		char *error_string;																			// Output of error stream		void new_error_stream();																// Re-initialise error stream		int auto_verify;																				// Flag for checking eqns				complex level1();																				// Add/Substract Level		complex level2();																				// Multiply/Divide Level		complex level3();																				// Power Level		complex level4();																				// Factorial Level		complex level5();																				// ENG symbols Level		complex primary();																			// Primary Level				complex compound(token_value method);									// Calculate Summation/Prodation		// Retrieve SUM/PROD parameters from input_stream		status get_compound_parameters(token_value method, string_class &variable,																	 int &lower_bound, int &upper_bound);		// Retrieve window parameters from error_stream		status get_window_parameters(string_class &variable, double &lower_bound,																 double &upper_bound);		string_class get_definition();						// Get equation definition from input_stream		static void initialise_math_function_array();						// Called within Constructor		void init_math_array();														// Sets up function pointer look-up		// Apply multiplying factor according to engineering conversion token		complex engineering_conversion(const token_value token, const complex x);		// Check operands for token operation are valid		int invalid_operands(const token_value token, const complex value1,												 const complex value2=complex(0,0));		token_value get_token();													// Retrieve token from input_stream		complex error(const char* s);											// Internal error reporting method		complex error(const string_class s);							// Internal error reporting method		// Constructor used in recursive calculations requiring derivative calculators		calculator(ulist<name_object> *var_list, ulist<name_object> *equation_list,							 ostrstream *errors, int *number_of_errors);		status set_input(string_class input_string);							// Acquire new input stream		status reset_input();																			// Dump input stream			public:			static const token_name token_names[50];						// Tokens processed by calculator		static ulist<name_object> constant_list;						// Generic Constant list		// Initialise generic constant list		static void build_internal_constants(const name_object *constants,const int length);		static int ERROR_STREAM_SIZE;												// Maximum error stream size		calculator();																									// Default Constructor		~calculator();																								// Destructor		calculator(const calculator &original);												// Copy Constructor		calculator& operator=(const calculator &source);							// Overloaded = operator		ulist<name_object>* get_equation_list();						// Return pointer to equation list		ulist<name_object>* get_var_list();									// Return pointer to variable list		complex evaluate(string_class input_string);		// Evaluate input string		string_class flush_errors();										// Return and clear error stream		ostream& peek_errors(ostream& output_stream);	 	// Return error stream through stream		int get_number_of_errors();											// Return no. of errors since clear		void all_clear();																// Clear all variables and equations		status clear_single_memory(string_class name);	// Clear single variable/equation		void auto_verify_off();													// Turn off auto verification		status auto_verify_on();												// Turn on auto verification		void set_validator(validator *checker);					// Setup validating object link		// Output contents of calculator to output_stream		friend ostream& operator<<(ostream& output_stream, const calculator a);		friend complex sqrt_comp(const complex value);						// Set up friend association		friend complex cbrt(const complex value);									// Set up friend association};#endif