/************************************************************************************** * HEADER FILE: complex.c++ * PURPOSE		: define members of complex class **************************************************************************************/#include "complex.h"#include "complex functions.h"// define default constructorcomplex::complex(){	re=0;	im=0;}// define real/imag parameterized constructorcomplex::complex(const double real, const double imag){	re=real;	im=imag;}// define function for setting both real/imag componentsvoid complex::set(const double real, const double imag){	re=real;	im=imag;}// define complex addition 																									(this=this+a)complex& complex::operator+=(const complex a){	re += a.re;	im += a.im;	return *this;}// define complex subtraction 																							(this=this-a)complex& complex::operator-=(const complex a){	re -= a.re;	im -= a.im;	return *this;}// define complex multiplication																						(this=this*a)complex& complex::operator*=(const complex a){	double real = a.re*re - a.im*im;	im = a.im*re + a.re*im;	re = real;	return *this;}// define complex division																									(this=this/a)complex& complex::operator/=(const complex a){	double d=a.re*a.re-a.im*a.im;	double real = (re*a.re+im*a.im)/d;	im = (im*a.re - re*a.im)/d;	re = real;	return *this;}// define complex addition																									(this=a+b)complex operator+(const complex a, const complex b){	return complex(a.re+b.re, a.im+b.im); }// define complex subtraction																								(this=a-b)complex operator-(const complex a, const complex b){	return complex(a.re-b.re, a.im-b.im); }// define complex unary minus 																							(this=-this)complex complex::operator-(){	re=-re;	im=-im;	return *this;}// define complex multiplication																						(this=a*b)complex operator*(const complex a, const complex b){ return complex(a.re*b.re-a.im*b.im, a.im*b.re + a.re*b.im); }// define complex division																									(this=a/b)complex operator/(const complex a, const complex b){	double d=b.re*b.re+b.im*b.im;	return complex((a.re*b.re+a.im*b.im)/d, (a.im*b.re - a.re*b.im)/d);}// define complex power operator																						(this=a^b)complex operator^(const complex a, const complex exponent){	if (a.re>0 && a.im==0 && exponent.im==0)				// calculations using real positive base		return complex (pow(a.re,exponent.re),0);	else																						// complex numbers used otherwise	{		if (a.re==exp(1))															// base=e, use polar complex conversion			return polar_rect(exp(exponent.re), exponent.im);		else																					// otherwise use DeMoivre's Theorem		{			return polar_rect(pow(magnitude(a),exponent.re), arg(a)*exponent.re);		}	}}// define output operator (rectangular form)ostream& operator<<(ostream& output_stream, const complex a){		// Output real and imaginary components in 8 character field,	// using scientific notation	output_stream.width(8);	output_stream.setf(ios::right,ios::adjustfield);	output_stream.setf(ios::scientific,ios::floatfield);	output_stream << a.re << "+";	output_stream.width(8);	output_stream.setf(ios::right,ios::adjustfield);	output_stream.setf(ios::scientific,ios::floatfield);	output_stream << a.im << "j";										// output in 'a+bj' form	return output_stream;}// define input operator (rectangular form)istream& operator>>(istream& input_stream, complex& complex_number){	char j_place_holder;	// expected input in the form 'a+bj'	input_stream >> complex_number.re >> complex_number.im >> j_place_holder;	return input_stream;}