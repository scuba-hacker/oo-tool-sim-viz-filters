/************************************************************************************** * CODE FILE: IO_map.c++ * PURPOSE	: define members of IO_map class **************************************************************************************/#include "IO_map.h"// Define default constructorIO_map::IO_map(){	input_length=0;	input_fields=NULL;	output_length=0;	output_fields=NULL;}// Define parameterized constructorIO_map::IO_map(ulist<string_object> in_fields, ulist<string_object> out_fields){	input_length=output_length=0;												// Initialise lengths to 0		// First deal with in_fields data	do																	// find out how many objects are in the string list	{	input_length++;	}	while (in_fields.progress_transverse()==SUCCESS);		// Progress through entire list	string_object temp_string_object;	input_fields=new string_class[input_length];				// Array holds in_field names	in_fields.reset_transverse();												// Reset to first node in list	for (int i=0; i<input_length; i++)									// Build look-up array:	{																										// maps element number->field name		in_fields.get_transverse(temp_string_object);			// Get current string object		input_fields[i]=temp_string_object.get_data();		in_fields.progress_transverse();									// Progress to next string object	}		// Now deal with out_fields data	do																	// find out how many objects are in the string list	{	output_length++;	}	while (out_fields.progress_transverse()==SUCCESS);	// Progress through entire list	output_fields=new string_class[output_length];			// Array holds in_field names	out_fields.reset_transverse();											// Reset to first node in list	for (int i=0; i<output_length; i++)									// Build look-up array:	{																										// maps element number->field name		out_fields.get_transverse(temp_string_object);		// Get current string object		output_fields[i]=temp_string_object.get_data();		out_fields.progress_transverse();									// Progress to next string object	}}// Define copy constructorIO_map::IO_map(IO_map &original){ *this=original; }// Define assignment of IO_map objects by IO_map objectsIO_map& IO_map::operator=(const IO_map &original){	// Copy across all non-dynamic data...	input_length=original.input_length;	output_length=original.output_length;	input_fields=NULL;	// Now deal with input_fields...	if (original.input_fields!=NULL)															// Copy only if >0 fields	{		input_fields=new string_class[input_length];	// Array maps element index->field name		for (int i=0; i<input_length; i++)						// Copy across all elements of original			input_fields[i]=original.input_fields[i];	}	else		input_fields=NULL;																		// Original has no input_fields	// Now deal with output_fields...	if (original.output_fields!=NULL)												// Copy only if >0 fields	{		output_fields=new string_class[output_length];// Array maps element index->field name		for (int i=0; i<output_length; i++)						// Copy across all elements of original			output_fields[i]=original.output_fields[i];	}	else		output_fields=NULL;																		// Original has no input_fields	return *this;}// Define destructorIO_map::~IO_map(){	delete [] input_fields;	delete [] output_fields;}// Define access functions to private member dataint IO_map::get_number_of_input_fields(){	return input_length; }int IO_map::get_number_of_output_fields(){	return output_length; }void IO_map::get_output_fields(string_class *storage){	if (output_fields!=NULL)													// Refuse access to non-defined array  	{				for (int i=0; i<output_length; i++)							// Make copy of all field elements			storage[i]=output_fields[i];									// for returning in 'storage'	}}void IO_map::get_input_fields(string_class *storage){	if (input_fields!=NULL)														// Refuse access to non-defined array  	{				for (int i=0; i<input_length; i++)							// Make copy of all field elements			storage[i]=input_fields[i];										// for returning in 'storage'	}}// Define overloaded output operator for IO_map objectostream& operator<<(ostream& output_stream, const IO_map output_map){	if (output_map.input_fields!=NULL)					// Refuse output when input fields undefined	{		output_stream << "		  Input Fields: ";		for (int i=0; i<output_map.input_length; i++)			cout << output_map.input_fields[i] << ", ";		output_stream << '\n';		output_stream << "		  Output Fields: ";		for (int i=0; i<output_map.output_length; i++)			cout << output_map.output_fields[i] << ", ";		output_stream << '\n';	}	else		output_stream << "ERROR: IO_map not initialised\n";	return output_stream;	}