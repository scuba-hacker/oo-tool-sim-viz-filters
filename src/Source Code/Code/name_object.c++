/************************************************************************************** * CODE FILE: name_object.c++ * PURPOSE	: define members of name_object class **************************************************************************************/#include "name_object.h"// Define default constructorname_object::name_object(){	next_name_object = NULL;	name=name_object::undefined_index;}// Define constructor using string_class and complex_container to initialisename_object::name_object(const string_class string, const complex_container complex_field){	name = string;	data = complex_field;	next_name_object = NULL;}// Define constructor using char array and complex_container to initialisename_object::name_object(const char *string, const complex_container complex_field){	name = string;	data = complex_field;	next_name_object = NULL;}// Define copy constructorname_object::name_object(const name_object &original){	name=original.name;	data=original.data;	next_name_object=original.next_name_object;}// Define assignment of name_object objects by name_object objectsname_object& name_object::operator=(name_object &source){	name=source.name;	data=source.data;	next_name_object=source.next_name_object;	return *this;}// Define method for extracting index fieldstring_class name_object::get_index(){ return name; }// Define method for setting index fieldstatus name_object::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid name_object::set_to_first_index(){	name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid name_object::set_to_next_index(const string_class ref){ name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare name_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldcomplex_container name_object::get_data(){ return data; }	// Define method for setting data fieldstatus name_object::set_data(const complex_container setting){	data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare name_object::compare_data(const complex_container name1,																	const complex_container name2){ return (compare_containers(name1, name2)); }// Define method for setting pointer fieldvoid name_object::set_pointer_to(name_object *p){ next_name_object=p; }// Define method for extracting pointer fieldname_object* name_object::get_pointer()	{ return next_name_object; }	// Define method for outputting name_object contents on standard outputvoid name_object::print_node(){cout << name << "-> " << data;}// Define methods for accessing public data members inside data field (complex_container)complex name_object::get_complex(){ return data.complex_number; }void name_object::set_complex(const complex new_complex){ data.complex_number=new_complex; }macro_type name_object::get_indicator(){ return data.indicator; }void name_object::set_indicator(const macro_type new_indicator){ data.indicator=new_indicator; }string_class name_object::get_equation(){ return data.equation; }void name_object::set_equation(const string_class new_equation){	data.indicator = EQUATION;	data.equation = new_equation;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, const name_object a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define undefined index as empty stringstring_class name_object::undefined_index="";