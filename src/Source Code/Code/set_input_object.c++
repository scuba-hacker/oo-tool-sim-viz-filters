/************************************************************************************** * CODE FILE: set_input_object.c++ * PURPOSE	: define members of set_input_object class **************************************************************************************/#include "set_input_object.h"// Define default constructorset_input_object::set_input_object()  {	next_set_input_object = NULL;	name=set_input_object::undefined_index;}// Define constructor using string_class to initialiseset_input_object::set_input_object(string_class name_string){	next_set_input_object = NULL;	name=name_string;}// Define constructor using string_class and set_input to initialiseset_input_object::set_input_object(string_class name_string, set_input data){	name=name_string;	load_data=data;	next_set_input_object = NULL;	}// Define copy constructorset_input_object::set_input_object(set_input_object &original){	*this=original; }// Define assignment of set_input_object objects by set_input_object objectsset_input_object& set_input_object::operator=(set_input_object &original){	name=original.name;	load_data=original.load_data;	next_set_input_object = original.next_set_input_object;		return *this;}// Define method for extracting index fieldstring_class set_input_object::get_index(){ return name; }// Define method for setting index fieldstatus set_input_object::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid set_input_object::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid set_input_object::set_to_next_index(const string_class ref){	name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare set_input_object::compare_index(const string_class index1,																				const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldset_input set_input_object::get_data()	{ return load_data; }	// Define method for setting data fieldstatus set_input_object::set_data(set_input setting){		load_data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare set_input_object::compare_data(const set_input name1, const set_input name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;															// Arbitrary ordering for set_input objects}// Define method for setting pointer fieldvoid set_input_object::set_pointer_to(set_input_object *p){ next_set_input_object=p; }// Define method for extracting pointer fieldset_input_object* set_input_object::get_pointer(){ return next_set_input_object; }		// Define method for outputting name_object contents on standard outputvoid set_input_object::print_node(){cout << name << "-> " << load_data;}// Define overloaded output operator for set_input_objectostream& operator<<(ostream& output_stream, set_input_object a){	output_stream << a.name << "->" << a.load_data;	return output_stream;}// Define undefined index as empty stringstring_class set_input_object::undefined_index="";