/************************************************************************************** * CODE FILE: calcobject.c++ * PURPOSE	: define members of calc_object class **************************************************************************************/#include "calcobject.h"// Define default constructorcalc_object::calc_object(){	next_calc_object = NULL;	identifier=calc_object::undefined_index;}// Define constructor using string_class to initialisecalc_object::calc_object(const string_class name){	next_calc_object = NULL;	identifier=name;}// Define copy constructorcalc_object::calc_object(const calc_object &original){	identifier=original.identifier;	data=original.data;	next_calc_object=original.next_calc_object;}// Define assignment of name_object objects by name_object objectscalc_object& calc_object::operator=(calc_object &source){	identifier=source.identifier;	data=source.data;	next_calc_object=source.next_calc_object;	return *this;}// Define method for extracting index fieldstring_class calc_object::get_index(){ return identifier; }// Define method for setting index fieldstatus calc_object::set_index(const string_class setting){	identifier=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid calc_object::set_to_first_index(){ identifier="a"; }// Define method for defining incremental indexing across the list, head->tailvoid calc_object::set_to_next_index(const string_class ref){	identifier=ref+"a";	}// Define method for comparing two index objects - lexical comparison of string_classcompare calc_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldcalculator calc_object::get_data(){ return data; }	// Define method for setting data fieldstatus calc_object::set_data(const calculator setting)	{		data=setting;	return SUCCESS;}	// Define method for comparing two data objectscompare calc_object::compare_data(const calculator calc1, const calculator calc2){#pragma unused (calc1)#pragma unused (calc2)	return (SMALLER);																						// Define arbitrary ordering}// Define method for setting pointer fieldvoid calc_object::set_pointer_to(calc_object *p){	next_calc_object=p; }// Define method for extracting pointer fieldcalc_object* calc_object::get_pointer()	{	return next_calc_object; }	// Define method for outputting name_object contents on standard outputvoid calc_object::print_node(){	cout << "Calculator:" << identifier << "->\n";	cout << "Variable List:\n" << data.get_var_list();	cout << "Equation List:\n" << data.get_equation_list();}// Define overloaded output operator for calc_objectostream& operator<<(ostream& output_stream, calc_object a){	output_stream << "Calculator '" << a.identifier << "' contains:\n" << a.data;	return output_stream;}// Define methods for accessing public data members inside data field (calculator)complex calc_object::evaluate(string_class input_string){ return data.evaluate(input_string); }string_class calc_object::flush_errors(){ return data.flush_errors(); }ostream& calc_object::peek_errors(ostream& output_stream){ return data.peek_errors(output_stream); }int calc_object::get_number_of_errors(){ return data.get_number_of_errors(); }void calc_object::all_clear(){ data.all_clear(); }status calc_object::clear_single_memory(string_class name){ return data.clear_single_memory(name); }void calc_object::auto_verify_off(){ data.auto_verify_off(); }status calc_object::auto_verify_on(){ return data.auto_verify_on(); }void calc_object::set_validator(validator *checker){ data.set_validator(checker); }// Define undefined index as empty stringstring_class calc_object::undefined_index="";