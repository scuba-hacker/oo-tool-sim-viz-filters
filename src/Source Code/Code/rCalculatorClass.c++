/************************************************************************************** * CODE FILE: rCalculatorClass.c++ * PURPOSE	: define members of calculator class **************************************************************************************/#include "rCalculatorClass.h"// Define default constructor (generates a SUPER_CALCULATOR)calculator::calculator(){	equation_checker=NULL;																	// Initialise validator pointer	var_list = new ulist<name_object>;											// Stores this calcs variables	equation_list = new ulist<name_object>;									// Stores this calcs equations	rank=SUPER_CALCULATOR;																	// Indicates top of hierarchy	binding_segment=0;																			// Parenthesis level 0	init_math_array();																			// Initialise mathfunc array	input_stream=NULL;																			// Initialise pointers	input_char_array=NULL;	error_stream=NULL;	error_string=NULL;	number_of_errors=NULL;	auto_verify=1;																					// Auto_verify on as default	new_error_stream();																			// Allocate new error stream}// Define copy constructor using overloaded = operatorcalculator::calculator(const calculator &original){ *this=original; }// Define overloaded = operator, allowing assignment between calculator objectscalculator& calculator::operator=(const calculator &original){	equation_checker=original.equation_checker;							// Use same equation checker	var_list = new ulist<name_object>;											// Allocate new lists	equation_list = new ulist<name_object>;	*var_list=*original.var_list;														// Make copy of lists	*equation_list=*original.equation_list;	rank=original.rank;																			// Duplicate other static data	binding_segment=original.binding_segment;	current_symbol=original.current_symbol;	input_stream=NULL;									// Initialise input/error streams/strings in target	input_char_array=NULL;	error_stream=NULL;	error_string=NULL;	number_of_errors=NULL;		if (strcmp(original.error_string,"")!=0)	// Copy across errors stored in original calc	{		error_string=new char[calculator::ERROR_STREAM_SIZE];		error_stream=new ostrstream(error_string, calculator::ERROR_STREAM_SIZE-1);		(*error_stream) << original.error_string;									// Copy across error string		number_of_errors = new int;																// Instantiate integer		*number_of_errors = *original.number_of_errors;						// Copy number of errors	}	else																								// No errors present in source calc		new_error_stream();															// Allocate new error stream in target	auto_verify=original.auto_verify;									// Copy across auto_verify flag	return *this;}// Define method for deleting error stringstream and allocating new error stringstreamvoid calculator::new_error_stream(){	if (number_of_errors!=NULL)												// If number_of_errors is being used		delete number_of_errors;												// Delete current instance	number_of_errors=new int;													// Allocate new number_of_errors int	*number_of_errors=0;															// Initialise errors to 0	if (error_string!=NULL)																// If error_string is being used		delete[] error_string;															// Delete current instance	error_string=new char[calculator::ERROR_STREAM_SIZE];			// Allocate new error_string	error_string[0]='\0';																			// Initialise error_string	if (error_stream!=NULL)																// If error_stream is being used		delete error_stream;																// Delete current instance																												// Allocate new error_stream	error_stream=new ostrstream(error_string, calculator::ERROR_STREAM_SIZE-1);}// Define method to return current error_string and initialise errors to 0string_class calculator::flush_errors(){	if (rank==SUPER_CALCULATOR)	// Terminate error stream only if this is a super-calculator		(*error_stream) << '\0';																			// Add string terminator	string_class return_string=error_string;									// Backup current error_string	new_error_stream();																				// Re-initialise error_stream	return return_string;																			// Return error_string}// Define method to allow examination of errors without initialising errors to 0ostream& calculator::peek_errors(ostream& output_stream){	if (rank==SUPER_CALCULATOR)	// Terminate error stream only if this is a super-calculator	{		// Get current letter pointer (offset) of error_stream		long offset = (error_stream->rdbuf()->pubseekoff(0,ios::cur, ios::out)).offset();		// Copy all chars up to offset into a new string		if (offset>0)																			// If there are errors to return...		{			char errors[1000];															// Define temporary buffer			memcpy(errors, error_string, offset);						// Error_string not NULL terminated			errors[offset]='\0';														// Add terminating character			output_stream << errors;												// Output error string		}		else			output_stream << "0 errors";										// Output zero error string	}	return output_stream;}// Define PRIVATE constructor - can only be used by a SUPER CALCULATOR calculator object// All calculator objects generated in this way have SUB CALCULATOR rank.calculator::calculator(ulist<name_object> *v_list, ulist<name_object> *exp_list,											 ostrstream *errors, int *number_of_err){	equation_checker=NULL;									// No defining of eqns occurs in sub_calculators	var_list=v_list;												// Point to SUPER CALCULATOR variable list	equation_list=exp_list;									// Point to SUPER CALCULATOR equation list	rank=SUB_CALCULATOR;										// All of these are SUB CALCULATORS	binding_segment=0;											// Initialise parentheses level to 0	input_stream = NULL;										// Initialise input stream/string	input_char_array=NULL;	error_stream=errors;										// Write all errors to SUPER CALC error stream	number_of_errors=number_of_err;					// Inherit number of errors from SUPER CALC	error_string=NULL;											// No private error_string - ref SUPER CALC	auto_verify=0;													// No assigning of eqn can be done in SUB CALC}// Define method for initialising math func array - determine if it has been set alreadyvoid calculator::init_math_array(){	if (math_function_array_initialised==0)													// If not already set...	{		math_function_array_initialised=1;														// Flag as set		initialise_math_function_array();															// Call init array	}}// Define destructor functioncalculator::~calculator(){	if (rank==SUPER_CALCULATOR)	// Dynamic allocation of lists/streams occurs only in SUPER	{		delete var_list;														// Delete all previously allocated objects		delete equation_list;		delete[] error_string;		delete error_stream;		delete number_of_errors;	}	else	{		// No deleting to do as SUB CALCULATORS references dynamic objects in SUPER CALC		// which must stay in existence after all SUB CALCULATORS have deceased	}}// Define method for initialising input_stream to point to new input_stringstatus calculator::set_input(string_class input_string){	if (input_stream!=NULL)														// If input_stream already defined...		reset_input();																	// Deallocate current input stream	input_char_array=new char[input_string.length()+1];		// Allocate new input stream	input_string.string_copy(input_char_array);						// Make char array copy in string	input_stream = new istrstream(input_char_array);			// Input_stream acts on char array	return SUCCESS;}// Define method for initialising input_stream to point to NULL (ie stream unused)status calculator::reset_input(){	if (input_stream!=NULL)														// If input_stream already defined	{		delete input_stream;														// Deallocate and NULLify stream		input_stream=NULL;		delete[] input_char_array;											// Deallocate and NULLify char array		input_char_array=NULL;		return SUCCESS;	}	else																			// Can't reset a stream that is already reset	{		cout << "WARNING - trying to reset a non-set input stream\n";		return ERROR;	}}// Define method for evaluating the complex number result of expression in input_stringcomplex calculator::evaluate(string_class input_string){		set_input(input_string);										// Set input stream to process input_string	current_symbol.clear();											// Initialise current token symbol	complex complex_result;											// Used to hold complex result of evaluate	while (*input_stream)												// While end of input_stream not reached	{		get_token();															// Get the next token in input_stream		if (current_symbol.token == END)					// If token signifies END of stream, break			break;		if (current_symbol.token == PRINT)				// If token signifies PRINT, break			continue;		complex_result=level1();									// Call LEVEL1 func to evaluate input	}	// Evaluation of input_string complete...	if (*number_of_errors>0)										// If errors occurred output to cout...		cout << "Number_of_errors was " << (int) *number_of_errors << '\n';	reset_input();															// Reset the input_stream	return complex_result;											// Return complex result derived from input}// Define LEVEL1 precedence function, processes PLUS/MINUS tokenscomplex calculator::level1(){	complex left = level2();																			// Call LEVEL2 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case PLUS:																								// ADDITION found				if (get_token()==END)																		// Detect 'a+' error					return error("Incomplete binary operation");				left += level2();																				// Compute addition				break;																									// Break out of loop			case MINUS:																								// SUBTRACTION found				if (get_token()==END)																		// Detect 'a-' error					return error("Incomplete binary operation");									left -= level2();																				// Compute subtraction				break;																									// Break out of loop			default:													// This level does not process the current token				return left;		}}// Define LEVEL2 precedence function, processes MUL/DIV tokenscomplex calculator::level2(){	complex left = level3();																			// Call LEVEL3 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case MUL:																									// MULTIPLICATION found				if (get_token()==END)																		// Detect 'a*' error					return error("Incomplete binary operation");				left *= level3();																				// Compute multiplication				break;																									// Break out of loop			case DIV:																									// DIVISION found			{				if (get_token()==END)																		// Detect 'a/' error					return error("Incomplete binary operation");				complex divisor = level3();															// Read in divisor				if (invalid_operands(DIV, divisor))											// Check divisor					return error("divide by 0");				left = left / divisor;																	// Compute division				break;																									// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL3 precedence function, processes POW/ROOTX/LOGX tokenscomplex calculator::level3(){	complex left = level4();																			// Call LEVEL4 evaluation	for (;;)																											// Loop Forever		switch (current_symbol.token)		{			case POW:																									// POWER found			{				if (get_token()==END)																		// Detect 'a^' error					return error("Incomplete binary operation");				complex exponent = level4();														// Read in exponent				if (invalid_operands(POW, left, exponent))							// Check exponent					return error("invalid POWER operands");				left = left^exponent;																		// Compute power result				break;																									// Break out of loop			}			case ROOTX:																								// Xth ROOT found			{				if (get_token()==END)																		// Detect 'a rootx' error					return error("Incomplete binary operation");				complex base = level3();												// Read in base from input				if (invalid_operands(ROOTX, left, base))				// Check base & left operand					return error("invalid ROOTX operands");				left = base^(complex (1/left.re, 0));						// Compute xth root result				break;																					// Break out of loop			}			case LOGX:			{				if (get_token()==END)														// Detect 'a logx' error					return error("Incomplete binary operation");				complex value = level3();												// Read in no. to take log of				if (invalid_operands(LOGX, left, value))				// Check both operands					return error("invalid LOGX operands");				left.re = logx(value.re, left.re);							// Compute Xth log				break;																					// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL4 precedence function, processes FACTORIAL tokencomplex calculator::level4(){	complex left = level5();																	// Call LEVEL5 evaluation	for (;;)																									// Loop forever		switch (current_symbol.token)		{			case FACTORIAL:																				// FACTORIAL found			{				get_token();																		// Skip over FACTORIAL symbol				if (invalid_operands(FACTORIAL, left))					// Check operand					return error("invalid FACTORIAL operand: non-integer / non-real");				left.re = factorial(left.re);										// Compute factorial				break;																					// Break out of loop			}			default:														// This level does not process the current token				return left;		}}// Define LEVEL5 precedence function, processes ENGINEERING SYMBOL tokenscomplex calculator::level5(){	complex left = primary();																	// Call PRIMARY evaluation	for (;;)																									// Loop forever		switch (current_symbol.token)		{			case MILLI:																						// ENG found			case MICRO:			case NANO:			case PICO:			case FEMTO:			case KILO:			case MEGA:			case GIGA:			case TERA:			case PETA:			case EXA:			{				token_value token_found=current_symbol.token;				// Store current token				get_token();																				// Skip over ENG symbol				left = engineering_conversion(token_found,left);		// Evaluate result				break;			}			default:				return left;		}}// Define PRIMARY precedence function, processes tokens with highest precedence, ie// numbers, names, unary minus, Parentheses, Modulus, Square Root, Cube Root, Trig Fns,// Compound fns etc. TOKENs processed : NUMBER, NAME, MINUS, LP, RP, LM, RM, SQRT, CBRT,// SIN, COS, TAN, ASIN, ACOS, ATAN, SINH, COSH, TANH, ASINH, ACOSH, ATANH, LN, LOG10,// LOG2, ARGUMENT, REAL, IMAGINARY, WINDOW, SUMMATION, PRODATION, ENDcomplex calculator::primary(){	// This function deals with unary operators, and all may form the start of an equation	switch (current_symbol.token)	{		case NUMBER:																							// Digit read in			get_token();																						// Get next token			if (current_symbol.token==NUMBER || current_symbol.token==NAME)	// Check errors				error ("Name/Number cannot proceed a Number\n");			return current_symbol.number_value;											// RETURN digit read in					case NAME:																								// Name read in		{				complex_container new_name;			complex temp_complex;			string_class temp_string;			complex_container temp_name;			int constant_found=0;													// Flag signifies NAME matches const			int variable_found=0;													// Flag signifies NAME matches var			int equation_found=0;													// Flag signifies NAME matches eqn			temp_string=current_symbol.name_string;				// Backup NAME read in			name_object temp_name_object(temp_string);		// Generate Name object holding NAME			status name_known;														// Flag signifies if NAME in a list						// ******** FIND OUT IF NAME REFERENCES AN ITEM STORED IN A CALCULATOR LIST ********			// First search the equation_list, then search the var_list, then			// search the constant_list for a match to NAME.			// If the search is successful, the corresponding data associated with NAME is			// loaded from the list node into the DATA field of temp_name_object.			if (equation_list->search_node(temp_name_object, COUNTER)==ERROR)		// NAME not eqn				if(var_list->search_node(temp_name_object, COUNTER)==ERROR)				// NAME not var				{					if (constant_list.search_node(temp_name_object, COUNTER)==ERROR)// NAMEnot const						name_known=ERROR;												// NAME not stored in this calculator					else					{						name_known=SUCCESS;											// NAME is a constant						constant_found=1;												// Flag CONSTANT found					}				}					else				{					name_known=SUCCESS;												// NAME is a variable					variable_found=1;													// Flag VARIABLE found				}			else			{				name_known=SUCCESS;													// NAME is an equation				equation_found=1;														// Flag EQUATION found			}						// ********* DETERMINE IF THIS IS AN ASSIGNMENT OR A REFERENCE TO NAME *************			switch(get_token())																				// Get next token on input			{				case NAME:																		// NAME/NUMBER cannot proceed a NAME				case NUMBER:					error ("Name/Number cannot proceed a Name\n");					return complex(0,0);												// RETURN null result					break;									case ASSIGN_CONSTANT:									// Treat NAME as VARIABLE, and do assignment				{					if (equation_found==1)									// If name already used for equation...					{						error ("Illegal Assignment to equation name\n");						return complex(0,0);									// RETURN null result					}					if (constant_found==1)									// If name already used for constant...					{						error ("Illegal Assignment to Constant");						return complex(0,0);									// RETURN null result					}										get_token();																					// Get next token on input					int old_errors=*number_of_errors;								// Backup number_of_errors value					temp_complex=level1();											// Get right hand side of assignment					if (*number_of_errors==old_errors)			// If no errors on right-side of assign					{																				// add NAME assignment to var list...						temp_name_object.set_indicator(CONSTANT);				// Storing a constant number						temp_name_object.set_complex(temp_complex);			// Set complex number field						// NOTE: if NAME already appears on var list, the complex number associated						// with it will be updated appropriately. One name_object on ulist will have						// NAME identifier after this function call.						var_list->maintain(temp_name_object, COUNTER, ASCENDING);	// Add to list					}					else																				// ERRORS found on RHS of assignment						error ("Right hand side of assignment is faulty");					return temp_complex;												// Return right hand side of assign					break;				}									case DEFINE_EQUATION:									// Treat NAME as EQUATION, and do assignment				{					if (variable_found==1)									// If name already used for variable...					{						error ("Illegal tagging of variable name to equation\n");						return complex(0,0);									// RETURN null result					}					if (constant_found==1)									// If name already used for constant...					{						error ("Illegal tagging of constant to definition");						return complex(0,0);									// RETURN null result					}										// Get remainder of input as string and store in definition_string...					string_class definition_string=get_definition();					temp_name_object.set_indicator(EQUATION);					// Storing an equation string 					temp_name_object.set_equation(definition_string);						// Set string field					equation_list->maintain(temp_name_object, COUNTER, ASCENDING);	// Add to list					// NOTE: if NAME already appears on eqn list, the string associated					// with it will be updated appropriately. One name_object on ulist will have					// NAME identifier after this function call.					// If the new equation causes a circular definition and auto_verify is on,					/// remove it from eqn list...					if (auto_verify==1 && equation_checker!=NULL &&							equation_checker->validate(this)==ERROR)					{						equation_list->remove(temp_name_object, COUNTER);					// Remove NAME node						string_class err("Circular equation not stored - error trace '");						err=err+equation_checker->error_trace+"'\n";					// Return error trace						error(err);																						// Report error message					}					return complex (0,0);																		// Return NULL result					break;				}								default:									// NAME is being used as a REFERENCE - look up its value				{						if (name_known==ERROR)							// NAME not present in const/var/eqn list...					{						char error_string[100]="'";						temp_string.string_copy(error_string+1);						strcat(error_string, "'  Name not found");						error (error_string);																		// Report error						return complex (0,0);																		// Return NULL result					}					else																// NAME present in const/var/eqn list					{						switch (temp_name_object.get_indicator())		// Find out if var/eqn						{							case CONSTANT:													// NAME is a constant complex number								return temp_name_object.get_complex();				// Return associated number							case EQUATION:											// NAME is references an equation string							{								string_class equation(temp_name_object.get_equation());	// Get eqn string								// Next, we need a new calculator to do the evaluation								{									complex sub_output;							// Store evaluation from sub_calculator									// Create new calculator to evaluate equation string, pass references									// to var/eqn lists and error stream/string.									calculator *sub_calculator=new calculator(var_list, equation_list,																												 error_stream, number_of_errors);									sub_output=sub_calculator->evaluate(equation);	// Evaluate eqn string									delete sub_calculator;													// Delete sub_calc.									return sub_output;						// RETURN evaluation result from sub calc								}								break;							}							default:								return error ("Illegal enumeration value for macro_indicator");						}					}					break;				}			}		}		// NOTE: at this point current_symbol.token has been set to the next symbol because		// of the get_token() call in the previous switch statement.		case MINUS:																										// Unary MINUS read in			get_token();																								// Get next token			return -primary();											// Calculate next operand and take negative					case LP:																									// Left parenthesis read in		{			binding_segment++;																		// Increase parenthesis level			get_token();																					// Get next token from input			complex expression_value = level1();									// Evaluate up to Right Paren.			if (current_symbol.token != RP)												// If No Right Parenthesis...			{				binding_segment=0;																	// Reset parenthesis level				return error(") expected");													// RETURN ERROR			}			get_token();																					// Get next token from input			binding_segment--;																		// Decrease parenthesis level			return expression_value;								// RETURN complex number inside parentheses		}		case LM:																							// Left Modulus operator read in 		{			binding_segment++;																	// Increase parenthesis level			get_token();																				// Get next token from input			complex expression_value = level1();								// Evaluate up to right modulus			if (current_symbol.token != RM)											// If No right modulus...			{				binding_segment=0;																// Reset parenthesis level				return error("] expected");												// RETURN ERROR			}			get_token();																				// Get next token from input			binding_segment--;																	// Decrement parenthesis level			// Take complex modulus of expression inside modulus brackets			expression_value.set(magnitude(expression_value),0);			return expression_value;														// Return modulus value		}				case SQRT:																							// Square Root token read in		{			get_token();																					// Get first token of operand			complex equation = level3();													// Evaluate operand			if (invalid_operands(SQRT, equation))									// Check for invalid operand				return error("invalid SQRT");												// RETURN error			return sqrt_comp(equation);														// Return complex square root.		}		case CBRT:																							// Cube Root token read in		{			get_token();																					// Get first token of operand			complex equation = level3();													// Evaluate operand			if (invalid_operands(CBRT, equation))									// Check for invalid operand				return error("invalid CBRT");												// RETURN error			return cbrt(equation);																// Return complex cube root.		}				case SIN:																								// Trig function token read in		case COS:		case TAN:		case ASIN:		case ACOS:		case ATAN:		case SINH:		case COSH:		case TANH:		case ASINH:		case ACOSH:		case ATANH:		case LN:		case LOG10:		case LOG2:		{			token_value math_fn_requested=current_symbol.token;		// Backup trig token read in			get_token();																					// Get first token of operand			complex math_func_parameter = level3();								// Evaluate operand			if (invalid_operands(math_fn_requested, math_func_parameter))	// Check operand				return error("invalid SQRT/CBRT/SIN/COS/TAN/SINH/COSH/TANH/ASIN/ACOS/ATAN/ASINH/ACOSH/ATANH/LN/LOG10/LOG2 operand");			// Use math_func look up table of math function pointers to call correct math			// function, and evaluate result of applying operand to that function.			return complex ( (*(math_func[(unsigned char)math_fn_requested]))												 (math_func_parameter.re), 0);		}				case ARGUMENT:																			// Complex argument token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaluate operand			return complex (arg(complex_number),0);						// Calculate and return argument		}				case REAL:																					// Real token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaulate operand			return complex (complex_number.re,0);							// Return real part of operand		}		case IMAGINARY:																			// Imag token read in		{			get_token();																			// Get first token of operand			complex complex_number=level3();									// Evaluate operand			return complex (complex_number.im,0);							// Return imag part of operand		}				case WINDOW:																				// Window function token read in		{			double lower_bound, upper_bound;									// Used to store window limits			string_class variable;														// Variable name to window			// Get window parameters from input, if error occurs then return NULL result			if (get_window_parameters(variable, lower_bound, upper_bound)==ERROR)				return complex (0,0);			current_symbol.token=NAME;											// Prime current_symbol.token			current_symbol.name_string=variable;						// Prime current_symbol.name_string			complex complex_number=primary();								// Evaluate value of NAME			// If result is within bound, then return real part of result...			if (complex_number.re>=lower_bound && complex_number.re<=upper_bound)				return complex (1, 0);			else 				return complex (0,0);				// otherwise result is outside window - return 0		}				case SUMMATION:																						// Summation token read in			return compound(PLUS);																	// Return summation result.		case PRODATION:																						// Prodation token read in.			return compound(MUL);																		// Return prodation result.		case END:																									// END of input token read.			return complex (0,0);																		// RETURN null result		default:																									// No primary token found			return error("primary expected");												// Report error	}}// Define method which reads characters from input_stream, and interprets these as// tokens - storing approriate token name in current_symbol.token_value calculator::get_token(){	char input_char;	// Read token from input stream.	do	{		if ( !(*input_stream).get(input_char)) 											// End of input reached...		{			// permitted tokens  at this point are: (all tokens in terminator tokens table)			if (binding_segment<=0 &&												// Look up token in terminator table					terminator_table[(unsigned char)current_symbol.token]!='!')				error ("Illegal Terminating Token\n");			return current_symbol.token = END;		}	}	while (input_char != '\n' && isspace(input_char));				// Skip white space except \n		switch (input_char)													// Input char holds the single token read in	{		case ';':		case '\n':			return current_symbol.token=PRINT;										// Indicates end of equation		case '!':		// Factorial		case '^':		// Power		case '@':		// Square Root		case '£':		// Cube Root		case '$':		// Xth Root		case '¡':		// Sine		case '™':		// Cosine		case '#':		// Tangent		case '~':		// Hyperbolic Sine		case 'Ω':		// Hyperbolic Cosine		case '≈':		// Hyberbolic Tangent		case '¢':		// ArcSine		case '∞':		// ArcCosine		case '§':		// ArcTangent		case 'ç':		// Hyperbolic ArcSine		case '√':		// Hyperbolic ArcCosine		case '∫':		// Hyberbolic ArcTangent		case '¶':		// Natural Logarithm		case '•':		// Logarithm to Base 10		case 'ª':		// Logarithm to Base 2		case 'º':		// Logarithm to any Base		case '≠':		// Complex argument		case '*':		// Multiply		case '/':		// Divide		case '+':		// Add		case '-':		// Minus		case '(':		// Left Parenthesis		case ')':		// Right Parenthesis		case '[':		// Modulus start		case ']':		// Modulus end		case '=':		// Assign constant		case ':':		// Define equation		case 'œ':		// MILLI		case '∑':		// MICRO		case '®':		// NANO		case '†':		// PICO		case '¥':		// FEMTO		case 'å':		// KILO		case 'ß':		// MEGA		case '∂':		// GIGA		case 'ƒ':		// TERA		case '©':		// PETA		case '∆':		// EXA		case '¬':		// SUMMATION		case '∏':		// PRODATION		case ',':		// COMMA operator (used in summation/prodation)		case '≤':		// REAL		case '≥':		// IMAGINARY		case '÷':		// WINDOW			return current_symbol.token=token_value(input_char);// store token and return symbol					case '0': case '1': case '2': case '3': case '4': 		// Digit/Decimal point read in		case '5': case '6': case '7': case '8': case '9':		case '.':		{			(*input_stream).putback(input_char);								// Putback last char to stream			(*input_stream) >> current_symbol.number_value.re;	// Read whole number as a double			return current_symbol.token=NUMBER;									// Return NUMBER		}		default:			if (isalpha(input_char))														// NAME is being read in			{				string_class temp;				*input_stream->putback(input_char);								// Putback last char to stream				*input_stream >> current_symbol.name_string;			// Read string from stream 				return current_symbol.token=NAME;									// Return NAME			}			error ("bad token");																// Undefined token read in			return current_symbol.token=PRINT;									// RETURN NULL result	}}// Define method for reading in parameters for SUMMATION/PRODATION from input_streamstatus calculator::get_compound_parameters(token_value method, string_class &variable,																					 int &lower_bound, int &upper_bound){	lower_bound=0;	string_class error_string;												// Holds errors occurring in this fn.	switch (method)	{		case PLUS:			error_string="SUMMATION: ";										// SUMMATION parameters to be read			lower_bound=0;																// Define lower bound for variable			break;		case MUL:			error_string="PRODATION: ";										// PRODATION parameters to be read			lower_bound=1;																// Define lower bound for variable			break;		default:			error ("Illegal Compound method");			return ERROR;			break;	}	// 1)	read in- '(' '<variable_name>' ',' '<upperbound>' ')'	get_token();	if (current_symbol.token==LP)													// If Left Parenthesis read in	{		get_token();																				// Get next token		if (current_symbol.token==NAME)											// If variable name read in		{			variable=current_symbol.name_string;							// Backup variable name			get_token();			if (current_symbol.token==COMMA)									// If comma read in			{				get_token();				upper_bound=level1().re;							// Read in upper_bound - keep real component				// Note a get_token operation has been done by level1()				if (current_symbol.token!=RP)										// If Right Parenthesis not read				{	// Then lower bound & upper bound specified, requires COMMA followed by NUMBER					if (current_symbol.token==COMMA)							// If COMMA read in					{						get_token();						lower_bound=upper_bound;								// Accept first NUMBER as lower_bound						upper_bound=level1().re;			// Read in new upper_bound - keep real component						// note a get_token operation has been done by level1()						if (current_symbol.token!=RP)								// If no Right Parenthesis read in						{							error (error_string+"illegal syntax - right parenthesis absent");							return ERROR;						}						else						{							if (lower_bound>upper_bound)									// If bounds badly ordered...							{								error (error_string+"illegal bounds - lower_bound>upper_bound");								return ERROR;							}							else											// Both lower and upper bounds have been specified							{								// All summation/prodation parameters stored and validated								return SUCCESS;							}						}					}					else																								// COMMA missing from input					{						error (error_string+"illegal syntax - comma absent/right parenthesis absent");						return ERROR;					}				}									else																				// Only upper bound has been specified				{						// All parameters read in ok					if (lower_bound>upper_bound)											// If bounds badly ordered...					{						error (error_string+"illegal bounds - lower_bound>upper_bound");						return ERROR;					}					else					{						// All summation/prodation parameters stored and validated						return SUCCESS;					}				}			}			else																									// COMMA missing from input			{				error (error_string+"illegal syntax - comma absent");				return ERROR;			}		}		else																										// Variable name missing		{			error (error_string+"illegal syntax - variable name absent");			return ERROR;		}	}	else																											// Left Parenthesis missing	{		error (error_string+"illegal syntax - left parenthesis absent");		return ERROR;	}}// Define method for reading in parameters for window operation from input_streamstatus calculator::get_window_parameters(string_class &variable, double &lower_bound,																				 double &upper_bound){	lower_bound=0;	upper_bound=0;	string_class error_string;	get_token();	if (current_symbol.token==LP)														// If Left Parenthesis read in	{		get_token();																					// Get next token		if (current_symbol.token==NAME)												// If variable name read in		{			variable=current_symbol.name_string;								// Backup variable name			get_token();			if (current_symbol.token==COMMA)										// If comma read in			{				get_token();				lower_bound=level1().re;							// Read in lower_bound - keep real component				if (current_symbol.token==COMMA)									// If COMMA read in				{					get_token();					upper_bound=level1().re;				// Read in new upper_bound - keep real component					// Note a get_token operation has been done by level1()					if (current_symbol.token!=RP)										// If right parenthesis not read					{						error (error_string+"illegal syntax - right parenthesis absent");						return ERROR;					}					else					{						if (lower_bound>upper_bound)										// If bounds badly ordered...						{							error (error_string+"illegal bounds - lower_bound>upper_bound");							return ERROR;						}						else						{							// All window parameters stored and validated							return SUCCESS;						}					}				}				else																									// COMMA missing from input				{					error (error_string+"illegal syntax - comma absent absent");					return ERROR;				}							}			else																										// COMMA missing from input			{				error (error_string+"illegal syntax - comma absent absent");				return ERROR;			}		}						else																											// Variable name missing		{			error (error_string+"illegal syntax - variable name absent");			return ERROR;		}	}	else																												// Left Parenthesis missing	{		error (error_string+"illegal syntax - left parenthesis absent");		return ERROR;	}}// Define method for calculating SUMMATION/PRODATION of expression, with one variable// ranged between a lower and upper bound.complex calculator::compound(token_value method){	string_class variable, error_string;	int lower_bound;	int upper_bound;	complex total;	// Retrieve parameters from input_stream.	if (get_compound_parameters(method, variable, lower_bound, upper_bound)==ERROR)		return complex (0,0);																						// RETURN NULL result	switch (method)																					// Initialise accumulated total	{		case PLUS:																						// SUMMATION requires 0 start			total=complex(0,0);			break;		case MUL:																							// PRODATION requires 1 start			total=complex(1,0);			break;		default:			error ("Illegal Compound method");			return complex (0,0);			break;	}	// 1) Make sure the variable name specified is not an equation name	if (equation_list->search_node(name_object(variable), COUNTER)==SUCCESS)	{		cout << "cack name is " << variable << "\n";		error ("Illegal compound function variable name - clashes with valid equation name");		return complex(0,0);																						// RETURN NULL result	}		// 2)	Record current offset position in input_array so that we may return here again,	//    for multiple evaluations.	long offset = (input_stream->rdbuf()->pubseekoff(0,ios::cur, ios::in)).offset();	char *expression_start=input_char_array+offset;		// Set pointer to start of expression	name_object temp_name_object=name_object(variable);		// 3) Now carry out required number of calculations, adjusting 'variable' value	//    appropriately before each loop. After each evaluation must make a new input_stream	//    pointing to character at expression_start.	for (int i=lower_bound; i<=upper_bound; i++)	{		get_token();																				// Get next token		temp_name_object.set_complex(complex(i,0));					// Variable set for this iteration		var_list->maintain(temp_name_object, COUNTER, ASCENDING);			// Update variable list		switch (method)		{			case PLUS:																									// Do a SUMMATION				total=total+level2();																			// SUM result to total				break;			case MUL:																										// Do a PRODATION				total=total*level2();																			// TIMES result to total				break;			default:				break;		}		if (i!=upper_bound)													// If FOR not finishing, need a new stream		{			delete input_stream;			// Make new stream pointing to expression_start			input_stream = new istrstream(expression_start);		}	}	return total;																			// Return total of SUMMATION/PRODATION}// Define method for storing remainder of input_stream into a string.string_class calculator::get_definition(){		string_class definition_string;	char input_char;	do	{		if (!(*input_stream).get(input_char))					// Break if end of input_stream reached			break;		definition_string=definition_string+input_char;		// Append char to definition_string	}	while (input_char!=(char)END && input_char!=(char)PRINT); // Continue until end reached	return definition_string;																		// RETURN the string}// Define method for initialising math_func look-up table with math function pointers// and terminator table with terminator tokens.void calculator::initialise_math_function_array(){	math_func[(unsigned char)SIN]=&sin;	math_func[(unsigned char)COS]=&cos;	math_func[(unsigned char)TAN]=&tan;	math_func[(unsigned char)ASIN]=&asin;	math_func[(unsigned char)ACOS]=&acos;	math_func[(unsigned char)ATAN]=&atan;	math_func[(unsigned char)SINH]=&sinh;	math_func[(unsigned char)COSH]=&cosh;	math_func[(unsigned char)TANH]=&tanh;	math_func[(unsigned char)ASINH]=&asinh;	math_func[(unsigned char)ACOSH]=&acosh;	math_func[(unsigned char)ATANH]=&atanh;	math_func[(unsigned char)LN]=&log;	math_func[(unsigned char)LOG10]=&log10;	math_func[(unsigned char)LOG2]=&log2;	for (int i=0; i<15; i++)		terminator_table[(unsigned char)terminator_tokens[i]]='!';}// Define method for applying engineering conversion to complex number.complex calculator::engineering_conversion(const token_value token, const complex x){	int multiplier=0;	switch (token)	{		case MILLI:			multiplier=-3;																// x10^-3			break;		case MICRO:			multiplier=-6;																// x10^-6			break;		case NANO:			multiplier=-9;																// x10^-9			break;		case PICO:			multiplier=-12;																// x10^-12			break;		case FEMTO:			multiplier=-15;																// x10^-15			break;		case KILO:			multiplier=3;																	// x10^-3			break;		case MEGA:			multiplier=6;																	// x10^6			break;		case GIGA:			multiplier=9;																	// x10^9			break;		case TERA:			multiplier=12;																// x10^12			break;		case PETA:			multiplier=15;																// x10^15			break;		case EXA:			multiplier=18;																// x10^18			break;		default:			return error("Unsuitable token passed to engineering conversion");	}	// Multiply complex number x by appropriate power of 10	return complex ((x.re*pow(10,multiplier)), (x.im*pow(10,multiplier)));}// Define method for determining if operands are invalid for particular tokens.int calculator::invalid_operands(const token_value token, const complex value1,																 const complex value2){	// Functions which can accept complex numbers (.im!=0)	switch (token)	{		case DIV:																			// DIVISION:			return (value1.re==0 && value1.im==0);			// prevent (a+bj)/(0+0j)		case POW:																			// POWER:			return (value1.re==0 && value1.im==0 && value2.re==0 || // prevent (0+0j)^0						 (value1.re!=exp(1) && value2.im!=0));			  // prevent a^(a+bj) iff a!=exp		case SQRT:																		// SQUARE ROOT		case CBRT:																		// CUBE ROOT			return 0;																		// No restrictions		case ROOTX:																		// Xth root			return (value1.re==0);											// Prevent 0th root					default:											// Check that complex number not being given to fn below			if (value1.im!=0 || value2.im!=0)				return 1;																			// ERROR complex number being used	}		// Functions which cannot accept complex numbers (.im==0)	switch (token)	{		case FACTORIAL:			return value1.re!=(int)value1.re || value1.re<0;				// Must be non-negative int		case TAN:			return !(fmod(value1.re,pi/2) != 0.0);									// Prevent tan 90, etc		case ASIN:		case ACOS:			return !(value1.re>=-1 && value1.re<=1);								// Must be in -1 -> 1		case ACOSH:			return !(value1.re>=1);																	// Must be >=1		case ATANH:			return !(value1.re>-1 && value1.re<1);									// Must be in -1 -> 1		case LN:																									// Natural Log		case LOG10:																								// Base 10 Log		case LOG2:																								// Base 2 Log			return !(value1.re>0);																	// Must be >0		case LOGX:																								// Base X Log			return !(value1.re>0 && value2.re>0);										// Both operands >0		default:			return 0;							// No checking required for other tokens, always return valid	}}// Define method for accessing equation list pointer (only used by preprocessor)ulist<name_object>* calculator::get_equation_list(){ return equation_list; }// Define method for accessing variable list pointer (only used by preprocessor)ulist<name_object>* calculator::get_var_list(){	return var_list; }// Define method for accepting an array of constants, and using this data to produce a// generic constant list for all calculatorsvoid calculator::build_internal_constants(const name_object *const_array,																					const int length){	ulist<name_object> build_list;		for (int i=0; i<length; i++)					// Add name objects to constant list in name order		build_list.add(const_array[i], COUNTER, ASCENDING);	calculator::constant_list=build_list;							// Copy list into static storage space}// Define method for internal error recording - accepts char arraycomplex calculator::error(const char* s){	(*error_stream) << "error: " << s << '\n';			// Output error message to error_stream	(*number_of_errors)++;													// Increment int number of errors	return complex (0,0);														// Return NULL result}// Define method for internal error recording - accepts string_classcomplex calculator::error(const string_class s){	(*error_stream) << "error: " << s << '\n';			// Output error message to error_stream	(*number_of_errors)++;													// Increment int number of errors	return complex (0,0);														// Return NULL result}// Define method for clearing both variable and equation list of calculator to empty statevoid calculator::all_clear(){	var_list->clearlist();	equation_list->clearlist();}// Define method for clearing a single variable/equation in this calc specified by namestatus calculator::clear_single_memory(string_class name){	if (var_list->remove(name,COUNTER)==ERROR)				// Removal from variable list fails...		return (equation_list->remove(name,COUNTER));		// Attempt removal from eqn list	else		return SUCCESS;																	// Removed successfully from var list}// Define method for outputting contents of calculator - overloaded output operatorostream& operator<<(ostream& output_stream, calculator a){		output_stream << "Variable List:\n ";							// Output variable list...	output_stream << *(a.var_list);	output_stream << "EQUATION List:\n ";							// Followed by the equation list...	output_stream << *(a.get_equation_list());	return output_stream;}// Define method for finding out how many errors have occurred since the last time// flush_errors was called (or if flush_errors has never been called, since this calc// object had been instantiated)int calculator::get_number_of_errors(){ return *number_of_errors; }// Define method for turning auto verification of equations off.void calculator::auto_verify_off(){ auto_verify=0; }// Define method for turning auto verification of equations on.// Verify is then done on all equations every time a new equation is defined.status calculator::auto_verify_on(){	// Check first to make sure there are no circular definitions currently in calculator	if (equation_checker->validate(this)==ERROR)		return ERROR;	else	{		auto_verify=1;		return SUCCESS;	}}// Define method for setting the validator which this calculator and all its SUB// CALCULATORS will use for validating/verifying equations for circular definitions.void calculator::set_validator(validator *checker){ equation_checker=checker; }// Rest of file consists of all static member data required by the calculator classint calculator::math_function_array_initialised=0;char calculator::terminator_table[256];double (*calculator::math_func[256])(double);ulist<name_object> calculator::constant_list;int calculator::ERROR_STREAM_SIZE=1000;// This array defines all those tokens which may terminate an expressionconst token_value calculator::terminator_tokens[15]={token_value(NUMBER),token_value(NAME),token_value(FACTORIAL),token_value(PRINT),token_value(MILLI),token_value(MICRO),token_value(NANO),token_value(PICO),token_value(FEMTO),token_value(KILO),token_value(MEGA),token_value(GIGA),token_value(TERA),token_value(PETA),token_value(EXA)};// This array maps an OPERATION string to a single character calculator symbol.const token_name calculator::token_names[50]={token_name ("PLUS",'+'),token_name ("MINUS", '-'),token_name ("MULTIPLY", '*'),token_name ("DIVIDE", '/'),token_name ("POWER",'^'),token_name ("FACTORIAL", '!'),token_name ("SQUARE_ROOT", '@'),token_name ("CUBE_ROOT", '£'),token_name ("ROOTX", '$'),token_name ("SINE",'¡'),token_name ("COSINE", '™'),token_name ("TANGENT",'#'),token_name ("ARCSINE", '¢'),token_name ("ARCCOSINE", '∞'),token_name ("ARCTANGENT", '§'),token_name ("SINE-H", '~'),token_name ("COSINE-H", 'Ω'),token_name ("TANGENT-H",'≈'),token_name ("ARCSINE-H",'ç'),token_name ("ARCCOSINE-H", '√'),token_name ("ARCTANGENT-H", '∫'),token_name ("NATURAL_LOG", '¶'),token_name ("LOG10", '•'),token_name ("LOG2", 'ª'),token_name ("LOGX", 'º'),token_name ("PRINT", ';'),token_name ("ASSIGN_CONSTANT",'='),token_name ("LEFT_BRACKET",'('),token_name ("RIGHT_BRACKET", ')'),token_name ("LEFT_MODULUS",'['),token_name ("RIGHT_MODULUS", ']'),token_name ("ARGUMENT",'≠'),token_name ("MILLI",'œ'),token_name ("MICRO",'∑'),token_name ("NANO",'®'),token_name ("PICO",'†'),token_name ("FEMTO",'¥'),token_name ("KILO", 'å'),token_name ("MEGA", 'ß'),token_name ("GIGA",'∂'),token_name ("TERA",'ƒ'),token_name ("PETA", '©'),token_name ("EXA",'∆'),token_name ("DEFINE_EQUATION",':'),token_name ("SUMMATION", '¬'),token_name ("PRODATION", '∏'),token_name ("COMMA", ','),token_name ("REAL", '≤'),token_name ("IMAGINARY", '≥'),token_name ("WINDOW",'÷')};