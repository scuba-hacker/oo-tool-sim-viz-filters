/************************************************************************************** * CODE FILE: CalculatorManager.c++ * PURPOSE	: define members of calculator_manager class **************************************************************************************/#include "CalculatorManager.h"extern const int MAX_IO=1000;												// Ref. Buffer size for input/output// Define CLI using cin/cout streams for accessing calculator_manager functionsvoid calculator_manager::interface(){	char input_string[MAX_IO]="";											// Initialise primary input char array	char input[MAX_IO]="";														// Initialise second input char array	string_class preprocessed_string;	string_class name;	string_class errors;	complex result;			cout << "\nCalculator Manager.";														// Output manager prompt	if (current_calc==NULL)																			// If no calculators in list		cout << "NULL> ";																					// Output NULL name	else		cout << current_calc->get_index() << "> ";								// Output current calc name	while (cin >> input_string)																	// Main interface loop	{		if (strcmp(input_string,"add")==0)						// Command for adding calculator to list		{			cin >> name;																// Get identifier for calculator			add_calculator(name);												// Add new calculator to list			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"remove")==0)					// Command for removing calc from list		{			cin >> name;																// Get identifier for calculator			remove_calculator(name);										// Remove calculator from list			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"set_current")==0)		// Command for setting current calc 		{			cin >> name;																// Get identifier for calculator			set_current_calc(name);											// Set current calculator to 'name'			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"storage")==0)				// Command for dumping vars/eqns to cout		{																							// for current calculator.			current_storage(cout);											// Output variables and equations			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"errors")==0)					// Command for dumping errors in current		{																							// calculator to cout.			current_errors(cout);												// Output error report.			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"clear_errors")==0)		// Command for clearing errors in curr.		{			current_clear_errors();											// Clear error report in current calc.			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"clear_memory")==0)		// Command to clear all variables and		{																							// equations in current calculator			cout << clear_memory();											// Clear all memories, report any errors			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"clear")==0)					// Command to clear single variable or		{																							// equation in current calculator			cin >> name;																// Get identifier for var/eqn			cout << clear_single_memory(name);					// Clear the memory, report any errors			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"resetmanager")==0)		// Command to re-initialise manager,		{																							// ie clear calculator list			reset_manager();			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"verify")==0)					// Command for verifying all equations		{																							// in current calculator			validate_current();													// Validate all equations			goto prompt;																// Jump to end of interface loop		}		if (strcmp(input_string,"auto_verify_on")==0)	// Command for activating auto-verify		{			auto_verify_on();			goto prompt;																// Jump to end of interface loop		}				if (strcmp(input_string,"auto_verify_off")==0)	// Command to deactivate auto-verify		{			auto_verify_off();			goto prompt;																	// Jump to end of interface loop		}				if (strcmp(input_string,"dump")==0)					// Command to output all calculators names		{																						// and contents in calculator list			cout << *this;			goto prompt;															// Jump to end of interface loop		}				if (strcmp(input_string,"order")==0)			// Command for sending expression/assignment		{																					// /definition to current calculator			cin.get(input, MAX_IO);									// Get all user input up to newline			result=process_order(input);						// Evaluate the order using current calc.			if (current_calc!=NULL)									// If current calculator is set...			{				// If errors stored in current calc, output those errors to cout				if (current_calc->get_number_of_errors()!=0)						cout << "Errors are present in '" << current_calc->get_index() << "'\n";				// Output result of order to cout				cout << "result is: '" << result << "'\n";			}			goto prompt;															// Jump to end of interface loop		}				if (strcmp(input_string,"help")==0)				// Command for displaying CLI command list		{			display_help();			goto prompt;														// Jump to end of interface loop		}				if (strcmp(input_string,"return")==0)			// Break out of the CLI		{			break;		}				cout << "No Command\n";																		// Catch invalid commands				prompt:																										// End of loop label				cout << "\nCalculator Manager.";													// Output manager prompt		if (current_calc==NULL)																		// If no calculators in list			cout << "NULL> ";																				// Output NULL name		else			cout << current_calc->get_index() << "> ";							// Output current calc name	}}// Define function to display all calculator manager commands to the screenvoid calculator_manager::display_help(){	cout << "Commands Available:\n";	cout << "\t add <name>\n";	cout << "\t remove <name>\n";	cout << "\t set_current <name>\n";	cout << "\t storage\n";	cout << "\t errors\n";	cout << "\t clear_errors\n";	cout << "\t clear_memory\n";	cout << "\t clear <name>\n";	cout << "\t resetmanager\n";	cout << "\t verify\n";	cout << "\t auto_verify_on\n";	cout << "\t auto_verify_off\n";	cout << "\t dump\n";	cout << "\t return\n";	cout << "\t order <expression> | <assignment> | <equation>\n";	cout << "\t help\n\n";}// Define function to clear calculator list and set current_calc to NULLvoid calculator_manager::reset_manager(){	calc_list.clearlist();											// Clear calculator list	current_calc=NULL;													// Initialise current calc to no calc}// Define Default Constructorcalculator_manager::calculator_manager(calc_preprocessor *preprocess){	preprocessor=preprocess;																// Connect a preprocessor object	// Define new validator using preprocessor as reference	// Preprocessor needed by validator for returning list of variable/equation names	equation_checker = new validator(preprocessor);	current_calc=NULL;																// Initialise current calc to no calc}// Define Destructorcalculator_manager::~calculator_manager(){	delete equation_checker;											// Destroy dynamically allocated validator}// Define Copy Constructor - uses overloaded = operatorcalculator_manager::calculator_manager(calculator_manager &original){	calc_list=original.calc_list; }// Define Overloaded = operatorcalculator_manager& calculator_manager::operator=(calculator_manager &source){	calc_list=source.calc_list;																// Copy across calculator list	equation_checker=source.equation_checker;	current_calc=source.current_calc;	return *this;}// Define method for adding a calculator with 'name' to calculator liststatus calculator_manager::add_calculator(const string_class name){	// Add to list using ASCENDING lexical ordering on name	if ((calc_list.add(calc_object(name), COUNTER, ASCENDING))==ERROR)	{		cout << "manager ERROR : New Calculator must have unique name to this manager\n";		return ERROR;	}	else	{		set_current_calc(name);									// Set current_calc to point to new calculator		current_calc->set_validator(equation_checker);		// Connect validator to new calc		return SUCCESS;	}}// Define method for removing a calculator with 'name' from calculator liststatus calculator_manager::remove_calculator(const string_class name){	if (calc_list.remove(calc_object(name), COUNTER)==SUCCESS)	{		set_current_calc();					// Set current to first calc in list or NULL if list empty		return SUCCESS;	}	else	{		cout << "Manager ERROR - " << name << " calculator was not removed because '" << 																  name <<"' calculator doesn't exist\n";		return ERROR;	}}// Define method for outputting current calculator's lists of variables and equationsostream& calculator_manager::current_storage(ostream &output_stream){	if (current_calc==NULL)																		// If calculator list is empty	{		cout << "Current Calculator not set\n";		output_stream << "Manager ERROR - current calculator not set\n";	}	else		output_stream << *current_calc;													// Output contents of current	return output_stream;}// Define method for outputting current calculator's lists error reportostream& calculator_manager::current_errors(ostream &output_stream){	if (current_calc==NULL)																		// If calculator list is empty	{		cout << "Current Calculator not set\n";		output_stream << "Manager ERROR - current calculator not set\n";	}	else		current_calc->peek_errors(output_stream);								// Output error report 	return output_stream;}// Define method for validating all equations in current calculatorstatus calculator_manager::validate_current(){	if (current_calc!=NULL)																	// If calculator list not empty	{		if (equation_checker->validate(&current_calc->get_data())==SUCCESS)	// Check equations		{			cout << "Calculator Manager declares '" << current_calc->get_index() <<						  "' to have integrity\n";			return SUCCESS;		}		else		{			cout << "ERROR : Calculator Manager finds circular definition in '" <<							current_calc->get_index() << "'\n";			cout << "		 Error Trace: " << equation_checker->error_trace << "\n";			return ERROR;		}	}	else	{		cout << "Manager ERROR - current calculator not set\n";		// Calculator list is empty		return ERROR;	}}// Define method for clearing error report in current calculatorstring_class calculator_manager::current_clear_errors(){	if (current_calc==NULL)																			// If calculator list empty	{		cout << "Current Calculator not set\n";		return "Manager ERROR - current calculator not set\n";	}	else		return current_calc->flush_errors();											// Clear error report}// Define method for clearing all variables & equations in current calculatorstring_class calculator_manager::clear_memory(){	if (current_calc==NULL)																			// If calculator list empty		return "Manager ERROR - current calculator not set\n";	else	{		current_calc->all_clear();																// Clear all memories		return "";	}}// Define method for clearing a single variable or equation in current calculatorstring_class calculator_manager::clear_single_memory(string_class name){	if (current_calc==NULL)																			// If calcalator list empty		return "Manager ERROR - current calculator not set\n";	else	{		if(current_calc->clear_single_memory(name)==ERROR)				// Name not found			return "Invalid name\n";		else			return "Cleared\n";	}}// Define method to send an order (expression/assignment/equation) to current calculatorcomplex calculator_manager::process_order(const string_class &calc_order){	if (current_calc==NULL)																			// If calcalator list empty		cout << "Current Calculator not set\n";	else	{		string_class preprocessed_string;		complex result;		preprocessor->preprocess(calc_order, preprocessed_string);				// Preprocess order		result=current_calc->evaluate(preprocessed_string);								// Evaluate order		return result;																				// Return complex number result	}	return complex (0,0);																							// Return NULLcomplex}// Define method for activating auto_verify for current_calculatorvoid calculator_manager::auto_verify_on(){	if (current_calc==NULL)																			// If calculator list empty		cout << "Current Calculator not set\n";	else	{		if(current_calc->auto_verify_on()==ERROR)			cout << "Circular equations detected - remove them - auto verify off";		else			cout << "Auto Verify Activated\n";	}}// Define method for deactivating auto_verify for current_calculatorvoid calculator_manager::auto_verify_off(){	if (current_calc==NULL)																			// If calculator list empty		cout << "Current Calculator not set\n";	else	{		cout << "Auto Verify Deactivated\n";		current_calc->auto_verify_off();	}}// Define method for returning name of current calculatorstring_class calculator_manager::get_current_calc(){	if (current_calc==NULL)																			// If calculator list empty		return "";	else		return current_calc->get_index();}// Define method for setting current calculator to calculator identified by 'name_string'status calculator_manager::set_current_calc(const string_class name_string){	calc_object *calculator_p;	if (calc_list.reset_transverse()==ERROR)						// Reset to head of calculator list	{		if (name_string!="")			cout << "Manager ERROR - can't set current calculator when calculator list is empty!\n";		current_calc=NULL;												// Reset current calculator to no calculator		return ERROR;	}		if (name_string=="")													// If first calculator in list is required	{		current_calc=calc_list.get_transverse_node_pointer();		return SUCCESS;	}		// Search calculator list for calculator identified by name_string	do	{		calculator_p=calc_list.get_transverse_node_pointer();				// Get current calculator		if (calculator_p->get_index()==name_string)									// If names match...		{						current_calc=calculator_p;																// Set current calculator			return SUCCESS;		}	}	while(calc_list.progress_transverse()==SUCCESS);							// Progress to next calc		cout << "Manager ERROR - setting current calculator failed as calculator with name '"			 << name_string << "' does not exist\n";	return ERROR;}// Define overloaded output operator for calculator_manager classostream& operator<<(ostream& output_stream, calculator_manager &output){	output_stream << "\nCalculator Manager List:\n\n";	if (output.calc_list.reset_transverse()==ERROR)									// Calculator list empty	{		output_stream << "No Calculators Present\n";		return output_stream;	}		calc_object calc;		do 															// Output contents of all calculators in calculator list	{		output.calc_list.get_transverse(calc);										// Get current calculator		cout << calc << "\n";																			// Output current calculator	}	while (output.calc_list.progress_transverse()==SUCCESS);		// Progress to next calc		return output_stream;}