#include "define_vars.h"#include "name_object.h"#include "list.h"// ****************** LIST - all code and design by Mark Jones **********template <class node>list<node>::list(void){	head=tail=current=transverse = NULL;							// Initialise list empty}template <class node>void list<node>::clearlist(void)													// Removes all nodes from list{	if (reset_transverse()==SUCCESS)								// Reset list and remove		while (remove_transverse()==SUCCESS);					// nodes if list not empty}template <class node>list<node>::~list(void)																			// List destructor function{	clearlist();}/*+++++++++++++++++++++++++++++ SEARCH FUNCTION ++++++++++++++++++++++++++++++++++If ordering method is COUNTER, search list for node with index matching thatcontained in searchitem.If ordering method is DATA, search list for node data matching that containedin searchmitem.Current is set to the node, if found - else current set to NULL.The function returns a pointer to the node preceding the searched node.If searched item not found, previous points to last node in list.If list empty, both current and previous are set to NULL.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>node* list<node>::search(node searchitem, ordering method){	node *previous;	current = head;														// Reset current to start of list.	previous = NULL;													// Initialise previous pointer.	if (method == COUNTER)		// Search for node with particular index.		while (current!=NULL && 										current->compare_index(current->get_index(), 														 searchitem.get_index()) != EQUAL)																						  	{				previous = current;										  		current = current->get_pointer();			   	}	  else  	// Search for node with particular data. 		while (current!=NULL && 									 			current->compare_data(current->get_data(), 														searchitem.get_data()) != EQUAL)  	{																								previous = current;											  		current = current->get_pointer();		  	}																									return previous;} /*+++++++++++++++++++++++ FIND_NEIGHBOURS FUNCTION +++++++++++++++++++++++++++++++This function finds the position in the list where target should be inserted.The position is determined on either index or data values, specified by'comparisontype'.To perform the search, the form of the ordering must be specified in 'direction'as being ASCENDING or DESCENDING.Pointers to preceding and proceding nodes to this position are returned.If either of these nodes do not exist, the respective pointer is set to NULL.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>void list<node>::find_neighbours(node *target, node* &preceding,			node* &proceding, ordering comparisontype, orderproperty direction){	current = head;													// Reset current to start of the list.	preceding = NULL;		compare operation;							// Holds the comparison method used when																	// comparing index/data in two nodes.																// Following determines whether to look for the															// node with larger, or smaller value in the list.		if (direction == ASCENDING)		operation=LARGER;										// Search for next larger node in list.	else		operation=SMALLER;									// Search for next smaller node in list.	// Do the search using compare_index commands if searching on index.// Else do search using compare_data commands if searching on data.		if (comparisontype == COUNTER)		while (current!=NULL &&						current->compare_index(current->get_index(),														 target->get_index())!=operation)		{																				preceding = current;										current = current->get_pointer();			}	else		while (current!=NULL &&											 current->compare_data(current->get_data(),			 											 target->get_data())!=operation)		{																						preceding = current;											current = current->get_pointer();		}	// Set preceding and proceding pointers.	if (preceding!=NULL)										// If the insertion point is not at 		proceding = preceding->get_pointer(); // head of list, set proceding to																					// the following node.	else		proceding = head;									// Otherwise, proceding node is the																			// first node in the list, and insertion																			// would be at the front of the list.}/*++++++++++++++++++++++++++ PRINTLIST FUNCTION +++++++++++++++++++++++++++++++++Print out the entire list on out stream. Traverses the list calling printnodefunction for every node.*/template <class node>void list<node>::printlist(){	if (head != NULL)														// If this is not an emptylist	{			current = head;						do						{			current->print_node();									current = current->get_pointer();				// Traverse to next node in list.			if (current != NULL)										// If this isn't the last node,				cout << " ";													// output space (node separater)		}		while (current != NULL);									// Repeat until end of list.		cout << '\n';											// End of list reached, move to next line	}	else	{		cout << "This list is empty\n";	}}/* ++++++++++++++++++++++++++++ REMOVE FUNCTION +++++++++++++++++++++++++++++++++++This function will search for removeitem node in the list and remove the nodefrom the list. It will match either the index or the data item when applying thesearch algorithm. The search method is determined by the 'ordering method' :method=COUNTER -> search on index	for node to removemethod=DATA		->	search on data for node to remove++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::remove(node removeitem, ordering method){	node *previous;														// used to point to node prior to 																						// node to be removed.		// ************************* TEST BLOCK remove.1 ****************************	previous=search(removeitem, method);	 // Set current to the node for removal.																				// and set previous to preceding node.	if (current==NULL)	 // If list empty or current points to NULL at end of list		return ERROR;				// node not found in the list, return ERROR.	// ************************* TEST BLOCK remove.2 ****************************		if (previous==NULL)												// ### DELETION AT HEAD OF LIST ###	{																						current=current->get_pointer();									// Set current to point to																										// the new head of the list.																					if (transverse == head)									// Update traverse if being removed			transverse = head->get_pointer();				if (tail == head)												// Update tail if being removed			tail = NULL;					delete head;														// Delete node at head of list		head = current;													// Update head to new head of list	}		// ************************* TEST BLOCK remove.3 ****************************		else	{														// ##### Deletion in middle or end of list. ######																																				// Delink current from list																							previous->set_pointer_to(current->get_pointer()); 				if (current == tail)									// Update tail if being removed			tail = previous;		if (current == transverse)						// Update transverse if being removed			if (current->get_pointer() != NULL)				// Transverse mid-list position				transverse = current->get_pointer(); 		// Move transverse to next node			else				transverse = previous;							delete current;										// Deallocate the node being removed		current = previous;								// Set current to point to node																			// before the node deleted.	}	return SUCCESS;};/*++++++++++++++++++++++++++++ ADD_TO_END FUNCTION +++++++++++++++++++++++++++++++This function appends a copy of newitem node to the end of the list.If the index of newitem has not been set (index=0), the index of the new node isderived by calling set_to_next_index on the index of the last node of the list.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::add_to_end(node newitem){	node *newnode;	newnode = new node;														// Allocate memory for new node		if (newnode == NULL)													// Out of memory condition	{		cerr << "ADD_TO_END: reports out of memory!";		return ERROR;	}		*newnode = newitem;												// Load new node with supplied data	// *********************** TEST BLOCK add_to_end.1 **************************	if (head == NULL)											// ######  Append to empty list #######	{																			// Empty list, make newnode the head		if (newitem.get_index()==0)					// Set index to first permissible index			newnode->set_index("");		head = transverse = (tail = newnode);								// Update head and tail	}		// *********************** TEST BLOCK add_to_end.2 **************************		else																// ###### Append to non-empty list ######	{		if (newitem.get_index()==0)													// If index has not been											newnode->set_to_next_index(tail->get_index());		// set load newitem with																												// next index.		tail->set_pointer_to(newnode);					// Set last node to point to newnode		tail=newnode;														// Move tail to end of list;	}		tail->set_pointer_to(NULL);			// Terminate end of list with NULL.	return SUCCESS;}/*++++++++++++++++++++++++++++ ADD FUNCTION ++++++++++++++++++++++++++++++++++++++This function adds a copy of newitem to the list. The insertion position isdetermined using:1)	ordering order : order=COUNTER		-		Item is added according to index value										 order=DATA				-		Item is added according to data value2)	orderproperty direction : 										 direction=ASCENDING  - ordered item increases down list					 					 direction=DESCENDING - ordered item decreases down listThe addition occurs in such a position as to keep the ordering of the listconsistent with the above conditions.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::add(node newitem, ordering order, orderproperty direction){	node *previous;							//	Required for calling function find_neighbours.	node *following;						//	Required for calling function find_neighbours.	node *newnode;							//	Used to point to the new node to be added.		newnode = new node;													// Allocate memory for new node,																							// pointed to by'newnode'.																								if (newnode==NULL)	{		cerr << "ADD FUNCTION: Out of memory\n";		return ERROR;	}																						*newnode = newitem;													// Copy in the newitem data	newnode->set_pointer_to(NULL);							// Newnode forced to point to NULL		// *************************** TEST BLOCK add.1 *****************************	if (head == NULL)												// ### insertion into empty list ###	{		head = tail = current = (transverse = newnode);	// Set all private pointers		return SUCCESS;																	// to point to new node	}	else		current = head;															// Reset current to head of list				find_neighbours(newnode, previous, following, order, direction);		// *************************** TEST BLOCK add.2 *****************************																						// ##### ADD TO END OF LIST #####	if (following == NULL)										// Node not found by find_neighbours	{		previous->set_pointer_to(newnode);										// Set preceding node 																													// to point to newnode.		current = newnode;																// Update current and tail		tail = newnode;																		// to point to new node.	}		// *************************** TEST BLOCK add.3 *****************************	else																			// ##### ADD BEFORE HEAD IN LIST ###	{		if (previous == NULL)		{			newnode->set_pointer_to(head);								// Make newnode head of list			head = current = newnode;											// and set current to head		}																	// *************************** TEST BLOCK add.4 *****************************		else																		// ###ADD NODE IN MIDDLE OF LIST###		{				previous->set_pointer_to(newnode);									// Set preceding node																													// to point to newnode			newnode->set_pointer_to(following);								// Set newnode to point																												// to proceding node.			current = newnode;																// Set current to point		}																										// to the new node.	}	return SUCCESS;												// No errors occurred, return SUCCESS.};/*++++++++++++++++++++++++ RESET_TRANSVERSE FUNCTION +++++++++++++++++++++++++++++This function sets transverse pointer to the head of the list.Return ERROR if list is empty, otherwise Return SUCCESS++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::reset_transverse()		// Reset transverse to start of list{// **************************** TEST BLOCK reset.1 ****************************	if (head == NULL)								// If empty list then can't reset!		return ERROR;// **************************** TEST BLOCK reset.2 ****************************	else	{		transverse = head;						// Set transverse to point to the head of list		return SUCCESS;	}}/*++++++++++++++++++++++++ GET_TRANSVERSE FUNCTION +++++++++++++++++++++++++++++++This function copies the node pointed to by transverse into 'gotitem' which isreturned back to the calling routine by reference.Return ERROR if list is empty, otherwise return SUCCESS.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::get_transverse(node &gotitem)		// Return the object pointed to by transverse. If list is empty,		// return status ERROR, else SUCCESS.{// **************************** TEST BLOCK get.1 ******************************	if (transverse != NULL)																// If list not empty...	{		gotitem = *transverse;							// Copy node pointed to by transverse to		return SUCCESS;											// gotitem, and return SUCCESS.	}// **************************** TEST BLOCK get.2 ******************************	else		return ERROR;																						// Can't get node.}/*+++++++++++++++++++++++++ PROGRESS_TRANSVERSE FUNCTION +++++++++++++++++++++++++This function will move transverse to point to the next node in the list.If the list is empty, or transverse is already at the end of the list, ERRORis returned. Otherwise, SUCCESS is returned.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::progress_transverse()		// Move transverse pointer to next node. If transverse points to NULL, or		// is NULL itself, return ERROR, else SUCCESS.{// ************************** TEST BLOCK progress.1 ***************************	if (transverse != NULL && transverse->get_pointer() != NULL)	{		transverse = transverse->get_pointer();			// Progress through list by one		return SUCCESS;															// node and return SUCCESS.		}	else// ************************** TEST BLOCK progress.2 ***************************		return ERROR;									// Progression not possible, return an ERROR.}/*+++++++++++++++++++++ CHANGE_TRANSVERSE_NODE_TO FUNCTION +++++++++++++++++++++++This function takes the data and index values from setitem and copies them tothe respective containers in the node pointed to by transverse. If the list isempty or the index or data to be set is invalid, an ERROR is returned.Otherwise, SUCCESS is returned.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::change_transverse_node_to(node setitem)		// This function will take data object and index from setitem and copy them		// into the node pointed to by transverse, as long as the list is not		// empty (and transverse points to NULL). 		{	if (transverse != NULL)		// If list is not empty.	{		if (transverse->set_data(setitem.get_data()) == ERROR ||			transverse->set_index(setitem.get_index()) == ERROR )																					// Return error if setitem																					// contains out-of-range data or index.																											return ERROR;			else																	// Else, no problem, return SUCCESS.			// ************************** TEST BLOCK change.1 ***************************			return SUCCESS;	}	else		// ************************** TEST BLOCK change.2 ***************************			return ERROR;								// Transverse points to NULL, can't change node.}/*++++++++++++++++++++++ REMOVE_TRANSVERSE FUNCTION ++++++++++++++++++++++++++++++This function deletes the node that transverse points to. ERROR is returned iflist is empty. Transverse is set to point to the next node in the list. If thereis no next node, then transverse is set to the previous node to that deleted.If the list becomes empty, transverse is set to NULL.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>status list<node>::remove_transverse(){	node* preceding;															// Initialise preceding pointer.	if (transverse != NULL)															// If list is not empty...	{			current = head;															// Reset current to head.		preceding = NULL;																								// Traverse the list whilst the																								// current node is not the same																								// as that pointed to by																								// transverse.																										while (current!=transverse)		 {																								preceding = current;												// Update preceding pointer. 		 	current = current->get_pointer();		 	 }																								// Preceding stores the pointer																								// to the node before transverse.	// ************************ TEST BLOCK rem_trans.1 **************************		if (transverse == head)							// ##### REMOVE FROM HEAD OF LIST #####		{						transverse=transverse->get_pointer();			// Set transverse to next node.																		// This will be NULL if list becomes empty.			delete head;									// Deallocate memory held by removed node.			head = transverse;						// Update head, tail and current pointers.			current = head;			tail = head;						if (head == NULL || head->get_pointer() == NULL) // If head is the only				tail = head;									// node in the list, or list is now empty,																			// update tail pointer.				}		// *********************** TEST BLOCK rem_trans.2 ***************************		else		{														// ##### REMOVE FROM ANYWHERE EXCEPT HEAD #####																																// Delink node pointed 																													// to by transverse.			preceding->set_pointer_to(transverse->get_pointer());						if (current == tail)												// Move tail back one node				tail = preceding;													// if last node being removed.							delete current;							// Deallocate memory held by removed node.						if (preceding->get_pointer() == NULL)			// End of list reached, set																								// transverse to new last node.				transverse = preceding;			else				transverse = preceding->get_pointer(); 			// Change transverse pointer																										// to next node in the list.			current = head;																			// Set current to head		}		return SUCCESS;																				// Successful removal	}	// *********************** TEST BLOCK rem_trans.2 ***************************	else		return ERROR;																							// List is empty.}/*+++++++++++++++++++++++++ OVERLOAD EQUALS OPERATOR +++++++++++++++++++++++++++++This function first empties the target (this) of any nodes. Then if source listis not empty, all nodes in source are added in sequence to the target.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>list<node>* list<node>::operator=(list<node> &source){	node working;		if (reset_transverse() == SUCCESS)									// Empty this of all nodes		while (remove_transverse() == SUCCESS);						// ERROR returned when																											// all removed.																												if (source.reset_transverse() == SUCCESS)					// If source is not empty...	{		do		{			source.get_transverse(working);									// Get a node from source.			add_to_end(working);														// Add the node to this.		}		while (source.progress_transverse() == SUCCESS);	}	return this;}/*+++++++++++++++++++++++++++ COPY CONSTRUCTOR +++++++++++++++++++++++++++++++++++This function uses the overloaded equals operator to make a copy of originallist.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/template <class node>list<node>::list(list<node> &original){	head=tail=current=transverse = NULL;								// Initialise all pointers	*this=original;																			// Call equals operator}// Make explicit instantiations of the two types of listtemplate class list<name_object>;typedef list<name_object> name_list;