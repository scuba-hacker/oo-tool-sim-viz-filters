/************************************************************************************** * CODE FILE: data_set_obj.c++ * PURPOSE	: define members of data_set_obj class **************************************************************************************/#include "data_set_obj.h"// Define default constructordata_set_obj::data_set_obj(){	next_data_set_obj = NULL;	name=data_set_obj::undefined_index;}// Define constructor using string_class to initialisedata_set_obj::data_set_obj(string_class name_string){	name=name_string;	next_data_set_obj = NULL;}// Define constructor using string_class and data_set to initialisedata_set_obj::data_set_obj(string_class name_string, data_set data_list){	name=name_string;	data=data_list;	next_data_set_obj = NULL;}// Define copy constructordata_set_obj::data_set_obj(data_set_obj &original){ *this=original; }// Define assignment of data_set_obj objects by data_set_obj objectsdata_set_obj& data_set_obj::operator=(data_set_obj &original){	name=original.name;	data=original.data;	next_data_set_obj = original.next_data_set_obj;	return *this;}// Define method for extracting index fieldstring_class data_set_obj::get_index(){ return name; }// Define method for setting index fieldstatus data_set_obj::set_index(const string_class setting){	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid data_set_obj::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid data_set_obj::set_to_next_index(const string_class ref){ name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare data_set_obj::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fielddata_set data_set_obj::get_data(){ return data; }	// Define method for setting data fieldstatus data_set_obj::set_data(data_set setting){		data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare data_set_obj::compare_data(const data_set name1, const data_set name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;																				// Arbitrary ordering for data_set}// Define method for setting pointer fieldvoid data_set_obj::set_pointer_to(data_set_obj *p){ next_data_set_obj=p; }// Define method for extracting pointer fielddata_set_obj* data_set_obj::get_pointer(){ return next_data_set_obj; }	// Define method for outputting name_object contents on standard outputvoid data_set_obj::print_node(){cout << name << "-> " << data;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, data_set_obj a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define methods for accessing public data members inside data field (data_set)status data_set_obj::get_element_assoc(complex &result, const int index,																			 const string_class field){ return data.get_element_assoc(result, index, field); }status data_set_obj::set_element_assoc(const complex new_value, const int index,																			 const string_class field){ return data.set_element_assoc(new_value, index, field); }status data_set_obj::get_element(complex &result, const int index, const int field_index){ return data.get_element(result, index, field_index); }status data_set_obj::set_element(const complex new_value, const int index,																 const int field_index){ return data.set_element(new_value, index, field_index); }int data_set_obj::get_length(){ return data.get_length(); }int data_set_obj::get_width(){	return data.get_width(); }void data_set_obj::get_fields(string_class *storage){	data.get_fields(storage); }status data_set_obj::clear_data_array(){ return data.clear_data_array();}// Define method for applying set_input to field 'field' of data_set in this data_set_objstatus data_set_obj::load_real_input(set_input &input, string_class field){	int index_low, index_high;													// Variables to hold 'input' fields	double start_value, increment;											// Variables to hold 'input' fields	int width=data.get_width();													// Holds width of data_set	string_class *fields=new string_class[width];				// Holds record fields from data_set	data.get_fields(fields);														// Extract record fields	status found=ERROR;																	// Error flag	int field_index=0;																	// integer index of selected field		for (int i=0; i<width; i++)											// Find the integer index of the 'field'		if (fields[i]==field)		{			field_index=i;			found=SUCCESS;		}	delete [] fields;																	// Fields array not required any more		if (found==ERROR)																	// Catch invalid 'field' name	{		cout << "ERROR: field '" << field << "' is not valid for this data_set\n";		return ERROR;	}		// extract parameters stored inside input_set 'input'	input.get_parameters(index_low, index_high, start_value, increment);			if (index_low<0 || index_high>=data.get_length())		// ERROR if out of range index	{		cout << "ERROR: attempt to set out of range element in data_set\n";		return ERROR;	}		int current_value=start_value;	for (int i=index_low; i<=index_high; i++)						// Load appropriate field with data	{		if (data.set_element(complex(start_value,0), i, field_index)==ERROR)		{			cout << "ERROR: set_element in data_set_obj::load_real_input\n";			return ERROR;		}		start_value+=increment;	}	return SUCCESS;}// Define function to return address of data_set datadata_set* data_set_obj::get_data_set_pointer(){	return &data;}// Define undefined index as empty stringstring_class data_set_obj::undefined_index="";