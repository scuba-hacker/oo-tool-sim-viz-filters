#include "graph_spec_object.h"graph_spec_object::graph_spec_object()  															// ******DEFAULT CONSTRUCTOR*******{	next_graph_spec_object = NULL;									// Initialize internal fields	name="";																	// Default NULL string}graph_spec_object::graph_spec_object(string_class graph_name){	next_graph_spec_object = NULL;	name=graph_name;} graph_spec_object::graph_spec_object(string_class graph_name, graph_spec new_graph_spec){		name=graph_name;	spec=new_graph_spec;}graph_spec_object::graph_spec_object(graph_spec_object &original){	name=original.name;	spec=original.spec;}graph_spec_object& graph_spec_object::operator=(graph_spec_object &original){	name=original.name;	spec=original.spec;	return *this;}string_class graph_spec_object::get_index()													// Return value of index field{ return name; }// *******THIS FUNCTION DEFINES HOW INDEXING WORKS ACROSS THE LIST *******void graph_spec_object::set_to_next_index(const string_class ref)					// Given index of ref, set index of{																				// this graph_spec_object to the next	name=ref+"a";											// permissible index. (append 'a')}void graph_spec_object::set_to_first_index(){	name="a";}status graph_spec_object::set_index(const string_class setting)						// Set value of index field {	name=setting;	return SUCCESS;		// always successful!}// ********THIS FUNCTION DEFINES THE COMPARISON METHOD FOR INDEXES**********compare graph_spec_object::compare_index(const string_class index1, const string_class index2){	// cout << "compare graph_spec_objects called, result is: ";	if (index1>index2)	{		// cout << "LARGER\n";		return LARGER;	}	else		if (index1==index2)		{			// cout << "EQUAL\n";			return EQUAL;		}		else		{			// cout << "SMALLER\n";			return SMALLER;		}}			graph_spec graph_spec_object::get_data()																// Return value of spec field{ return spec; }	status graph_spec_object::set_data(graph_spec setting)											// Set value of spec field{			spec=setting;																	// if within valid bounds	return SUCCESS;}	// ********THIS FUNCTION DEFINES THE COMPARISON METHOD FOR DATA************	compare graph_spec_object::compare_data(const graph_spec name1, const graph_spec name2){	#pragma unused (name1)	#pragma unused (name2)	return SMALLER; // this is irrelevant as ordering on spec isn't going to be used}void graph_spec_object::set_pointer_to(graph_spec_object *p)						// Set next_graph_spec_object pointer to the	{ next_graph_spec_object=p; }											// value of pointer pgraph_spec_object* graph_spec_object::get_pointer()																	// Return value of	{ return next_graph_spec_object; }															// next_graph_spec_object pointer	void graph_spec_object::print_node()																			// Print Node info	{cout << name << "-> " << spec;}					// on standard outputostream& operator<<(ostream& output_stream, graph_spec_object a){	output_stream << a.name << "->" << a.spec;	return output_stream;}string_class graph_spec_object::undefined_index="";