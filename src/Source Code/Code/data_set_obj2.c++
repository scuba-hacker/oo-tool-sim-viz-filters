#include "data_set_obj.h"data_set_obj::data_set_obj()  								// ******DEFAULT CONSTRUCTOR*******{	next_data_set_obj = NULL;									// Initialize internal fields	name="";																	// Default NULL string}data_set_obj::data_set_obj(string_class name_string){	name=name_string;	next_data_set_obj = NULL;									// Initialize internal fields}data_set_obj::data_set_obj(string_class name_string, data_set data_list){	name=name_string;	data=data_list;	next_data_set_obj = NULL;									// Initialize internal fields}data_set_obj::data_set_obj(data_set_obj &original){	*this=original;}data_set_obj& data_set_obj::operator=(data_set_obj &original){	name=original.name;	data=original.data;	next_data_set_obj = original.next_data_set_obj;									// Initialize internal fields	return *this;}string_class data_set_obj::get_index()													// Return value of index field{ return name; }// *******THIS FUNCTION DEFINES HOW INDEXING WORKS ACROSS THE LIST *******void data_set_obj::set_to_next_index(const string_class ref)					// Given index of ref, set index of{																				// this data_set_obj to the next	name=ref+"a";											// permissible index. (append 'a')}void data_set_obj::set_to_first_index(){	name="a";}status data_set_obj::set_index(const string_class setting)						// Set value of index field {	name=setting;	return SUCCESS;		// always successful!}// ********THIS FUNCTION DEFINES THE COMPARISON METHOD FOR INDEXES**********compare data_set_obj::compare_index(const string_class index1, const string_class index2){	// cout << "compare data_set_objs called, result is: ";	if (index1>index2)	{		// cout << "LARGER\n";		return LARGER;	}	else		if (index1==index2)		{			// cout << "EQUAL\n";			return EQUAL;		}		else		{			// cout << "SMALLER\n";			return SMALLER;		}}			data_set data_set_obj::get_data()																// Return value of data field{ return data; }	status data_set_obj::set_data(data_set setting)											// Set value of data field{																									// if within valid bounds	data=setting;	return SUCCESS;			// Success assumed}	// ********THIS FUNCTION DEFINES THE COMPARISON METHOD FOR DATA************	compare data_set_obj::compare_data(const data_set name1, const data_set name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;		// not going define a way of ordering on data}void data_set_obj::set_pointer_to(data_set_obj *p)						// Set next_data_set_obj pointer to the	{ next_data_set_obj=p; }											// value of pointer pdata_set_obj* data_set_obj::get_pointer()																	// Return value of	{ return next_data_set_obj; }															// next_data_set_obj pointer	void data_set_obj::print_node()																			// Print Node info	{cout << name << "-> " << data;}					// on standard outputostream& operator<<(ostream& output_stream, data_set_obj a){	output_stream << a.name << "->" << a.data;	return output_stream;}status data_set_obj::get_array_element(complex &result, const int index, const string_class field){	return data.get_array_element(result, index, field);}status data_set_obj::set_array_element(const complex new_value, const int index, const string_class field){	return data.set_array_element(new_value, index, field);}int data_set_obj::get_length(){	return data.get_length();}int data_set_obj::get_width(){	return data.get_width();}void data_set_obj::get_fields(string_class *storage){	data.get_fields(storage);}string_class data_set_obj::undefined_index="";