/************************************************************************************** * CODE FILE: record_object.c++ * PURPOSE	: define members of record_object class **************************************************************************************/#include "record_object.h"// Define default constructorrecord_object::record_object(){	next_record_object = NULL;	name=record_object::undefined_index;}// Define constructor using string_class to initialiserecord_object::record_object(string_class name_string){	name=name_string;	next_record_object = NULL;}// Define constructor using string_class and ulist<string_object> to initialiserecord_object::record_object(string_class name_string, ulist<string_object> data_list){	name=name_string;	data=data_list;	next_record_object = NULL;}// Define copy constructorrecord_object::record_object(record_object &original){	name=original.name;	data=original.data;	next_record_object=original.next_record_object;}// Define assignment of record_object objects by record_object objectsrecord_object& record_object::operator=(record_object &original){	name=original.name;	data=original.data;	next_record_object=original.next_record_object;	return *this;}// Define method for extracting index fieldstring_class record_object::get_index(){ return name; }// Define method for setting index fieldstatus record_object::set_index(const string_class setting)	{	name=setting;	return SUCCESS;}// Define method for defining index of first object in list, if index not specifiedvoid record_object::set_to_first_index(){ name="a"; }// Define method for defining incremental indexing across the list, head->tailvoid record_object::set_to_next_index(const string_class ref){	name=ref+"a"; }// Define method for comparing two index objects - lexical comparison of string_classcompare record_object::compare_index(const string_class index1, const string_class index2){	if (index1>index2)		return LARGER;	else		if (index1==index2)			return EQUAL;		else			return SMALLER;}			// Define method for extracting data fieldulist<string_object> record_object::get_data(){ return data; }	// Define method for setting data fieldstatus record_object::set_data(ulist<string_object> setting)	{	data=setting;	return SUCCESS;}	// Define method for comparing two data objects - comparison complex_containerscompare record_object::compare_data( ulist<string_object> name1, 																		 ulist<string_object> name2){	#pragma unused (name1)	#pragma unused (name2)		return SMALLER;																// Arbitrary ulist<string_object> ordering}// Define method for setting pointer fieldvoid record_object::set_pointer_to(record_object *p){ next_record_object=p; }// Define method for extracting pointer fieldrecord_object* record_object::get_pointer(){ return next_record_object; }	// Define method for outputting name_object contents on standard outputvoid record_object::print_node(){cout << name << "-> " << data;}// Define overloaded output operator for name_objectostream& operator<<(ostream& output_stream, record_object a){	output_stream << a.name << "->" << a.data;	return output_stream;}// Define undefined index as empty stringstring_class record_object::undefined_index="";