/************************************************************************************** * CODE FILE: calc_preprocessor.c++ * PURPOSE	: define members of calc_preprocessor class **************************************************************************************/#include "calc_preprocessor.h"// Define Constructor which builds a correlator array which maps input strings to// calculator special characters and an inverse correlator array which performs the// reverse actioncalc_preprocessor::calc_preprocessor(const user_label *input_mappings,																		 const token_name *token_mappings, int length){	input_stream=NULL;																						// Initialise input stream	input_char_array=NULL;																					// Initialise char array		array_length=length;																						// Length of correlator	correlator=new token_name[array_length];												// Allocate correlator		for (int i=0; i<array_length; i++)															// Traverse input_array	{		for (int j=0; j<array_length; j++)														// Traverse token_array		{			if (input_mappings[i].calc_string==token_mappings[j].name)	// When match is found			{				// Associate input_string with corresponding character token, store in correlator				correlator[i].name=input_mappings[i].input_string;				correlator[i].token=token_mappings[j].token;			}		}	}	// now build reverse map for postprocessing - store in inverse_correlator	for(int k=0; k<array_length; k++)		inverse_correlator[(unsigned char)correlator[k].token]=correlator[k].name;}// Define destructor functioncalc_preprocessor::~calc_preprocessor(){ delete[] correlator;}											// delete dynamically allocated data structure// Define method to convert user string to calc stringvoid calc_preprocessor::preprocess (string_class input_string,																		string_class &output_string){	output_string="";																					// Initialise output_string	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	string_class single_name;																	// For single name read in	char input_char;																					// For piecewise char input			while (*input_stream)											// Scan entire input string using input_stream	{			// Read input, storing chars read into output_string, until alpha char found		while (input_stream->get(input_char) && (!isalpha(input_char) ))			output_string=output_string+input_char;				// Break out of while loop if end of stream encountered		if (!*input_stream)			break;				input_stream->putback(input_char);		// Put back last character into stream		*input_stream >> single_name;					// Read in a name (delimited by non alnum char)				// Look-up the single name in the correlator array		// Find out if a char token substitution is required		for (int i=0; i<array_length; i++)												// Search entire correlator			if (correlator[i].name==single_name)										// If a match is found...			{				single_name=correlator[i].token;											// Substitute name for token				break;																								// Break out of loop			}		output_string=output_string+single_name;									// Append to output_string	}	reset_input();																							// Reset istrstream}// Define method to convert user string to calc string, whilst also returning list of// unidentified user names found in user stringvoid calc_preprocessor::preprocess (string_class input_string,																		string_class &output_string,																		ulist<string_object> *unidentified){	unidentified->clearlist();																// Clear referenced list	output_string="";																					// Initialise output_string	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	string_class single_name;																	// For single name read in	char input_char;																					// For piecewise char input			while (*input_stream)											// Scan entire input string using input_stream	{			// Read input, storing chars read into output_string, until alpha char found		while (input_stream->get(input_char) && (!isalpha(input_char) ))			output_string=output_string+input_char;				// Break out of while loop if end of stream encountered		if (!*input_stream)			break;				input_stream->putback(input_char);		// Put back last character into stream		*input_stream >> single_name;					// Read in a name (delimited by non alnum char)				// Look-up the single name in the correlator array		// Find out if a char token substitution is required		int found=0;																							// Found flag		for (int i=0; i<array_length; i++)												// Search entire correlator			if (correlator[i].name==single_name)										// If a match is found...			{				found=1;																							// Flag the match found				single_name=correlator[i].token;											// Substitute name for token				break;																								// Break out of loop			}				if (!found)		{	// corresponding token not found for name, add name to unidentified list			string_object not_found(single_name);										// Build string_object			unidentified->add(not_found, DATA, ASCENDING);					// Add to list		}		output_string=output_string+single_name;									// Append to output_string	}	reset_input();																							// Reset istrstream}void calc_preprocessor::postprocess (const string_class &input_string,																		 string_class &postprocessed_string){	set_input(input_string);																	// Set istrstream to point to																														// copy of input_string	unsigned char input_char;																	// For piecewise char input	char output_string[1000]="";															// For holding output	char append_string[1000]="";															// For expanded string	char current_letter[2]=" ";																// Array holding one char+NULL		while (*input_stream)											// Scan entire input string using input_stream		{		*input_stream >> input_char;											// Read in single char from stream				if (!*input_stream)																// If end of input_stream reached...			break;																					// break out of the loop					// Use input_char as index for inverse_correlator array		if (inverse_correlator[(int)input_char]!="")			// If an expand string is present...		{	// Substitute string for single character			inverse_correlator[(int)input_char].string_copy(append_string);		// Extract string			strcat(output_string,append_string);						// Append expansion-string to output		}		else		{			current_letter[0]=input_char;										// Else no translation required...			strcat(output_string,current_letter);						// Append single char to output			}	}	reset_input();																			// Reset istrstream	postprocessed_string=output_string;									// Return output_string}// Define method for initialising input_streamstatus calc_preprocessor::set_input(string_class input_string){	if (input_stream!=NULL)																					// Stream already set-up		reset_input();																								// so reset the stream.	// istrstream objects can only operate on char arrays	// Extract char array from input_string, allocating mem to hold the copy	input_char_array=new char[input_string.length()+1];	input_string.string_copy(input_char_array);		input_stream = new istrstream(input_char_array);							// Initialise input_stream	return SUCCESS;}// Define method for terminating input_streamstatus calc_preprocessor::reset_input(){	if (input_stream!=NULL)															// Stream okay to reset	{		delete input_stream;															// Deallocate stream		input_stream=NULL;		delete[] input_char_array;												// Deallocate associated char array		input_char_array=NULL;		return SUCCESS;	}	else	{		cout << "WARNING - trying to reset a non-set input stream\n";			// Steam not inited		return ERROR;	}}